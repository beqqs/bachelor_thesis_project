\section{Fuzzy Matching}
Fuzzy matching is a technique that finds similarities between text strings, even when they are not the same.
In this thesis, the python library \textbf{RapidFuzz} is used, which is a fast string matching library.
It helps finding similarities between the string in case of misspellings, typographical errors or variations in wording.
Unlike exact matching, which would only identify a true or false statement for an exact match, fuzzy matching algorithms measure similarities via edit distance or partial ratio comparisons to determine how closely the strings resemble each other.
The partial ratio from RapidFuzz uses two strings as an input and outputs an integer in the range [0,100] depending on how closely they are similar.
By using fuzzy matching with RapidFuzz, this work ensures that variations and inconsistencies in textual data do not compromise the quality of the results, supporting more reliable data processing and analysis.


1.
\begin{algorithm}
\caption{Query\_databases}
\label{alg:querydb}
\KwIn{API URL (\texttt{queryURL })}
\KwOut{Generated BibTeX file}

$response \gets$ send GET request to \texttt{queryURL} and receive JSON data\;

$bibEntries \gets$ empty list\;

\ForEach{$entry$ in $response$}{
    $DOI \gets entry.DOI$\;
    $Title \gets entry.title$\;
    $Note \gets entry.cited\_by\_count$\;
    $Journal \gets entry.journal$\;
    $Author \gets entry.author$\;
    $Type \gets entry.publication\_type$\;

    create BibTeX entry with $DOI$, $Title$, $Note$, $Journal$, $Author$, and $Type$\;
    append BibTeX entry to $bibEntries$\;
}

save $bibEntries$ as BibTeX file\;

\end{algorithm}


\begin{algorithm}[H]
\caption{Normalize\_authors}
\label{test1}
\KwIn{BibTeX file}
\KwOut{Updated BibTeX file}

\ForEach{entry}{
    $author \gets$ $entry.author$\;
    $name\_parts \gets$ split $author$ by spaces or hyphen\;
    $abbr \gets$ empty list\;
    \If{$name\_parts_{|name\_parts|-1}$ contains ``.''}{\texttt{skip entry}\;}
    \For{$i \gets 1$ to $|name\_parts|-1$}{
        \eIf{$name\_parts_i$ contains ``.'' \textbf{or} $|name\_parts_i|<2$}{
            \texttt{skip $name\_parts_i$}\;
        }{
            add first letter of $name\_parts_i$ + ``.'' to $abbr$\;
        }
    }
    $lname \gets name\_parts_{|name\_parts|-1}$\;
    $newAuthor \gets$  $lname$ + $abbr$ \;
  $entry.author\gets$  $newAuthor$\;
}
save BibTeX file\;
\end{algorithm}

\begin{algorithm}
\caption{Combine\_bib\_files}
\label{alg:comb}
\KwIn{Three BibTeX files: \texttt{openalex.bib}, \texttt{DBLP.bib}, \texttt{Scopus.bib}}
\KwOut{Merged BibTeX file: \texttt{merged.bib}}

$mergedEntries \gets$ empty list\;

$allEntries \gets$ load entries from \texttt{openalex.bib}, \texttt{DBLP.bib}, and \texttt{Scopus.bib}\;

\ForEach{$entry$ in $allEntries$}{
    \If{$entry.DOI$ exists and is in $mergedEntries$}{
        skip $entry$\;
    }
    \ElseIf{$entry.year$ exists in $mergedEntries$}{
        \If{fuzzy match($entry.title$, $mergedEntries.title$) $>$ 90\% \textbf{and} fuzzy match($entry.author$, $mergedEntries.author$) $>$ 90\%}{
            skip $entry$\;
        }
        \Else{
            append $entry$ to $mergedEntries$\;
        }
    }
    \Else{
        append $entry$ to $mergedEntries$\;
    }
}
save $mergedEntries$ as $merged.bib$\;

\end{algorithm}