@ARTICLE{Jarraya_2007,title={Automatic Verification and Performance Analysis of Time-Constrained SysML Activity Diagrams},year={2007},author={Yosr Jarraya and Yosr Jarraya and Andrei Soeanu and Andrei Soeanu and Mourad Debbabi and Mourad Debbabi and Fawzi Hassaïne and Fawzi Hassaïne},doi={10.1109/ecbs.2007.22},pmid={null},pmcid={null},mag_id={2111755821},journal={null},abstract={We present in this paper a new approach for the automatic verification and performance analysis of SysML activity diagrams. Since timeliness is important in the design and analysis of real-time systems, we annotate activity diagrams with time constraints. In order to apply the model checking technique, we use discrete-time Markov chains (DTMC) as a semantic interpretation of such SysML models wherein communication is restricted to synchronization. Thus, we describe a mapping procedure of SysML activity diagrams to their corresponding DTMC and use PRISM model checker for the assessment and evaluation of performance characteristics. Finally, we apply our methodology on a real-life case study meant to assess a systems engineering behavioral model of a photo-camera device}}
@ARTICLE{Debbabi_2010,title={Verification and Validation in Systems Engineering: Assessing UML/SysML Design Models},year={2010},author={Mourad Debbabi and Mourad Debbabi and Fawzi Hassane and Fawzi Hassane and Yosr Jarraya and Yosr Jarraya and Andrei Soeanu and Andrei Soeanu and Andrei Soeanu and Luay Alawneh and Luay Alawneh},doi={null},pmid={null},pmcid={null},mag_id={229556925},journal={null},abstract={Verification and validation represents an important process used for the quality assessment of engineered systems and their compliance with the requirements established at the beginning of or during the development cycle. Debbabi and his coauthors investigate methodologies and techniques that can be employed for the automatic verification and validation of systems engineering design models expressed in standardized modeling languages. Their presentation includes a birds eye view of the most prominent modeling languages for software and systems engineering, namely the Unified Modeling Language (UML) and the more recent Systems Modeling Language (SysML). Moreover, it elaborates on a number of quantitative and qualitative techniques that synergistically combine automatic verification techniques, program analysis, and software engineering quantitative methods applicable to design models described in these modeling languages. Each of these techniques is additionally explained using a case study highlighting the process, its results, and resulting changes in the system design. Researchers in academia and industry as well as students specializing in software and systems engineering will find here an overview of state-of-the-art validation and verification techniques. Due to their close association with the UML standard, the presented approaches are also applicable to industrial software development.}}
@ARTICLE{Milner_1999,title={Communicating and Mobile Systems: the Pi-Calculus},year={1999},author={Robin Milner and Robin Milner},doi={null},pmid={null},pmcid={null},mag_id={1603799276},journal={null},abstract={Glossary Part I. Communicating Systems: 1. Introduction 2. Behaviour of automata 3. Sequential processes and bisimulation 4. Concurrent processes and reaction 5. Transitions and strong equivalence 6. Observation equivalence: theory 7. Observation equivalence: examples Part II. The pi-Calculus: 8. What is mobility? 9. The pi-calculus and reaction 10. Applications of the pi-calculus 11. Sorts, objects and functions 12. Commitments and strong bisimulation 13. Observation equivalence and examples 14. Discussion and related work Bibliography Index.}}
@ARTICLE{Kwiatkowska_2011,title={PRISM 4.0: verification of probabilistic real-time systems},year={2011},author={Marta Kwiatkowska and Marta Kwiatkowska and Gethin Norman and Gethin Norman and David Parker and David Parker},doi={10.1007/978-3-642-22110-1_47},pmid={null},pmcid={null},mag_id={1862398452},journal={null},abstract={This paper describes a major new release of the PRISMprobabilistic model checker, adding, in particular, quantitative verification of (priced) probabilistic timed automata. These model systems exhibiting probabilistic, nondeterministic and real-time characteristics. In many application domains, all three aspects are essential; this includes, for example, embedded controllers in automotive or avionic systems, wireless communication protocols such as Bluetooth or Zigbee, and randomised security protocols. PRISM, which is open-source, also contains several new components that are of independent use. These include: an extensible toolkit for building, verifying and refining abstractions of probabilistic models; an explicit-state probabilistic model checking library; a discrete-event simulation engine for statistical model checking; support for generation of optimal adversaries/strategies; and a benchmark suite.}}
@ARTICLE{Carneiro_2008,title={Mapping SysML State Machine Diagram to Time Petri Net for Analysis and Verification of Embedded Real-Time Systems with Energy Constraints},year={2008},author={Ermeson Carneiro and Ermeson Carneiro and E. Carneiro and Paulo Maciel and Paulo Maciel and Gustavo Callou and Gustavo Callou and Eduardo Tavares and Eduardo Tavares and Bruno Nogueira and Bruno Nogueira},doi={10.1109/enics.2008.19},pmid={null},pmcid={null},mag_id={2147382878},journal={null},abstract={The main objective of this paper is to propose a solution for modeling, analysis and verification of embedded real-time systems with energy constraints. For that, we combine functionalities of the SysML models and annotation from MARTE with the advantages of using time Petri net. This formalism allows analysis and verification of functional, timing and energy requirements in early phases of the development lifecycle. In order to depict the practically usability of the proposed method, a real-world case study is presented, namely, pulse-oximeter. Experimental results have demonstrated an accuracy of 96% using the proposed formal method in comparison with the values obtained with the hardware platform.}}
@ARTICLE{Andrade_2009,title={A Methodology for Mapping SysML Activity Diagram to Time Petri Net for Requirement Validation of Embedded Real-Time Systems with Energy Constraints},year={2009},author={Ermeson Andrade and Ermeson Andrade and Paulo Maciel and Paulo Maciel and Gustavo Callou and Gustavo Callou and Bruno Nogueira and Bruno Nogueira},doi={10.1109/icds.2009.19},pmid={null},pmcid={null},mag_id={2171958237},journal={null},abstract={In this paper we use the Activity diagram of the System Modeling Language (SysML) in combination with the new UML profile for Modeling and Analysis of Real-Time and Embedded systems (MARTE) in order to validate functional, timing and low power requirements in early phases of the embedded system development life-cycle. However, SysML lacks a formal semantics and hence it is not possible to apply, directly, mathematical techniques on SysML models for system validation. Thus, a novel approach for automatic translation of SysML Activity diagram into Time Petri Net with Energy constraints (ETPN) is proposed. In order to depict the practical usability of the proposed method, a case study is presented, namely, pulse-oximeter. Besides, the estimates obtained (execution time and energy consumption) from the model are 95% close to the respective measures obtained from the real hardware platform.}}
@ARTICLE{Debbabi_2010,title={Verification and Validation in Systems Engineering},year={2010},author={Mourad Debbabi and Mourad Debbabi and Fawzi Hassaïne and Fawzi Hassaïne and Yosr Jarraya and Yosr Jarraya and Yosr Jarraya and Andrei Soeanu and Andrei Soeanu and Andrei Soeanu and Luay Alawneh and Luay Alawneh},doi={10.1007/978-3-642-15228-3},pmid={null},pmcid={null},mag_id={43911128},journal={null},abstract={null}}
@ARTICLE{Ando_2013,title={Formalization and Model Checking of SysML State Machine Diagrams by CSP},year={2013},author={Takahiro Ando and Takahiro Ando and Hirokazu Yatsu and Hirokazu Yatsu and Weiqiang Kong and Weiqiang Kong and Kenji Hisazumi and Kenji Hisazumi and Akira Fukuda and Akira Fukuda},doi={10.1007/978-3-642-39646-5_9},pmid={null},pmcid={null},mag_id={156802673},journal={null},abstract={SysML state machine diagrams are used to describe the behavior of blocks in the system under consideration. The work in [1] proposed a formalization of SysML state machine diagrams in which the diagrams were translated into CSP# processes that could be verified by the state-of-the-art model checker PAT. In this paper, we make several modifications and add new rules to the translation described in that work. First, we modify three translation rules, which we think are inappropriately defined according to the SysML definition of state machine diagrams. Next, we add new translation rules for two components of the diagrams – junction and choice pseudostates – which have not been dealt with previously. As the contribution of this work, we can achieve more reasonable verification results for more general SysML state machine diagrams.}}
@ARTICLE{Apvrille_2013,title={Static analysis techniques to verify mutual exclusion situations within SysML models},year={2013},author={Ludovic Apvrille and Ludovic Apvrille and Pierre de Saqui-Sannes and Pierre de Saqui-Sannes},doi={10.1007/978-3-642-38911-5_6},pmid={null},pmcid={null},mag_id={197065186},journal={null},abstract={AVATAR is a real-time extension of SysML supported by the TTool open-source toolkit. So far, formal verification of AVATAR models has relied on reachability techniques that face a state explosion problem. The paper explores a new avenue: applying structural analysis to AVATAR models, so as to identify mutual exclusion situations. In practice, TTool translates a subset of an AVATAR model into a Petri net and solves an equation system built upon the incidence matrix of the net. TTool implements a push-button approach and displays verification results at the AVATAR model level. The approach is not restricted to AVATAR and may be adapted to other UML profiles.}}
@ARTICLE{Gomaa_2011,title={Software Modeling and Design: UML, Use Cases, Patterns, and Software Architectures},year={2011},author={Hassan Gomaa and Hassan Gomaa},doi={null},pmid={null},pmcid={null},mag_id={624948933},journal={null},abstract={This book covers all you need to know to model and design software applications from use cases to software architectures in UML and shows how to apply the COMET UML-based modeling and design method to real-world problems. The author describes architectural patterns for various architectures, such as broker, discovery, and transaction patterns for service-oriented architectures, and addresses software quality attributes including maintainability, modifiability, testability, traceability, scalability, reusability, performance, availability, and security. Complete case studies illustrate design issues for different software architectures: a banking system for client/server architecture, an online shopping system for service-oriented architecture, an emergency monitoring system for component-based software architecture, and an automated guided vehicle for real-time software architecture. Organized as an introduction followed by several short, self-contained chapters, the book is perfect for senior undergraduate or graduate courses in software engineering and design, and for experienced software engineers wanting a quick reference at each stage of the analysis, design, and development of large-scale software systems.}}
@ARTICLE{Holt_2008,title={SysML for Systems Engineering},year={2008},author={John Holt and John Holt and John Holt and Simon Perry and Simon Perry},doi={null},pmid={null},pmcid={null},mag_id={1481029116},journal={null},abstract={This book provides a pragmatic introduction to the systems engineering modelling language, the SysML, aimed at systems engineering practitioners at any level of ability, ranging from students to experts. The theoretical aspects and syntax of SysML are covered and each concept is explained through a number of example applications.}}
@ARTICLE{Jansen_2003,title={A QoS-oriented extension of UML statecharts},year={2003},author={David N. Jansen and David N. Jansen and Holger Hermanns and Holger Hermanns and Joost-Pieter Katoen and Joost-Pieter Katoen},doi={10.1007/978-3-540-45221-8_7},pmid={null},pmcid={null},mag_id={1540489524},journal={Lecture Notes in Computer Science},abstract={Performance, dependability and quality of service (QoS) are prime aspects of the UML modeling domain. To capture these aspects effectively in a modeling language requires easy-to-use support for the specification and analysis of randomly varying behaviors. This paper introduces an extension of UML statecharts with randomly varying durations, by enriching a specific syntactic construct: The after operator is equipped with (discrete or continuous) probability distributions, determining the duration of the delay caused by this operator. The semantics of this extension is given in terms of a variant of stochastic automata. It is shown how existing model-checking tools can be used to calculate model-inherent QoS characteristics automatically. We study a UML model of an automatic teller machine scenario using this approach.}}
@ARTICLE{Forejt_2011,title={Automated Verification Techniques for Probabilistic Systems},year={2011},author={Vojtěch Forejt and Vojtech Forejt and Marta Kwiatkowska and Marta Kwiatkowska and Gethin Norman and Gethin Norman and David Parker and David Parker},doi={10.1007/978-3-642-21455-4_3},pmid={null},pmcid={null},mag_id={1809182522},journal={null},abstract={This tutorial provides an introduction to probabilistic model checking, a technique for automatically verifying quantitative properties of probabilistic systems. We focus on Markov decision processes (MDPs), which model both stochastic and nondeterministic behaviour. We describe methods to analyse a wide range of their properties, including specifications in the temporal logics PCTL and LTL, probabilistic safety properties and cost- or reward-based measures. We also discuss multi-objective probabilistic model checking, used to analyse trade-offs between several different quantitative properties. Applications of the techniques in this tutorial include performance and dependability analysis of networked systems, communication protocols and randomised distributed algorithms. Since such systems often comprise several components operating in parallel, we also cover techniques for compositional modelling and verification of multi-component probabilistic systems. Finally, we describe three large case studies which illustrate practical applications of the various methods discussed in the tutorial.}}
@ARTICLE{Behrmann_2004,title={A Tutorial on UPPAAL},year={2004},author={Gerd Behrmann and Gerd Behrmann and Albert David and Alexandre David and Kim Guldstrand Larsen and Kim Guldstrand Larsen},doi={10.1007/978-3-540-30080-9_7},pmid={null},pmcid={null},mag_id={1962072139},journal={null},abstract={This is a tutorial paper on the tool Uppaal. Its goal is to
be a short introduction on the flavor of timed automata implemented in
the tool, to present its interface, and to explain how to use the tool. The
contribution of the paper is to provide reference examples and modeling
patterns.}}
@ARTICLE{Knorreck_2011,title={TEPE: a SysML language for time-constrained property modeling and formal verification},year={2011},author={Daniel Knorreck and Daniel Knorreck and Ludovic Apvrille and Ludovic Apvrille and Pierre de Saqui-Sannes and Pierre de Saqui-Sannes},doi={10.1145/1921532.1921556},pmid={null},pmcid={null},mag_id={1965685836},journal={ACM Sigsoft Software Engineering Notes},abstract={Using UML or SysML models in a verification-centric method requires a property expression language, a formal semantics, and a tool. The paper introduces TEPE, a graphical TEmporal Property Expression language based on SysML parametric diagrams. TEPE enriches the expressiveness of other common property languages in particular with the notion of physical time and unordered signal reception. TEPE is further instantiated in the AVATAR real-time UML profile. TTool, an open-source toolkit, implements a press-button approach for the formal verification of AVATAR-TEPE properties with UPPAAL. An elevator system serves as example}}
@ARTICLE{Carrillo_2012,title={Formalizing and verifying compatibility and consistency of SysML blocks},year={2012},author={Oscar Carrillo and Oscar Carrillo and Samir Chouali and Samir Chouali and Hassan Mountassir and Hassan Mountassir},doi={10.1145/2237796.2237813},pmid={null},pmcid={null},mag_id={1998155798},journal={ACM Sigsoft Software Engineering Notes},abstract={The objective of this paper is to define an approach to formalize and verify the SysML blocks in a refinement process. We propose to specify system architecture with SysML Block Definition Diagram, this diagram is then analyzed and decomposed into several sub-blocks in order to verify their compatibility. The structural architecture of an abstract block is given by the Internal Block Diagram (IBD) which defines the communication links between sub-blocks. The compatibility verification between sub-blocks is only made on linked sub-blocks. The behaviour of each sub-block is described by an interface automaton which species the invocations exchanged with its environment. The verification between blocks is translated into consistency verification between the blocks and compatibility verification between their interface automata. Incompatibilities can be inconsistent at architecture level and at communication level if there are deadlocks during the interaction between sub-blocks. Once the verification is established between the sub-blocks, the abstract block can be then substituted by the sub-blocks which compose it.}}
@ARTICLE{Ouchani_2014,title={A formal verification framework for SysML activity diagrams},year={2014},author={Samir Ouchani and Samir Ouchani and Otmane Aït Mohamed and Otmane Ait Mohamed and Otmane Ait Mohamed and Otmane Ait Mohamed and Mourad Debbabi and Mourad Debbabi},doi={10.1016/j.eswa.2013.10.064},pmid={null},pmcid={null},mag_id={2047987805},journal={Expert Systems With Applications},abstract={null}}
@ARTICLE{Kaliappan_2008,title={Designing and Verifying Communication Protocols Using Model Driven Architecture and Spin Model Checker},year={2008},author={Prabhu Shankar Kaliappan and Prabhu Shankar Kaliappan and Hartmut Koenig and Hartmut Koenig and Vishnu Kumar Kaliappan and Vishnu Kumar Kaliappan and Vishnu Kumar Kaliappan and Vishnu Kumar Kaliappan},doi={10.1109/csse.2008.976},pmid={null},pmcid={null},mag_id={2071301479},journal={null},abstract={The need of communication protocols in todaypsilas environment increases as much as the network explores. Many new kinds of protocols, e.g. for information sharing, security, etc., are being developed day-to-day which often leads to rapid, premature developments. Many protocols have not scaled to satisfy important properties like deadlock and livelock freedom, since MDA focuses on the rapid development rather than on the quality of the developed models. In order to fix the above, we introduce a 2-Phase strategy based on the UML state machine and sequence diagram to satisfy the properties of communication protocols. We convert these models into PROMELA code for execution on the SPIN model checker. The results are compared with the developed UML models.}}
@ARTICLE{George_2012,title={Improving design quality by automatic verification of activity diagram syntax},year={2012},author={Renu George and Renu George and Philip Samuel and Philip Samuel},doi={10.1109/isda.2012.6416555},pmid={null},pmcid={null},mag_id={2094697271},journal={null},abstract={The quality of the product is an important issue in software development and quality assurance is an important aspect of any software design. One of the factors that affect the software quality is the correctness of its design. Any defect in the design can lead to high cost for defect correction. Activity diagrams are used to model the dynamic or behavioral aspects of the system. In this paper, an algorithm that analyzes activity diagrams and automatically verifies the syntax of each of its components is presented. Incomplete workflow can lead to incorrect results and a missing edge can lead to incomplete workflow. Mismatch in fork, join pair can lead to concurrency issues and synchronization problems. Detection of such errors in the design phase ensures product quality. The activity diagram is transformed to its components and analysis is performed on the components based on the syntactic specifications to detect errors. The workflow in the diagram and syntactic correctness of control flow are analyzed by the algorithm. Errors, if any, in the diagram are identified and a log of the errors is maintained in the error table. Analysis of the activity diagram and verification of its syntax can help in the development of a product whose quality is assured.}}
@ARTICLE{Liu_2013,title={USMMC: a self-contained model checker for UML state machines},year={2013},author={Shuang Liu and Shuang Liu and Shuang Liu and Shuang Liu and Yang Liu and Yang Liu and Yang Liu and Jun Sun and Jun Sun and Ming Zheng and Manchun Zheng and Bimlesh Wadhwa and Bimlesh Wadhwa and Jin Song Dong and Jin Song Dong},doi={10.1145/2491411.2494595},pmid={null},pmcid={null},mag_id={2095507077},journal={null},abstract={UML diagrams are gaining increasing usage in Object-Oriented system designs. UML state machines are specifically used in modeling dynamic behaviors of classes. It has been widely agreed that verification of system designs at an early stage will dramatically reduce the development cost. Tool support for verification UML designs can also encourage consistent usage of UML diagrams throughout the software development procedure. In this work, we present a tool, named USMMC, which turns model checking of UML state machines into practice. USMMC is a self-contained toolkit, which provides editing, interactive simulation as well as powerful model checking support for UML state machines. The evaluation results show the effectiveness and scalability of our tool.}}
@ARTICLE{Jarraya_2009,title={On the Meaning of SysML Activity Diagrams},year={2009},author={Yosr Jarraya and Yosr Jarraya and Mourad Debbabi and Mourad Debbabi and Jamal Bentahar and Jamal Bentahar},doi={10.1109/ecbs.2009.25},pmid={null},pmcid={null},mag_id={2099480557},journal={null},abstract={In this paper, we aim to ascribe a meaning to SysML activity diagrams. To this end, we propose a dedicated algebraic-like language, namely activity calculus, and an operational semantics that provides a rigorous and intuitive operational understanding of the behavior captured by the diagram. The semantics covers advanced control flows such as unstructured loops and concurrent control flows. Further more, our approach allows non well-formed control flows, with mixed and nested forks and joins. The probabilistic behaviors as specified in SysML are also considered. This formalization allows us to build a sound framework for the verification and validation of systems design expressed in SysML activity diagrams.}}
@ARTICLE{Hoare_1985,title={Communicating sequential processes},year={1985},author={C. A. R. Hoare and C. A. R. Hoare},doi={null},pmid={null},pmcid={null},mag_id={2110425399},journal={null},abstract={This paper suggests that input and output are basic primitives of programming and that parallel composition of communicating sequential processes is a fundamental program structuring method. When combined with a development of Dijkstra's guarded command, these concepts are surprisingly versatile. Their use is illustrated by sample solutions of a variety of a familiar programming exercises.}}
@ARTICLE{Eshuis_2006,title={Symbolic model checking of UML activity diagrams},year={2006},author={Rik Eshuis and Rik Eshuis},doi={10.1145/1125808.1125809},pmid={null},pmcid={null},mag_id={2120450154},journal={ACM Transactions on Software Engineering and Methodology},abstract={Two translations from activity diagrams to the input language of NuSMV, a symbolic model verifier, are presented. Both translations map an activity diagram into a finite state machine and are inspired by existing statechart semantics. The requirements-level translation defines state machines that can be efficiently verified, but are a bit unrealistic since they assume the perfect synchrony hypothesis. The implementation-level translation defines state machines that cannot be verified so efficiently, but that are more realistic since they do not use the perfect synchrony hypothesis. To justify the use of the requirements-level translation, we show that for a large class of activity diagrams and certain properties, both translations are equivalent: regardless of which translation is used, the outcome of model checking is the same. Moreover, for linear stuttering-closed properties, the implementation-level translation is equivalent to a slightly modified version of the requirements-level translation. We use the two translations to model check data integrity constraints for an activity diagram and a set of class diagrams that specify the data manipulated in the activities. Both translations have been implemented in two tools. We discuss our experiences in applying both translations to model check some large example activity diagrams.}}
@ARTICLE{Kaliappan_2008,title={Designing and Verifying Communication Protocols Using Model Driven Architecture and Spin Model Checker},year={2008},author={Prabhu Shankar Kaliappan and Prabhu Shankar Kaliappan and Hartmut Koenig and Hartmut Koenig},doi={10.4236/jsea.2008.11003},pmid={null},pmcid={null},mag_id={2141178378},journal={Journal of Software Engineering and Applications},abstract={The need of communication protocols in today’s environment increases as much as the network explores. Many new kinds of protocols, e.g. for information sharing, security, etc., are being developed day-to-day which often leads to rapid, premature developments. Many protocols have not scaled to satisfy important properties like deadlock and livelock freedom, since MDA focuses on the rapid development rather than on the quality of the developed models. In order to fix the above, we introduce a 2-Phase strategy based on the UML state machine and sequence diagram. The state machine is converted into PROMELA code as a protocol model and its properties are derived from the sequence diagram as Linear Temporal Logic (LTL) through automation. The PROMELA code is interpreted through the SPIN model checker, which helps to simulate the behavior of protocol. Later the automated LTL properties are supplemented to the SPIN for the verification of protocol properties. The results are compared with the developed UML model and SPIN simulated model. Our test results impress the designer to verify the expected results with the system design and to identify the errors which are unnoticed during the design phase.}}
@ARTICLE{Segala_1995,title={A Compositional Trace-Based Semantics for Probabilistic Automata},year={1995},author={Roberto Segala and Roberto Segala},doi={10.1007/3-540-60218-6_17},pmid={null},pmcid={null},mag_id={2168098347},journal={null},abstract={We extend the trace semantics for labeled transition systems to a randomized model of concurrent computation. The main objective is to obtain a compositional semantics. The role of a trace in the randomized model is played by a probability distribution over traces, called a trace distribution. We show that the preorder based on trace distribution inclusion is not a precongruence, and we build an elementary context, called the principal context, that is sufficiently powerful to characterize the coarsest precongruence that is contained in the trace distribution preorder. Finally, we introduce a notion of a probabilistic forward simulation and we prove that it is sound for the trace distribution precongruence. An important characteristic of probabilistic forward simulations is that they relate states to probability distributions over states.}}
@ARTICLE{Gomaa_null,title={Software Modeling and Design},year={null},author={Hassan Gomaa and Hassan Gomaa},doi={10.1017/cbo9780511779183},pmid={null},pmcid={null},mag_id={4250283107},journal={null},abstract={This book covers all you need to know to model and design software applications from use cases to software architectures in UML and shows how to apply the COMET UML-based modeling and design method to real-world problems. The author describes architectural patterns for various architectures, such as broker, discovery, and transaction patterns for service-oriented architectures, and addresses software quality attributes including maintainability, modifiability, testability, traceability, scalability, reusability, performance, availability, and security. Complete case studies illustrate design issues for different software architectures: a banking system for client/server architecture, an online shopping system for service-oriented architecture, an emergency monitoring system for component-based software architecture, and an automated guided vehicle for real-time software architecture. Organized as an introduction followed by several short, self-contained chapters, the book is perfect for senior undergraduate or graduate courses in software engineering and design, and for experienced software engineers wanting a quick reference at each stage of the analysis, design, and development of large-scale software systems.}}
@ARTICLE{Störrle_2005,title={Towards a Formal Semantics of UML 2.0 Activities.},year={2005},author={Harald Störrle and Harald Störrle and Jan Hendrik Hausmann and Jan Hendrik Hausmann},doi={null},pmid={null},pmcid={null},mag_id={2693416},journal={null},abstract={The new version 2.0 of the Unified Modeling Language (UML) was targeted at improving expressiveness and semantic precision. These developments are particularly evident in activity diagrams which have not only acquired many new features, but a completely new metamodel and semantic foundation. The UML contains some hints that Petri-nets are the inspirational source for the new semantics. In this paper we will investigate how strong the alignment of UML’s activity diagrams to Petri-nets really is. We start by providing a mapping of the basic elements of activity diagrams to Petri-nets and discuss the problems arising when trying to extend this approach to some of the advanced features of activity diagrams, namely exceptions, traverse-to-completion, and streaming. This examination raises several syntactic and semantic questions concerning activities. We conclude that for basic activities, the analogy works pretty well, but for higher-level constructs, no such intuitive connection exists.}}
@ARTICLE{Debbabi_2010,title={Probabilistic Model Checking of SysML Activity Diagrams},year={2010},author={Mourad Debbabi and Mourad Debbabi and Fawzi Hassaïne and Fawzi Hassaïne and Yosr Jarraya and Yosr Jarraya and Yosr Jarraya and Andrei Soeanu and Andrei Soeanu and Andrei Soeanu and Luay Alawneh and Luay Alawneh},doi={10.1007/978-3-642-15228-3_9},pmid={null},pmcid={null},mag_id={95001664},journal={null},abstract={Incorporated modeling and analysis of both functional and non-functional aspects of today’s systems behavior represents a challenging issue in the field of formal methods .}}
@ARTICLE{Abdulkhaleq_2014,title={A Software Safety Verification Method Based on System-Theoretic Process Analysis},year={2014},author={Asim Abdulkhaleq and Asim Abdulkhaleq and Stefan Wagner and Stefan Wagner},doi={10.1007/978-3-319-10557-4_44},pmid={null},pmcid={null},mag_id={118638570},journal={null},abstract={Modern safety-critical systems are increasingly reliant on software. Software safety is an important aspect in developing safety-critical systems, and it must be considered in the context of the system level into which the software will be embedded. STPA (System-Theoretic Process Analysis) is a modern safety analysis approach which aims to identify the potential hazardous causes in complex safety-critical systems at the system level. To assure that these hazardous causes of an unsafe software’s behaviour cannot happen, safety verification involves demonstrating whether the software fulfills those safety requirements and will not result in a hazardous state. We propose a method for verifying of software safety requirements which are derived at the system level to provide evidence that the hazardous causes cannot occur (or reduce the associated risk to a low acceptable level). We applied the method to a cruise control prototype to show the feasibility of the proposed method.}}
@ARTICLE{Baier_2008,title={Principles of Model Checking (Representation and Mind Series)},year={2008},author={Christel Baier and Christel Baier and Joost-Pieter Katoen and Joost-Pieter Katoen},doi={null},pmid={null},pmcid={null},mag_id={125598877},journal={null},abstract={Our growing dependence on increasingly complex computer and software systems necessitates the development of formalisms, techniques, and tools for assessing functional properties of these systems. One such technique that has emerged in the last twenty years is model checking, which systematically (and automatically) checks whether a model of a given system satisfies a desired property such as deadlock freedom, invariants, or request-response properties. This automated technique for verification and debugging has developed into a mature and widely used approach with many applications. Principles of Model Checking offers a comprehensive introduction to model checking that is not only a text suitable for classroom use but also a valuable reference for researchers and practitioners in the field. The book begins with the basic principles for modeling concurrent and communicating systems, introduces different classes of properties (including safety and liveness), presents the notion of fairness, and provides automata-based algorithms for these properties. It introduces the temporal logics LTL and CTL, compares them, and covers algorithms for verifying these logics, discussing real-time systems as well as systems subject to random phenomena. Separate chapters treat such efficiency-improving techniques as abstraction and symbolic manipulation. The book includes an extensive set of examples (most of which run through several chapters) and a complete set of basic results accompanied by detailed proofs. Each chapter concludes with a summary, bibliographic notes, and an extensive list of exercises of both practical and theoretical nature.}}
@ARTICLE{Liu_2013,title={A Formal Semantics for Complete UML State Machines with Communications},year={2013},author={Shuang Liu and Shuang Liu and Shuang Liu and Shuang Liu and Yang Liu and Yang Liu and Yang Liu and Étienne André and Étienne André and Christine Choppy and Christine Choppy and Jun Sun and Jun Sun and Bimlesh Wadhwa and Bimlesh Wadhwa and Jin Song Dong and Jin Song Dong},doi={10.1007/978-3-642-38613-8_23},pmid={null},pmcid={null},mag_id={137536751},journal={null},abstract={UML is a widely used notation, and formalizing its semantics is an important issue. Here, we concentrate on formalizing UML state machines, used to express the dynamic behaviour of software systems. We propose a formal operational semantics covering all features of the latest version (2.4.1) of UML state machines specification. We use labelled transition systems as the semantic model, so as to use automatic verification techniques like model checking. Furthermore, our proposed semantics includes synchronous and asynchronous communications between state machines. We implement our approach in USM2C, a model checker supporting editing, simulation and automatic verification of UML state machines. Experiments show the effectiveness of our approach.}}
@ARTICLE{Bérard_2001,title={Systems and Software Verification},year={2001},author={Béatrice Bérard and Béatrice Bérard and Michel Bidoit and Michel Bidoit and Alain Finkel and Alain Finkel and François Laroussinie and François Laroussinie and Antoine Petit and Antoine Petit and Antoine Petit and Laure Petrucci and Laure Petrucci and Philippe Schnoebelen and Philippe Schnoebelen and Philippe Schnoebelen and Pierre McKenzie and Pierre McKenzie},doi={10.1007/978-3-662-04558-9},pmid={null},pmcid={null},mag_id={198918365},journal={null},abstract={null}}
@ARTICLE{Yan_2014,title={Formal Throughput and Response Time Analysis of MARTE Models},year={2014},author={Gaogao Yan and Gaogao Yan and Xun Zhu and Xue-Yang Zhu and Rong Yan and Rongjie Yan and Guangyuan Li and Guangyuan Li and Guangyuan Li},doi={10.1007/978-3-319-11737-9_28},pmid={null},pmcid={null},mag_id={220926404},journal={null},abstract={UML Profile for MARTE is an extension of UML in the domain of real-time and embedded systems. In this paper, we present a method to evaluate throughput and response time of systems described in MARTE models. A MARTE model we consider includes a use case diagram, a deployment diagram and a set of activity diagrams. We transform a MARTE model into a network of timed automata in UPPAAL and use UPPAAL to find the possible best throughput and response time of a system, and the best solution in the worst cases for both of them. The two case studies demonstrate our support of decision makings for designers in analyzing models with different parameters, such as the number of concurrent activities and the number of resources. In the first case study, we analyze the throughput of a system deploying on multiprocessor platforms. The second analyzes the response time of an order processing system.}}
@ARTICLE{Larsen_1989,title={Bisimulation Through Probabilistic Testing.},year={1989},author={Kim Guldstrand Larsen and Kim Guldstrand Larsen and Arne Skou and Arne Skou},doi={null},pmid={null},pmcid={null},mag_id={259536784},journal={null},abstract={Abstract   We propose a language for testing concurrent processes and examine its strength in terms of the processes that are distinguished by a test. By using probabilistic transition systems as the underlying semantic model, we show how a testing algorithm can distinguish, with a probability arbitrarily close to one, between processes that are not bisimulation equivalent. We also show a similar result (in a slightly stronger form) for a new process relation called    2  3  -  bisimulation   —which lies strictly between that of simulation and bisimulation. Finally, the ultimately strength of the testing language is shown to identify a new process relation called probabilistic bisimulation—which is strictly stronger than bisimulation.}}
@ARTICLE{Suryadevara_2012,title={Timed Automata Modeling of CCSL Constraints},year={2012},author={Jagadish Suryadevara and Jagadish Suryadevara and Ling Yin and Ling Yin},doi={null},pmid={null},pmcid={null},mag_id={580248071},journal={null},abstract={The UML profile MARTE includes CCSL (Clock Constraint Specification Language) for specifying logical (synchronous/asynchronous) as well as chronometric timing constraints. A reference semantics for CCSL has been defined and transformation techniques proposed e.g. CCSL to Promela. In this paper, we present transformation of CCSL into timed automata, to enable verification with UPPAAL modelchecker. Further, we discuss how the transformation approach supports modeling multiple timebases, timebase relationships and corresponding timing constraints.}}
@ARTICLE{Marinescu_2014,title={Analyzing Industrial Architectural Models by Simulation and Model-Checking},year={2014},author={Raluca Marinescu and Raluca Marinescu and Henrik Kaijser and Henrik Kaijser and Marius Mikučionis and Marius Mikucionis and Cristina Seceleanu and Cristina Seceleanu and Henrik Lönn and Henrik Lönn and Albert David and Alexandre David},doi={10.1007/978-3-319-17581-2_13},pmid={null},pmcid={null},mag_id={650936524},journal={null},abstract={The software architecture of any automotive system has to be decided well in advance of production, so it is very desirable to assess its quality in order to obtain quick indications of errors at early design phases. In this paper, we present a constellation of analysis techniques for architectural models described in EAST-ADL. The methods are complementary in terms of covering EAST-ADL model analysis against a rich set of requirements, and in terms of the varying degree of confidence in the provided guarantees. Based on the needs of the current model-driven development in a chosen automotive context, we propose three analysis techniques of EAST-ADL architectural models, in an attempt to tackle some of the exposed design needs: simulation of EAST-ADL functions in Simulink, model-checking EAST-ADL models with timed automata semantics, and statistical model-checking in UPPAAL, applied on an automatically generated network of timed automata. An industrial Brake-by-Wire prototype is the case study on which we show the potential of simulating EAST-ADL models in Simulink, model-checking downscale EAST-ADL models, as well statistical model-checking of full model versions, in order to tame verification scalability problems.}}
@ARTICLE{Leitner-Fischer_2011,title={Quantitative analysis of UML Models},year={2011},author={Florian Leitner-Fischer and Florian Leitner-Fischer and Stefan Leue and Stefan Leue},doi={null},pmid={null},pmcid={null},mag_id={825702603},journal={null},abstract={When developing a safety-critical system it is essential to obtain an assessment of different design alternatives. In particular, an early safety assessment of the architectural design of a system is desirable. In spite of the plethora of available formal quantitative analysis methods it is still difficult for software and system architects to integrate these techniques into their every day work. This is mainly due to the lack of methods that can be directly applied to architecture level models, for instance given as UML diagrams. Our approach bridges this gap and improves the integration of quantitative safety analysis methods into the development process. We propose a UML profile that allows for the specification of all inputs needed for the analysis at the level of a UML model. The QuantUM tool which we have developed, automatically translates an UML model into an analysis model. Furthermore, the results gained from the analysis are lifted to the level of the UML specification or other high-level formalism to further facilitate the process. Thus the analysis model and the formal methods used during the analysis are hidden from the user.}}
@ARTICLE{Rodríguez_2014,title={Execution and Verification of UML State Machines with Erlang},year={2014},author={Ricardo Rodríguez and Ricardo J. Rodríguez and Ricardo J. Rodríguez and Lars–Åke Fredlund and Lars-Åke Fredlund and Ángel Herranz and Ángel Herranz and Julio Mariño and Julio Mariño},doi={10.1007/978-3-319-10431-7_22},pmid={null},pmcid={null},mag_id={1222965787},journal={null},abstract={Validation of a system design enables to discover specification errors before it is implemented (or tested), thus hopefully reducing the development cost and time. The Unified Modelling Language (UML) is becoming widely accepted for the early specification and analysis of requirements for safety-critical systems, although a better balance between UML’s undisputed flexibility, and a precise unambiguous semantics, is needed. In this paper we introduce UMerL, a tool that is capable of executing and formally verifying UML diagrams (namely, UML state machine, class and object diagrams) by means of a translation of its behavioural information into Erlang. The use of the tool is illustrated with an example in embedded software design.}}
@ARTICLE{Rütten_2004,title={Mathematical Techniques for Analyzing Concurrent and Probabilistic Systems},year={2004},author={Jan Rütten and Jan Rutten and Marta Kwiatkowska and Marta Kwiatkowska and Gethin Norman and Gethin Norman and David Parker and David Parker and D.H. Parker},doi={10.1090/crmm/023},pmid={null},pmcid={null},mag_id={1266757872},journal={null},abstract={On streams and coinduction: Preface Acknowledgments Streams and coinduction Stream calculus Analytical differential equations Coinductive counting Component connectors Key differential equations Bibliography Modelling and verification of probabilistic systems: Preface Introduction Discrete-time Markov chains Markov decision processes Continuous-time Markov chains Probabilistic timed automata Implementation Measure theory and probability Iterative solution methods Bibliography.}}
@ARTICLE{Hoque_2013,title={Early Analysis of Soft Error Effects for Aerospace Applications Using Probabilistic Model Checking},year={2013},author={Khaza Anuarul Hoque and Khaza Anuarul Hoque and Otmane Aït Mohamed and Otmane Ait Mohamed and Otmane Ait Mohamed and Otmane Ait Mohamed and Yvon Savaria and Yvon Savaria and Claude Thibeault and Claude Thibeault},doi={10.1007/978-3-319-05416-2_5},pmid={null},pmcid={null},mag_id={1430091258},journal={null},abstract={SRAM-based FPGAs are increasingly popular in the aerospace industry for their field programmability and low cost. However, they suffer from cosmic radiation induced Single Event Upsets (SEUs), commonly known as soft errors. In safety-critical applications, the dependability of the design is a prime concern since failures may have catastrophic consequences. An early analysis of dependability and performance of such safety-critical applications can reduce the design effort and increases the confidence. This paper introduces a novel methodology based on probabilistic model checking, to analyze the dependability and performability properties of safety-critical systems for early design decisions. Starting from a high-level description of a model, a Markov reward model is constructed from the Control Data Flow Graph (CDFG) of the system and a component characterization library targeting FPGAs. Such an exhaustive model captures all the failures and repairs possible in the system within the radiation environment. We present a case study based on a benchmark circuit to illustrate the applicability of the proposed approach and to demonstrate that a wide range of useful dependability and performability properties can be analyzed using our proposed methodology.}}
@ARTICLE{Vardi_2001,title={Branching vs. Linear Time: Final Showdown},year={2001},author={Moshe Y. Vardi and Moshe Y. Vardi},doi={10.1007/3-540-45319-9_1},pmid={null},pmcid={null},mag_id={1489227129},journal={null},abstract={The discussion of the relative merits of linear- versus branching-time frameworks goes back to early 1980s. One of the beliefs dominating this discussion has been that "while specifying is easier in LTL (linear-temporal logic), verification is easier for CTL (branching-temporal logic)". Indeed, the restricted syntax of CTL limits its expressive power and many important behaviors (e.g., strong fairness) can not be specified in CTL. On the other hand, while model checking for CTL can be done in time that is linear in the size of the specification, it takes time that is exponential in the specification for LTL. Because of these arguments, and for historical reasons, the dominant temporal specification language in industrial use is CTL.In this paper we argue that in spite of the phenomenal success of CTL-based model checking, CTL suffers from several fundamental limitations as a specification language, all stemming from the fact that CTL is a branching-time formalism: the language is unintuitive and hard to use, it does not lend itself to compositional reasoning, and it is fundamentally incompatible with semiformal verification. These inherent limitations severely impede the functionality of CTL-based model checkers. In contrast, the linear-time framework is expressive and intuitive, supports compositional reasoning and semi-formal verification, and is amenable to combining enumerative and symbolic search methods. While we argue in favor of the linear-time framework, we also we argue that LTL is not expressive enough, and discusswhat would be the "ultimate" temporal specification language.}}
@ARTICLE{Cattani_2002,title={Decision Algorithms for Probabilistic Bisimulation},year={2002},author={Silvia Cattani and Stefano Cattani and Roberto Segala and Roberto Segala},doi={10.1007/3-540-45694-5_25},pmid={null},pmcid={null},mag_id={1489359924},journal={null},abstract={We propose decision algorithms for bisimulation relations defined on probabilistic automata, a model for concurrent nondeterministic systems with randomization. The algorithms decide both strong and weak bisimulation relations based on deterministic as well as randomized schedulers. These algorithms extend and complete other known algorithms for simpler relations and models. The algorithm we present for strong probabilistic bisimulation has polynomial time complexity, while the algorithm for weak probabilistic bisimulation is exponential; however we argue that the latter is feasible in practice.}}
@ARTICLE{Friedenthal_2008,title={A Practical Guide to SysML: The Systems Modeling Language},year={2008},author={Sanford Friedenthal and Sanford Friedenthal and Alan Moore and Alan Moore and Rick Steiner and Rick Steiner},doi={null},pmid={null},pmcid={null},mag_id={1495459766},journal={null},abstract={A general purpose graphical modeling language used to specify, analyze, and design systems that may include hardware, software, and personnel, SysML is now being adopted by companies across a broad range of industries, including aerospace and defense, automotive, and IT system developers. This book is the bestselling, authoritative guide to SysML for systems and software engineers, providing a comprehensive and practical resource for modeling systems with SysML. Fully updated to cover newly released version 1.3, it includes a full description of the modeling language along with a quick reference guide, and shows how an organization or project can transition to model-based systems engineering using SysML, with considerations for processes, methods, tools, and training. Numerous examples to help readers understand how SysML can be used in practice, while reference material facilitates studying for the OMG Systems Modeling Professional (OCSMP) Certification Program, designed to test candidates' knowledge of SysML and their ability to use models to represent real-world systems.



Authoritative and comprehensive guide to understanding and implementing SysML
A quick reference guide, including language descriptions and practical examples
Application of model-based methodologies to solve complex system problems
Guidance on transitioning to model-based systems engineering using SysML
Preparation guide for OMG Certified Systems Modeling Professional (OCSMP)

Table of Contents


Part I Introduction


Systems Engineering Overview

Model-Based Systems Engineering3 SysML Language Overview

SysML Language Overview

Part II Language Description 

SysML Language Architecture

Organizing the Model with Packages

Modeling Structure with Blocks 

Modeling Constraints with Parametrics

Modeling Flow-Based Behavior with Activities

Modeling Message-Based Behavior with Interactions

Modeling Event-Based Behavior with State Machines

Modeling Functionality with Use Cases

Modeling Text-Based Requirements and their Relationship?to Design

Modeling Cross-Cutting Relationships with Allocations

Customizing SysML for Specific Domains 

Part III Modeling Examples 

Water Distiller Example Using Functional Analysis

Residential Security System Example Using the Object-Oriented Systems Engineering Method

Part IV Transitioning to Model-Based Systems Engineering 

Integrating SysML into a Systems Development Environment

Deploying SysML into an Organization


APPENDIXES

A-1 SysML Reference Guide

A-2 Cross Reference Guide to the OMG Systems Modeling Professional Certification Program (OCSMP) - NEW}}
@ARTICLE{Baier_2008,title={Principles of Model Checking},year={2008},author={Christel Baier and Christel Baier and Joost-Pieter Katoen and Joost-Pieter Katoen},doi={null},pmid={null},pmcid={null},mag_id={1498432697},journal={null},abstract={Our growing dependence on increasingly complex computer and software systems necessitates the development of formalisms, techniques, and tools for assessing functional properties of these systems. One such technique that has emerged in the last twenty years is model checking, which systematically (and automatically) checks whether a model of a given system satisfies a desired property such as deadlock freedom, invariants, and request-response properties. This automated technique for verification and debugging has developed into a mature and widely used approach with many applications. Principles of Model Checking offers a comprehensive introduction to model checking that is not only a text suitable for classroom use but also a valuable reference for researchers and practitioners in the field. The book begins with the basic principles for modeling concurrent and communicating systems, introduces different classes of properties (including safety and liveness), presents the notion of fairness, and provides automata-based algorithms for these properties. It introduces the temporal logics LTL and CTL, compares them, and covers algorithms for verifying these logics, discussing real-time systems as well as systems subject to random phenomena. Separate chapters treat such efficiency-improving techniques as abstraction and symbolic manipulation. The book includes an extensive set of examples (most of which run through several chapters) and a complete set of basic results accompanied by detailed proofs. Each chapter concludes with a summary, bibliographic notes, and an extensive list of exercises of both practical and theoretical nature.}}
@ARTICLE{Clarke_2008,title={DESIGN AND SYNTHESIS OF SYNCHRONIZATION SKELETONS USING BRANCHING TIME TEMPORAL LOGIC},year={2008},author={Edmund M. Clarke and Edmund M. Clarke and E. Allen Emerson and E. Allen Emerson},doi={10.1007/978-3-540-69850-0_12},pmid={null},pmcid={null},mag_id={1501731334},journal={null},abstract={We Propose a method of constructing concurrent programs in which the synchronization skeletonof the program is automatically synthesized from a high-level (branching time) Temporal Logic specification. The synchronization skeleton is an abstraction of the actual program where detail irrelevant to synchronization is suppressed. For example, in the synchronization skeleton for a solution to the critical section problem each process's critical section may be viewed as a single node since the internal structure of the critical section is unimportant. Most solutions to synchronization problems in the literature are in fact given as synchronization skeletons. Because synchronization skeletons are in general finite state, the propositional version of Temporal Logic can be used to specify their properties.}}
@ARTICLE{Bertot_2004,title={Interactive Theorem Proving and Program Development: Coq'Art: The Calculus of Inductive Constructions},year={2004},author={Yves Bertot and Yves Bertot and Pierre Castran and Pierre Castran},doi={null},pmid={null},pmcid={null},mag_id={1508641834},journal={null},abstract={A practical introduction to the development of proofs and certified programs using Coq. An invaluable tool for researchers, students, and engineers interested in formal methods and the development of zero-fault software.}}
@ARTICLE{McMillan_1992,title={Symbolic model checking: an approach to the state explosion problem},year={1992},author={Kenneth L. McMillan and Kenneth L. McMillan},doi={null},pmid={null},pmcid={null},mag_id={1517173520},journal={null},abstract={Finite state models of concurrent systems grow exponentially as the number of components of the system increases. This is known widely as the state explosion problem in automatic verification, and has limited finite state verification methods to small systems. To avoid this problem, a method called symbolic model checking is proposed and studied. This method avoids building a state graph by using Boolean formulas to represent sets and relations. A variety of properties characterized by least and greatest fixed points can be verified purely by manipulations of these formulas using Ordered Binary Decision Diagrams.
Theoretically, a structural class of sequential circuits is demonstrated whose transition relations can be represented by polynomial space OBDDs, though the number of states is exponential. This result is born out by experimental results on example circuits and systems. The most complex of these is the cache consistency protocol of a commercial distributed multiprocessor. The symbolic model checking technique revealed subtle errors in this protocol, resulting from complex execution sequences that would occur with very low probability in random simulation runs.
In order to model the cache protocol, a language was developed for describing sequential circuits and protocols at various levels of abstraction. This language has a synchronous dataflow semantics, but allows nondeterminism and supports interleaving processes with shared variables. A system called SMV can automatically verify programs in this language with respect to temporal logic formulas, using the symbolic model checking technique.
A technique for proving properties of inductively generated classes of finite state systems is also developed. The proof is checked automatically, but requires a user supplied process called a process invariant to act as an inductive hypothesis. An invariant is developed for the distributed cache protocol, allowing properties of systems with an arbitrary number of processors to be proved.
Finally, an alternative method is developed for avoiding the state explosion in the case of asynchronous control circuits. This technique is based on the unfolding of Petri nets, and is used to check for hazards in a distributed mutual exclusion circuit.}}
@ARTICLE{Pientka_2007,title={Proof pearl: the power of higher-order encodings in the logical framework LF},year={2007},author={Brigitte Pientka and Brigitte Pientka},doi={10.1007/978-3-540-74591-4_19},pmid={null},pmcid={null},mag_id={1532839410},journal={null},abstract={In this proof pearl, we demonstrate the power of higher-order encodings in the logical framework Twelf[PS99] by investigating proofs about an algorithmic specification of bounded subtype polymorphism, a problem from the POPLmark challenge [ABF+05]. Our encoding and representation of the problem plays to the strengths of the logical framework LF. Higher-order abstract syntax is used to deal with issues of bound variables. More importantly, we exploit the full advantage of parametric and higher-order judgments. As a key benefit we get a tedious narrowing lemma, which must normally be proven separately, for free. Consequently, we obtain an extremely compact and elegant encoding of the admissibility of general transitivity and other meta-theoretic properties.}}
@ARTICLE{Bertot_2004,title={Interactive Theorem Proving and Program Development},year={2004},author={Yves Bertot and Yves Bertot and Pierre Castéran and Pierre Castéran},doi={10.1007/978-3-662-07964-5},pmid={null},pmcid={null},mag_id={1553511155},journal={null},abstract={Coq is an interactive proof assistant for the development of mathematical theories and formally certified software. It is based on a theory called the calculus of inductive constructions, a variant of}}
@ARTICLE{Parker_2003,title={Implementation of symbolic model checking for probabilistic systems},year={2003},author={David Parker and David Parker},doi={null},pmid={null},pmcid={null},mag_id={1553940723},journal={null},abstract={In this thesis, we present efficient implementation techniques for probabilistic model checking, a method which can be used to analyse probabilistic systems such as randomised distributed algorithms, fault-tolerant processes and communication networks. A probabilistic model checker inputs a probabilistic model and a specification, such as "the message will be delivered with probability 1", "the probability of shutdown occurring is at most 0.02" or "the probability of a leader being elected within 5 rounds is at least 0.98", and can automatically verify if the specification is true in the model. Motivated by the success of symbolic approaches to non-probabilistic model checking, which are based on a data structure called binary decision diagrams (BDDs), we present an extension to the probabilistic case, using multi-terminal binary decision diagrams (MTBDDs). We demonstrate that MTBDDs can be used to perform probabilistic analysis of large, structured models with more than 7.5 billion states, way out of the reach of conventional, explicit techniques, based on sparse matrices. We also propose a novel, hybrid approach, combining features of both symbolic and explicit implementations and show, using results from a wide range of case studies, that this technique can almost match the speed of sparse matrix based implementations, but uses significantly less memory. This increases, by approximately an order of magnitude, the size of model which can be handled on a typical workstation.}}
@ARTICLE{Café_2013,title={Multi-paradigm semantics for simulating SysML models using SystemC-AMS},year={2013},author={Daniel Chaves Café and Daniel Chaves Café and Filipe Vinci dos Santos and Filipe Vinci dos Santos and Filipe Vinci dos Santos and Cécile Hardebolle and Cécile Hardebolle and Christophe Jacquet and Christophe Jacquet and Frédéric Boulanger and Frédéric Boulanger},doi={null},pmid={null},pmcid={null},mag_id={1557243541},journal={null},abstract={SysML is an industrial standard for the modeling of systems, providing a graphical way to model structure and behavior. Despite its flexibility, SysML lacks semantics to give language elements a precise meaning. Current implementations of the standard allow multiple interpretations of syntactical elements and can cause misunderstandings when porting a model among tools. Our work focuses on the definition of concrete semantics for SysML to enable correct interpretation of heterogeneous models. We also add semantic adaptation elements to guarantee that interactions among different formalisms are unambiguous. We demonstrate our approach by generating SystemC-AMS code automatically from SysML diagrams for a case study with two distinct formalisms. This kind of translation allows the validation of system behavior through simulation.}}
@ARTICLE{Gallotti_2008,title={Quality Prediction of Service Compositions through Probabilistic Model Checking},year={2008},author={Stefano Gallotti and Stefano Gallotti and Carlo Ghezzi and Carlo Ghezzi and Raffaela Mirandola and Raffaela Mirandola and Giordano Tamburrelli and Giordano Tamburrelli},doi={10.1007/978-3-540-87879-7_8},pmid={null},pmcid={null},mag_id={1557855756},journal={null},abstract={The problem of composing services to deliver integrated business solutions has been widely studied in the last years. Besides addressing functional requirements, services compositions should also provide agreed service levels. Our goal is to support model-based analysis of service compositions, with a focus on the assessment of non-functional quality attributes, namely performance and reliability. We propose a model-driven approach, which automatically transforms a design model of service composition into an analysis model, which then feeds a probabilistic model checker for quality prediction. To bring this approach to fruition, we developed a prototype tool called  ATOP , and we demonstrate its use on a simple case study.}}
@ARTICLE{Chen_2011,title={On the Generative Power of Omega-Grammars and Omega-Automata.},year={2011},author={Zhe Chen and Zhe Chen},doi={10.3233/fi-2011-557},pmid={null},pmcid={null},mag_id={1573460045},journal={Fundamenta Informaticae},abstract={An ω-grammar is a formal grammar used to generate ω-words (i.e. infinite length words), while an ω-automaton is an automaton used to recognize ω-words. This paper gives clean and uniform definitions for ω-grammars and ω-automata, provides a systematic study of the generative power of ω-grammars with respect to ω-automata, and presents a complete set of results for various types of ω-grammars and acceptance modes. We use the tuple (σ, ρ, π) to denote various acceptance modes, where σ denotes that some designated elements should appear at least once or infinitely often, ρ denotes some binary relation between two sets, and π denotes normal or leftmost derivations. Technically, we propose (σ, ρ, π)-accepting ω-grammars, and systematically study their relative generative power with respect to (σ, ρ)-accepting ω-automata. We show how to construct some special forms of ω-grammars, such as e-production-free ω-grammars. We study the equivalence or inclusion relations between ω-grammars and ω-automata by establishing the translation techniques. In particular, we show that, for some acceptance modes, the generative power of ω-CFG is strictly weaker than ω-PDA, and the generative power of ω-CSG is equal to ω-TM (rather than linear-bounded ω-automata-like devices). Furthermore, we raise some remaining open problems for two of the acceptance modes.}}
@ARTICLE{Cimatti_1999,title={NUSMV: A New Symbolic Model Verifier},year={1999},author={Alessandro Cimatti and Alessandro Cimatti and Edmund M. Clarke and Edmund M. Clarke and Fausto Giunchiglia and Fausto Giunchiglia and Marco Roveri and Marco Roveri},doi={10.1007/3-540-48683-6_44},pmid={null},pmcid={null},mag_id={1574030932},journal={null},abstract={This paper describes NUSMV, a new symbolic model checker developed as a joint project between Carnegie Mellon University (CMU) and Istituto per la Ricerca Scientifica e Tecnolgica (IRST). NUSMV is designed to be a well structured, open, flexible and documented platform for model checking. In order to make NUSMV applicable in technology transfer projects, it was designed to be very robust, close to the standards required by industry, and to allow for expressive specification languages. NUSMV is the result of the reengineering, reimplementation and extension of SMV [6], version 2.4.4 (SMV from now on). With respect to SMV, NUSMV has been extended and upgraded along three dimensions. First, from the point of view of the system functionalities, NUSMV features a textual interaction shell and a graphical interface, extended model partitioning techniques, and allows for LTL model checking. Second, the system architecture of NUSMV has been designed to be highly modular and open. The interdependencies between different modules have been separated, and an external, state of the art BDD package [8] has been integrated in the system kernel. Third, the quality of the implementation has been strongly enhanced. This makes of NUSMV a robust, maintainable and well documented system, with a relatively easy to modify source code. NUSMV is available at http://nusmv.irst.itc.it/.}}
@ARTICLE{Clarke_2008,title={The Birth of Model Checking},year={2008},author={Edmund M. Clarke and Edmund M. Clarke},doi={10.1007/978-3-540-69850-0_1},pmid={null},pmcid={null},mag_id={1577525693},journal={null},abstract={"When the time is ripe for certain things, these things appear in different places in the manner of violets coming to light in early spring." (Wolfgang Bolyai to his son Johann in urging him to claim the invention of non- Euclidean geometry without delay [Vit88]).}}
@ARTICLE{Lu_2011,title={Automated learning of probabilistic assumptions for compositional reasoning},year={2011},author={Feng Lu and Lu Feng and Marta Kwiatkowska and Marta Kwiatkowska and David Parker and David Parker},doi={10.1007/978-3-642-19811-3_2},pmid={null},pmcid={null},mag_id={1578170176},journal={null},abstract={Probabilistic verification techniques have been applied to the formal modelling and analysis of a wide range of systems, from communication protocols such as Bluetooth, to nanoscale computing devices, to biological cellular processes. In order to tackle the inherent challenge of scalability, compositional approaches to verification are sorely needed. An example is assume-guarantee reasoning, where each component of a system is analysed independently, using assumptions about the other components that it interacts with. We discuss recent developments in the area of automated compositional verification techniques for probabilistic systems. In particular, we describe techniques to automatically generate probabilistic assumptions that can be used as the basis for compositional reasoning. We do so using algorithmic learning techniques, which have already proved to be successful for the generation of assumptions for compositional verification of non-probabilistic systems. We also present recent improvements and extensions to this work and survey some of the promising potential directions for further research in this area.}}
@ARTICLE{Harper_2002,title={Programming in Standard ML},year={2002},author={Robert Harper and Robert Harper and Franck van Breugel and Franck van Breugel and Karl Crary and Karl Crary and Mike Erdmann and Mike Erdmann and Matthias Felleisen and Matthias Felleisen and Joel Jones and Joel Jones and John Lafferty and John Lafferty and Frank Pfenning and Frank Pfenning and Chris Stone and Christopher A. Stone and Dave Swasey and Dave Swasey and Johan Wallen and Johan Wallen and S. D. Williams and Scott Williams},doi={null},pmid={null},pmcid={null},mag_id={1578268413},journal={null},abstract={null}}
@ARTICLE{Jacobs_2014,title={A Formal Model of SysML Blocks Using CSP for Assured Systems Engineering},year={2014},author={Jaco Jacobs and Jaco Jacobs and Andrew Simpson and Andrew Simpson},doi={10.1007/978-3-319-17581-2_9},pmid={null},pmcid={null},mag_id={1586230860},journal={null},abstract={The Systems Modeling Language (SysML) is a semi-formal, visual modelling language used in the specification and design of systems. In this paper, we describe how Communicating Sequential Processes (CSP) and its associated refinement checker, Failures Divergences Refinement (FDR), gives rise to an approach that facilitates the refinement checking of the behavioural consistency of SysML diagrams. We formalise the conjoined behaviour of key behavioural constructs — state machines and activities — within the context of SysML. Furthermore, blocks, the fundamental modelling construct of the SysML language, can be combined in a compositional approach to system specification. The use of a process-algebraic formalism enables us to explore the behaviour of the resulting composition more rigorously. We demonstrate how CSP, in conjunction with SysML, can be used in a formal top-down approach to systems engineering. A small case study validates the contribution.}}
@ARTICLE{Kwiatkowska_2009,title={Stochastic Games for Verification of Probabilistic Timed Automata},year={2009},author={Marta Kwiatkowska and Marta Kwiatkowska and Gethin Norman and Gethin Norman and David Parker and David Parker},doi={10.1007/978-3-642-04368-0_17},pmid={null},pmcid={null},mag_id={1590344134},journal={null},abstract={Probabilistic timed automata (PTAs) are used for formal modelling and verification of systems with probabilistic, nondeterministic and real-time behaviour. For non-probabilistic timed automata, forwards reachability is the analysis method of choice, since it can be implemented extremely efficiently. However, for PTAs, such techniques are only able to compute upper bounds on maximum reachability probabilities. In this paper, we propose a new approach to the analysis of PTAs using abstraction and stochastic games. We show how efficient forwards reachability techniques can be extended to yield both lower and upper bounds on maximum (and minimum) reachability probabilities. We also present abstraction-refinement techniques that are guaranteed to improve the precision of these probability bounds, providing a fully automatic method for computing the exact values. We have implemented these techniques and applied them to a set of large case studies. We show that, in comparison to alternative approaches to verifying PTAs, such as backwards reachability and digital clocks, our techniques exhibit superior performance and scalability.}}
@ARTICLE{Knapp_2002,title={Model Checking - Timed UML State Machines and Collaborations},year={2002},author={Alexander Knapp and Alexander Knapp and Stephan Merz and Stephan Merz and Christopher Rauh and Christopher Rauh},doi={10.1007/3-540-45739-9_23},pmid={null},pmcid={null},mag_id={1597414920},journal={Lecture Notes in Computer Science},abstract={We describe a prototype tool, HUGO/RT, that is designed to automatically verify whether the timed state machines in a UML model interact according to scenarios specified by time-annotated UML collaborations. Timed state machines are compiled into timed automata that exchange signals and operations via a network automaton. A collaboration with time constraints is translated into an observer timed automaton. The model checker UPPAAL is called upon to verify the timed automata representing the model against the observer timed automaton.}}
@ARTICLE{Chen_2010,title={Nevertrace claims for model checking},year={2010},author={Zhe Chen and Zhe Chen and Gilles Motet and Gilles Motet},doi={10.1007/978-3-642-16164-3_12},pmid={null},pmcid={null},mag_id={1607146086},journal={null},abstract={We propose the nevertrace claim, which is a new construct for specifying the correctness properties that either finite or infinite execution traces (i.e., sequences of transitions) that should never occur. In semantics, it is neither similar to never claim and trace assertion, nor a simple combination of them. Furthermore, the theoretical foundation for checking nevertrace claims, namely the Asynchronous-Composition Buchi Automaton Control System (AC-BAC System), is proposed. The major contributions of the nevertrace claim include: a powerful construct for formalizing properties related to transitions and their labels, and a way for reducing the state space at the design stage.}}
@ARTICLE{Lu_2011,title={Learning-based compositional verification for synchronous probabilistic systems},year={2011},author={Feng Lu and Lu Feng and Tingting Han and Tingting Han and Marta Kwiatkowska and Marta Kwiatkowska and David Parker and David Parker},doi={10.1007/978-3-642-24372-1_40},pmid={null},pmcid={null},mag_id={1665588751},journal={null},abstract={We present novel techniques for automated compositional verification of synchronous probabilistic systems. First, we give an assume-guarantee framework for verifying probabilistic safety properties of systems modelled as discrete-time Markov chains. Assumptions about system components are represented as probabilistic finite automata (PFAs) and the relationship between components and assumptions is captured by weak language inclusion. In order to implement this framework, we develop a semi-algorithm to check language inclusion for PFAs and a new active learning method for PFAs. The latter is then used to automatically generate assumptions for compositional verification.}}
@ARTICLE{Ouchani_2012,title={Efficient probabilistic abstraction for SysML activity diagrams},year={2012},author={Samir Ouchani and Samir Ouchani and Otmane Aït Mohamed and Otmane Ait Mohamed and Otmane Ait Mohamed and Otmane Ait Mohamed and Mourad Debbabi and Mourad Debbabi},doi={10.1007/978-3-642-33826-7_18},pmid={null},pmcid={null},mag_id={1684877896},journal={null},abstract={SysML activity diagrams are OMG/INCOSE standard models for specifying and analyzing systems' behaviors. In this paper, we propose an abstraction approach for this type of diagrams that helps to mitigate the state-explosion problem in probabilistic model checking. To this end, we present two algorithms to reduce the size of a given SysML activity diagram. The first eliminates the irrelevant behaviors regarding the property under check, while the second merges control nodes into equivalent ones. The resulting abstracted model can answer safely the Probabilistic Computation Tree Logic (PCTL) property. Moreover, we present a novel calculus for activity diagrams (NuAC) that captures their underlying semantics. In addition, we prove the soundness of our approach by defining a probabilistic weak simulation relation between the semantics of the abstract and the concrete models. This relation is shown to preserve the satisfaction of the PCTL properties. Finally, we demonstrate the effectiveness of our approach on an online shopping system case study.}}
@ARTICLE{Qureshi_2011,title={From EAST-ADL to AUTOSAR software architecture: a mapping scheme},year={2011},author={Tahir Naseer Qureshi and Tahir Naseer Qureshi and DeJiu Chen and DeJiu Chen and Henrik Lönn and Henrik Lönn and Martin Törngren and Martin Törngren},doi={10.1007/978-3-642-23798-0_35},pmid={null},pmcid={null},mag_id={1700595761},journal={null},abstract={This paper addresses the gap between models describing system requirements, functions and architecture at a higher level of abstraction (such as SysML models), with respect to software/hardware architecture description (such as the AADL models) as the means to improve the development process or embedded systems. The EAST-ADL and AUTOSAR are the two focused architecture description formalisms in the presented work. While EAST-ADL is an architecture description language providing an extension and profiling of SysML dedicated to automotive embedded systems, AUTOSAR provides means to describe software architecture architectures. The contribution of the paper is a relationship investigation between different concepts of the two languages. Three case studies, of a position control, fuel control and a brake-by-wire system, have been used to support and validate the work. The resulting mapping scheme provides a basis for automated architecture refinements and synthesis.}}
@ARTICLE{Tabuchi_2005,title={Model-Driven performance analysis of UML design models based on stochastic process algebra},year={2005},author={Naoshi Tabuchi and Naoshi Tabuchi and Naoto Sato and Naoto Sato and Naoto Sato and Hiroaki Nakamura and Hiroaki Nakamura},doi={10.1007/11581741_5},pmid={null},pmcid={null},mag_id={1709885960},journal={null},abstract={The popular model-driven development (MDD) methodology strongly promotes a model-based approach to modular system development, which often implies as an integral part automatic transformation of UML design components into executable forms. When using MDD for verifying performance-related system specifications, UML designs annotated with these specifications in some profile language need to be transformed to stochastic (Markovian) models or timed simulation models. However, most of the previous efforts have focused on transformations of (variants of) UML state machine models and/or transformations to stochastic Petri net models, which lead to two problems: Relying (solely) on state machine models often restricts design flexibility (designers instead prefer choosing diagrams on a case-by-case basis), and graph-oriented Petri net models complicate the modular transformations of UML models.

To resolve these problems, we propose stochastic performance analysis of a UML design defined in different sorts of diagrams, including not only state machines but also activity diagrams with temporal annotation in UML-SPT, which are transformed into stochastic process algebraic forms. To our knowledge, this is the first attempt to define stochastic process algebraic semantics for the UML AD with UML-SPT annotations. Unlike the related efforts, ours will facilitate verification in early development stages, in which consultants and architects can benefit from modeling in a natural manner and modular component-based development, thanks to the inherent compositionality of process algebra. Further, to guarantee the validity of the transformation, we have proved the equivalence of our semantics with the stochastic Petri net semantics of UML AD.

We have developed a prototype implementation of this performance analysis mechanism, and shown that realistic design examples, defined in different sorts of UML diagrams, can successfully be transformed into those that provide various performance metrics.}}
@ARTICLE{Segala_1994,title={Probabilistic Simulations for Probabilistic Processes},year={1994},author={Roberto Segala and Roberto Segala and Nancy Lynch and Nancy Lynch},doi={10.1007/978-3-540-48654-1_35},pmid={null},pmcid={null},mag_id={1793726001},journal={null},abstract={Several probabilistic simulation relations for probabilistic systems are defined and evaluated according to two criteria: compositionality and preservation of “interesting” properties. Here, the interesting properties of a system are identified with those that are expressible in an untimed version of the Timed Probabilistic concurrent Computation Tree Logic (TPCTL) of Hansson. The definitions are made, and the evaluations carried out, in terms of a general labeled transition system model for concurrent probabilistic computation. The results cover weak simulations, which abstract from internal computation, as well as strong simulations, which do not.}}
@ARTICLE{Jurdziński_2007,title={Model checking probabilistic timed automata with one or two clocks},year={2007},author={Marcin Jurdziński and Marcin Jurdziński and François Laroussinie and François Laroussinie and Jeremy Sproston and Jeremy Sproston},doi={10.1007/978-3-540-71209-1_15},pmid={null},pmcid={null},mag_id={1894019848},journal={null},abstract={Probabilistic timed automata are an extension of timed automata with discrete probability distributions.We consider model-checking algorithms for the subclasses of probabilistic timed automata which have one or two clocks. Firstly, we show that PCTL probabilistic model-checking problems (such as determining whether a set of target states can be reached with probability at least 0.99 regardless of how nondeterminism is resolved) are PTIME-complete for one clock probabilistic timed automata, and are EXPTIME-complete for probabilistic timed automata with two clocks. Secondly, we show that the model-checking problem for the probabilistic timed temporal logic PTCTL is EXPTIME-complete for one clock probabilistic timed automata. However, the corresponding model-checking problem for the subclass of PTCTL which does not permit both (1) punctual timing bounds, which require the occurrence of an event at an exact time point, and (2) comparisons with probability bounds other than 0 or 1, is PTIME-complete.}}
@ARTICLE{Gery_2002,title={Rhapsody: A Complete Life-Cycle Model-Based Development System},year={2002},author={Eran Gery and Eran Gery and David Harel and David Harel and Eldad Palachi and Eldad Palachi},doi={10.1007/3-540-47884-1_1},pmid={null},pmcid={null},mag_id={1901342657},journal={null},abstract={We discuss Rhapsody, a UML based software development tool, designed to support complete model-based iterative life-cycle. First, we identify several key inhibiting factors that prevent model-based approaches from being adopted as a mainstream practice.We then examine the requirements for allowing complete life-cycle model-based development and discuss how they are met by Rhapsody through its key enabling technologies, which include: - model-code associativity - automated implementation generation - implementation framework - model execution - model-based testingWe explain why each of these features is instrumental to an effective development of production systems, based on a key observation that the modeling language does not replace the implementation platform, but should be integrated with it in a synergistic manner. This allows the use of modeling for expressing requirements and design abstractions, along with the use of the full power of an implementation language and its supporting platform to specify implementation details. While allowing this flexibility, Rhapsody facilitates full consistency of the modeling and implementation artifacts throughout the life-cycle, and it also supports a high level of automation in the implementation and validation of the developed system.}}
@ARTICLE{Chen_2015,title={Model checking aircraft controller software: a case study},year={2015},author={Zhe Chen and Zhe Chen and Yu Gu and Yi Gu and Zhiqiu Huang and Zhiqiu Huang and Jun Zheng and Jun Zheng and Chang Liu and Chang Liu and Ziyi Liu and Ziyi Liu},doi={10.1002/spe.2242},pmid={null},pmcid={null},mag_id={1940023874},journal={Software - Practice and Experience},abstract={This paper documents an application of model checking to formally verify an interrupt-driven Slats and Flaps Control Unit software programmed in C, one component of a certain type of Chinese aircraft. Our objective was to identify errors rather than to prove correctness. We focused on the correctness of the algorithms used in the buffer operations, which are very common and important in aircraft software. In the verification, a total of four flawed code fragments was identified, including a minor efficiency issue. According to the programming team, this is regarded as a very successful result, and this project is the first successful attempt to apply model checking to the practice of verifying onboard aircraft software in China. Thanks to its completeness and reality, this case study can also serve as a complete and valuable real-world example for teaching and learning model checking. Copyright © 2013 John Wiley & Sons, Ltd.}}
@ARTICLE{Noll_2014,title={Safety, Dependability and Performance Analysis of Aerospace Systems},year={2014},author={Thomas Noll and Thomas Noll},doi={10.1007/978-3-319-17581-2_2},pmid={null},pmcid={null},mag_id={1946904169},journal={null},abstract={The size and complexity of software in spacecraft is increasing exponentially, and this trend complicates its validation within the context of the overall spacecraft system. Current validation methods are labour-intensive as they rely on manual analysis, review and inspection. In this paper we give an overview of an integrated system-software co-engineering approach focusing on a coherent set of specification and analysis techniques for evaluation of system-level correctness, safety, dependability and performability of on-board computer-based aerospace systems. It features both a tailored modelling language and toolset for supporting (semi-)automated validation activities. Our modelling language is a dialect of the Architecture Analysis and Design Language, AADL, and enables engineers to specify the system, the software, and their reliability aspects. The COMPASS toolset employs state-of-the-art model checking techniques, both qualitative and probabilistic, for the analysis of requirements related to functional correctness, safety, dependability and performance.}}
@ARTICLE{Chouali_2011,title={Formal verification of components assembly based on SysML and interface automata},year={2011},author={Samir Chouali and Samir Chouali and Ahmed Hammad and Ahmed Hammad},doi={10.1007/s11334-011-0170-3},pmid={null},pmcid={null},mag_id={1969755665},journal={Innovations in Systems and Software Engineering},abstract={We propose an approach which combines component SysML models and interface automata in order to assemble components and to verify formally their interoperability. So we propose to verify formally the assembly of components specified with the expressive and semi-formal modeling language, SysML. We specify component-based system architecture with SysML Block Definition Diagram, and the composition links between components with Internal Block Diagrams. Component's protocols are specified with sequence diagrams, they are necessary to exploit interface automata formalism. Interface automata is a common Input Output (I/O) automata-based formalism intended to specify the signature and the protocol level of the component interfaces. We propose formal specifications for SysML semi-formal models in order to exploit interface automata approach. We also improve the interface automata approach by considering system architecture, specified with SysML, in the verification of components composition.}}
@ARTICLE{Kamandi_2006,title={Transformation of UML Models into Analyzable OSAN Models},year={2006},author={Ali Kamandi and Ali Kamandi and Mohammad Abdollahi Azgomi and Mohammad Abdollahi Azgomi and Ali Movaghar and Ali Movaghar},doi={10.1016/j.entcs.2005.12.059},pmid={null},pmcid={null},mag_id={1969995445},journal={Electronic Notes in Theoretical Computer Science},abstract={The unified modelling language (UML) is a de facto standard for object-oriented modelling. However, the formal semantics for the notations included in UML are not provided, which are a key requirement for the verification and evaluation purposes. To solve this problem, Petri net formalism has been used as a complement to UML in several research projects. However, there is not a complete transformation technique for all concepts and diagrams of UML to an extension of Petri nets. We have recently introduced object stochastic activity networks (OSANs). OSANs are a high-level modelling formalism that integrates object-orientation into stochastic activity networks (SANs). In this paper, we present some transformation techniques for the most important concepts and diagrams of UML into OSANs. The resulting OSAN models can be used for both evaluation and verification purposes.}}
@ARTICLE{Pronk_2012,title={Model Checking, the technology and the tools},year={2012},author={C.N.A. Pronk and C. Pronk},doi={10.1109/icsengt.2012.6339364},pmid={null},pmcid={null},mag_id={1970004368},journal={null},abstract={This paper gives a short introduction to the technology of Model Checking together with a few examples where the technology has been used successfully. A number of so-called temporal logics will be discussed, together with the main tool implementing each of the logics.}}
@ARTICLE{Beato_2005,title={UML Automatic Verification Tool with Formal Methods},year={2005},author={M. Encarnación Beato and M. Encarnación Beato and Manuel Gértrudix Barrio and Manuel Barrio-Solórzano and Carlos E. Cuesta and Carlos E. Cuesta and Pablo de la Fuente and Pablo de la Fuente},doi={10.1016/j.entcs.2004.10.024},pmid={null},pmcid={null},mag_id={1970560823},journal={Electronic Notes in Theoretical Computer Science},abstract={The use of the UML specification language is very widespread due to some of its features. However, the ever more complex systems of today require modeling methods that allow errors to be detected in the initial phases of development. The use of formal methods make such error detection possible but the learning cost is high.This paper presents a tool which avoids this learning cost, enabling the active behavior of a system expressed in UML to be verified in a completely automatic way by means of formal method techniques. It incorporates an assistant for the verification that acts as a user guide for writing properties so that she/he needs no knowledge of either temporal logic or the form of the specification obtained.}}
@ARTICLE{Larsen_1991,title={Bisimulation through probabilistic testing},year={1991},author={Kim Guldstrand Larsen and Kim Guldstrand Larsen and Arne Skou and Arne Skou},doi={10.1016/0890-5401(91)90030-6},pmid={null},pmcid={null},mag_id={1976268573},journal={Information & Computation},abstract={null}}
@ARTICLE{Fredlund_2007,title={McErlang: a model checker for a distributed functional programming language},year={2007},author={Lars–Åke Fredlund and Lars-Åke Fredlund and H. Svensson and Hans Svensson},doi={10.1145/1291151.1291171},pmid={null},pmcid={null},mag_id={1978899117},journal={null},abstract={We present a model checker for verifying distributed programs written in the Erlang programming language. Providing a model checker for Erlang is especially rewarding since the language is by now being seen as a very capable platform for developing industrial strength distributed applications with excellent failure tolerance characteristics. In contrast to most other Erlang verification attempts, we provide support for a very substantial part of the language. The model checker has full Erlang data type support, support for general process communication, node semantics (inter-process behave subtly different from intra-process communication), fault detection and fault tolerance through process linking, and can verify programs written using the OTP Erlang component library (used by most modern Erlang programs).   As the model checking tool is itself implemented in Erlang we benefit from the advantages that a (dynamically typed) functional programming language offers: easy prototyping and experimentation with new verification algorithms, rich executable models that use complex data structures directly programmed in Erlang, the ability to treat executable models interchangeably as programs (to be executed directly by the Erlang interpreter) and data, and not least the possibility to cleanly structure and to cleanly combine various verification sub-tasks. In the paper we discuss the design of the tool and provide early indications on its performance.}}
@ARTICLE{Chen_2013,title={A Review of Automated Formal Verification of Ad Hoc Routing Protocols for Wireless Sensor Networks},year={2013},author={Zhe Chen and Zhe Chen and Daqiang Zhang and Daqiang Zhang and Daqiang Zhang and Daqiang Zhang and Dongliang Zhang and Daqiang Zhang and R. Y. Zhu and Rongbo Zhu and Yinxue Ma and Yinxue Ma and Ping Yin and Ping Yin and Feng Xie and Feng Xie},doi={10.1166/sl.2013.2653},pmid={null},pmcid={null},mag_id={1979547295},journal={Sensor Letters},abstract={This paper surveys how formal verification can be used to prove the correctness of ad hoc routing protocols, which are fundamental infrastructure of wireless sensor networks. The existing techniques fall into two classes: verification on small-scale networks and verification on unbounded networks. The former one is always fully automatic and easy to use, thanks to the limited state space generated in verification. However, it cannot prove the correctness over all cases. The latter one can provide a complete proof based on abstractions of unbounded network. However, it usually needs user intervention and expertise in verification. The two kinds of technique are illustrated by verifications against some key properties such as stability, loop-freedom and deadlock-freedom. To conclude, they can be used to find faults and prove correctness, respectively. We believe that they can together aid the development of correct ad hoc routing protocols and their reliable implementations.}}
@ARTICLE{Kwiatkowska_2005,title={Probabilistic model checking in practice: case studies with PRISM},year={2005},author={Marta Kwiatkowska and Marta Kwiatkowska and Gethin Norman and Gethin Norman and David Parker and David Parker},doi={10.1145/1059816.1059820},pmid={null},pmcid={null},mag_id={1984719832},journal={null},abstract={In this paper, we describe some practical applications of probabilistic model checking, a technique for the formal analysis of systems which exhibit stochastic behaviour. We give an overview of a selection of case studies carried out using the probabilistic model checking tool PRISM, demonstrating the wide range of application domains to which these methods are applicable. We also illustrate several benefits of using formal verification techniques to analyse probabilistic systems, including: (i) that they allow a wide range of numerical properties to be computed accurately; and (ii) that they perform a complete and exhaustive analysis enabling, for example, a study of best- and worst-case scenarios.}}
@ARTICLE{Larsen_1989,title={Bisimulation through probabilistic testing (preliminary report)},year={1989},author={Kim Guldstrand Larsen and Kim Guldstrand Larsen and Arne Skou and Arne Skou},doi={10.1145/75277.75307},pmid={null},pmcid={null},mag_id={1992008267},journal={null},abstract={We propose a language for testing concurrent processes and examine its strength in terms of the processes that are distinguished by a test. By using probabilistic transition systems as the underlying semantic model, we show how a testing algorithm with a probability arbitrary close to 1 can distinguish processes that are not bisimulation equivalent. We also show a similar result (in a slightly stronger form) for a new process relation called 2/3-bisimulation — lying strictly between that of simulation and bisimulation. Finally, the ultimately strength of the testing language is shown to identify an even stronger process relation, called probabilistic bisimulation.}}
@ARTICLE{Singhoff_2004,title={Cheddar: a flexible real time scheduling framework},year={2004},author={Frank Singhoff and Frank Singhoff and Jérôme Legrand and Jérôme Legrand and Laurent Nana and Laurent Nana and Laurent Nana and Lionel Marcé and L. Marce},doi={10.1145/1046191.1032298},pmid={null},pmcid={null},mag_id={1996763308},journal={ACM Sigada Ada Letters},abstract={This paper describes an Ada framework called Cheddar which provides tools to check if a real time application meets its temporal constraints. The framework is based on the real time scheduling theory and is mostly written for educational purposes. With Cheddar, an application is defined by a set of processors, tasks, buffers, shared resources and messages. Cheddar provides feasibility tests in the cases of monoprocessor, multiprocessor and distributed systems. It also provides a flexible simulation engine which allows the designer to describe and run simulations of specific systems. The framework is open and has been designed to be easily connected to CASE tools such as editors, design tools, simulators, ...}}
@ARTICLE{Lu_2010,title={Compositional Verification of Probabilistic Systems Using Learning},year={2010},author={Feng Lu and Lu Feng and Marta Kwiatkowska and Marta Kwiatkowska and David Parker and David Parker},doi={10.1109/qest.2010.24},pmid={null},pmcid={null},mag_id={1996917540},journal={null},abstract={We present a fully automated technique for compositional verification of probabilistic systems. Our approach builds upon a recently proposed assume-guarantee framework for probabilistic automata, in which assumptions and guarantees are probabilistic safety properties, represented using finite automata. A limitation of this work is that the assumptions need to be created manually. To overcome this, we propose a novel learning technique based on the L* algorithm, which automatically generates probabilistic assumptions using the results of queries executed by a probabilistic model checker. Learnt assumptions either establish satisfaction of the verification problem or are used to generate a probabilistic counterexample that refutes it. In the case where an assumption cannot be generated, lower and upper bounds on the probability of satisfaction are produced. We illustrate the applicability of the approach on a range of case studies.}}
@ARTICLE{kerholm_2007,title={The SAVE approach to component-based development of vehicular systems},year={2007},author={Mikael kerholm and Mikael kerholm and Jan Carlson and Jan Carlson and Johan Fredriksson and Johan Fredriksson and Hans Hansson and Hans Hansson and John Håkansson and John Håkansson and Anders Möller and Anders Möller and Paul Pettersson and Paul Pettersson and Massimo Tivoli and Massimo Tivoli},doi={10.1016/j.jss.2006.08.016},pmid={null},pmcid={null},mag_id={2000254486},journal={Journal of Systems and Software},abstract={null}}
@ARTICLE{Dubois_2010,title={A Model for Requirements Traceability in a Heterogeneous Model-Based Design Process: Application to Automotive Embedded Systems},year={2010},author={Hubert Dubois and Hubert Dubois and Marie-Agnès Peraldi-Frati and Marie-Agnès Peraldi-Frati and Fadoi Lakhal and Fadoi Lakhal},doi={10.1109/iceccs.2010.2},pmid={null},pmcid={null},mag_id={2002460562},journal={null},abstract={Requirements traceability modeling is a key issue in real-time embedded design process. In such systems, requirements are of different nature (software-related, system-related, functional or non functional) and must be traced through a multilevel design flow which integrates multiple tools and heterogeneous models. Validation and Verification (V&V) activities must be performed on models and on the final product to check whether they match the initial requirements. Results of design and V&V activities must be able to impact traceability information. We thus propose DARWIN4REQ, a metamodel for requirement traceability, based on three independent flows (requirement model, solution model and V&V model). The new metamodel establishes a link between these flows and affords full traceability of requirements, including those set for heterogeneous models. This paper presents the DARWIN4REQ metamodel and its use in the context of heterogeneous models for requirements modeling, design and V&V. An automotive application illustrates the proposed approach based on UML-profiles such that SYSML, EAST-ADL2 and MARTE for design and on SIMULINK, SyNDEx and TIMESQUARE for V&V activities.}}
@ARTICLE{Ouchani_2013,title={A Security Risk Assessment Framework for SysML Activity Diagrams},year={2013},author={Samir Ouchani and Samir Ouchani and Otmane Aït Mohamed and Otmane Ait Mohamed and Otmane Ait Mohamed and Otmane Ait Mohamed and Mourad Debbabi and Mourad Debbabi},doi={10.1109/sere.2013.11},pmid={null},pmcid={null},mag_id={2007232223},journal={null},abstract={In this paper, we address the issue of security risk assessment of systems that are designed by using SysML activity diagrams. For this purpose, we develop a practical framework to enable security requirements specification and security level evaluation. First, we rely on the standard catalogue of attacks to build a library of attacks patterns. Then, we model the extracted patterns as SysML activity diagrams and we develop a specification algorithm in order to automatically generate security requirements relevant to a system under test. In order to evaluate them, we propose a methodology to map the diagrams interaction into a probabilistic model checker. Finally, we demonstrate the effectiveness of our framework on the secure real time streaming protocol.}}
@ARTICLE{Blech_2012,title={Towards a formal foundation of behavioral types for UML state-machines},year={2012},author={Jan Olaf Blech and Jan Olaf Blech and Bernhard Schätz and Bernhard Schätz},doi={10.1145/2237796.2237814},pmid={null},pmcid={null},mag_id={2019228318},journal={null},abstract={Behavioral types for model-based development comprise abstract behavioral aspects of the models they are associated with. Behavioral types allow checking that a model fulfills these behavioral aspects. Furthermore, as types can be related with each other, they support more complex checks and guarantees like compatibility in composition and refinement of models in a model based development process.   We propose a behavioral type system and explain its properties, specically targeting a subset of UML state-machines. We present an early implementation that generates behavioral type definitions out of an Eclipse-based modeling environment. These type definitions are generated for the higher-order proof assistant Coq as files. We present checking and comparison techniques based on these files for behavioral aspects that can be derived from the model definition.}}
@ARTICLE{Ebeid_2012,title={Generation of SystemC/TLM code from UML/MARTE sequence diagrams for verification},year={2012},author={Emad Ebeid and Emad Ebeid and Davide Quaglia and Davide Quaglia and Davide Quaglia and Davide Quaglia and Franco Fummi and Franco Fummi},doi={10.1109/ddecs.2012.6219051},pmid={null},pmcid={null},mag_id={2019387813},journal={null},abstract={Verification of real time embedded systems at high level of abstraction is a challenging task that requires the simulation of the system and the checking of its timing and functional properties as well as constraints. The paper presents a methodology which starts from UML sequence diagrams with MARTE timing constraints and generates a SystemC/TLM model with checkers. The execution of the model allows to verify the specified sequence of exchanged information between components while checkers allow to verify that properties and timing constraints are met. The application of the methodology to the design of a wireless sensor node shows the validity of the approach and its simulation overhead.}}
@ARTICLE{Rajlich_2014,title={Software evolution and maintenance},year={2014},author={Václav Rajlich and Vaclav Rajlich},doi={10.1145/2593882.2593893},pmid={null},pmcid={null},mag_id={2019608710},journal={null},abstract={Successful software requires constant change that is triggered by evolving requirements, technologies, and stakeholder knowledge. This constant change constitutes software evolution. Software evolution has gained steadily in importance and recently moved into the center of attention of software developers. There is the new prominence of evolutionary software development that includes agile, iterative, open source, inner source, and other processes. As a consequence, the bulk of software development now happens in the stage of software evolution and this changed the face of software engineering. This paper discusses evolutionary software development and also discusses the software change, which is the fundamental software evolution task. It further discusses research methodologies, teaching software evolution in undergraduate curriculum, and difference between software evolution and software maintenance. For all these themes, this travelogue paper presents the current state of the art and the perspective of the future advance.}}
@ARTICLE{Ben-Menachem_2010,title={Reactive Systems: Modelling, Specification and Verification; is written by L. Aceto, et al; and published by Cambridge University Press; distributed by Cambridge University Press; © 2007, (hardback), ISBN 978-0-521-87546-2, pp. 300},year={2010},author={Mordechai Ben-Menachem and Mordechai Ben-Menachem},doi={10.1145/1811226.1811243},pmid={null},pmcid={null},mag_id={2019704995},journal={ACM Sigsoft Software Engineering Notes},abstract={No abstract available.}}
@ARTICLE{Yang_2010,title={Mapping UML Activity Diagrams to Analyzable Petri Net Models},year={2010},author={Nanying Yang and Nianhua Yang and Huiqun Yu and Huiqun Yu and Haitao Sun and Hua Sun and Zhiqin Qian and Zhilin Qian},doi={10.1109/qsic.2010.26},pmid={null},pmcid={null},mag_id={2021900813},journal={null},abstract={To enhance formal analysis, activity diagrams annotated with MARTE stereotypes are mapped into timed colored Petri nets with inhibitor arcs (TCPNIA). The mapping rules for the elements of activity diagrams and MARTE stereotypes are proposed respectively. The rules to map pin nodes and object flows to Petri nets are presented. These nodes can improve activity diagrams’ modeling abilities for complicated systems. The reaching of any final nodes will stop all the flows in an activity. A method to map final nodes into Petri nets preserving this semantics is also presented with the help of inhibitor arcs. The data related issues are processed through colored properties in the TCPNIA model, guard functions and operational functions.}}
@ARTICLE{Zhang_2009,title={MDE-Based Mode Transformation: From MARTE Model to FIACRE Model: MDE-Based Mode Transformation: From MARTE Model to FIACRE Model},year={2009},author={Tian Zhang and Tian Zhang and Frédéric Jouault and Jouault Frédéric and Attiogbé Christian and Attiogbé Christian and Jean Bézivín and Bézivin Jean and Xuandong Li and Xuan-Dong Li},doi={10.3724/sp.j.1001.2009.00214},pmid={null},pmcid={null},mag_id={2027177394},journal={Journal of Software},abstract={PDF HTML阅读 XML下载 导出引用 引用提醒 基于MDE的异构模型转换:从MARTE模型到FIACRE模型 DOI: 作者: 作者单位: 作者简介: 通讯作者: 中图分类号: 基金项目: Supported by the National Natural Science Foundation of China under Grant No.60425204 (国家自然科学基金); the National Basic Research Program of China under Grant No.2002CB312001 (国家重点基础研究发展计划(973)); the National High-Tech Research and Development Plan of China under Grant No.2007AA010302 (国家高技术研究发展计划(863)); the Natural Science Foundation of Jiangsu Province of China under Grant No.BK2007714 (江苏省自然科学基金) MDE-Based Mode Transformation: From MARTE Model to FIACRE Model Author: Affiliation: Fund Project: 摘要 | 图/表 | 访问统计 | 参考文献 | 相似文献 | 引证文献 | 资源附件 | 文章评论 摘要:通过研究一个具有代表性的UML/MARTE(unified modeling language/modeling and analysis of real timeand embedded systems)模型向FIACRE(intermediate format for the architectures of embedded distributed components)形式模型的转换实例,探讨了异构模型之间在语义和语法层的相互转换问题.在语义层,通过模型转换技术构造语义映射规则,实现元语言之间的转换;在语法层,通过构造元模型的具体语法,反映元语言的语法规则,从而产生目标模型的程序实体.基于此实例研究,探讨了通用转换途径的相关框架和关键技术,并讨论了转换工作的优缺点和实 用性. Abstract:This paper presents a representative case study of bridging UML/MARTE (unified modeling language/ modeling and analysis of real time and embedded systems) to FIACRE (intermediate format for the architectures of embedded distributed components), and discusses in detail two sub-problems of semantic mapping and syntactic transformation respectively. At the semantic level, the semantic mapping rules are developed using model transformation technology so as to implement the transformation between metamodels. At the syntactic level, the concrete syntax rules are built on the metamodels so that textual programs could be generated. Based on the case study, the general framework and corresponding key techniques are discussed. In addition, both the advantages and deficiencies of the work are concluded. 参考文献 相似文献 引证文献}}
@ARTICLE{Mallet_2008,title={MARTE: a profile for RT/E systems modeling, analysis-- and simulation ?},year={2008},author={Frédéric Mallet and Frédéric Mallet and Robert de Simone and Robert de Simone and Robert de Simone},doi={10.4108/icst.simutools2008.3097},pmid={null},pmcid={null},mag_id={2027735483},journal={null},abstract={As its name promises, the Unified Modeling Language (UML) provides a collection of diagrammatic modeling styles. To the early class/objects and use-case diagrams were almost immediately added state-, activity-, collaboration-, and component diagrams. All these modeling views, required for structural and behavioral representations of systems, were then progressed to further detailed expressivity. Provision for domain-specific specializations was made under the form of profiles.

Somehow this goal of being rather universal and extendible discarded the possibility of UML to adopt too strict and precise a semantics; as users were generally to define and refine it in their stereotyped profiles anyway. As a result, even the little execution semantics there is in the standard is often not considered in such specializations.

We tackled the general issue of defining a broadly expressive Time Model as a sub-profile of the upcoming OMG Profile for Modeling and Analysis of Real-Time Embedded systems (MARTE), currently undergoing finalization at OMG. The goal is to provide a generic timed interpretation, on which timed models of computation and timed simulation semantics could be built inside the UML definition scope, instead of as part of the many external proprietary profiles. The MARTE time library can be used as the basis for the definition of a UML real-time simulator.}}
@ARTICLE{Ouchani_2014,title={A property-based abstraction framework for SysML activity diagrams},year={2014},author={Samir Ouchani and Samir Ouchani and Otmane Aït Mohamed and Otmane Ait Mohamed and Otmane Ait Mohamed and Otmane Ait Mohamed and Mourad Debbabi and Mourad Debbabi},doi={10.1016/j.knosys.2013.11.016},pmid={null},pmcid={null},mag_id={2028605530},journal={Knowledge Based Systems},abstract={null}}
@ARTICLE{Kwiatkowska_2006,title={Performance analysis of probabilistic timed automata using digital clocks},year={2006},author={Marta Kwiatkowska and Marta Kwiatkowska and Gethin Norman and Gethin Norman and David Parker and David Parker and Jeremy Sproston and Jeremy Sproston},doi={10.1007/s10703-006-0005-2},pmid={null},pmcid={null},mag_id={2028827800},journal={null},abstract={Probabilistic timed automata, a variant of timed automata extended with discrete probability distributions, is a modelling formalism suitable for describing formally both nondeterministic and probabilistic aspects of real-time systems, and is amenable to model checking against probabilistic timed temporal logic properties. However, the previously developed verification algorithms either suffer from high complexity, give only approximate results, or are restricted to a limited class of properties. In the case of classical (non-probabilistic) timed automata it has been shown that for a large class of real-time verification problems correctness can be established using an integral model of time (digital clocks) as opposed to a dense model of time. Based on these results we address the question of under what conditions digital clocks are sufficient for the performance analysis of probabilistic timed automata and show that this reduction is possible for an important class of systems and properties including probabilistic reachability and expected reachability. We demonstrate the utility of this approach by applying the method to the performance analysis of three probabilistic real-time protocols: the dynamic configuration protocol for IPv4 link-local addresses, the IEEE 802.11 wireless local area network protocol and the IEEE 1394 FireWire root contention protocol.}}
@ARTICLE{Lima_2009,title={Formal Verification and Validation of UML 2.0 Sequence Diagrams using Source and Destination of Messages},year={2009},author={Vitor Lima and Vitor Lima and Chamseddine Talhi and Chamseddine Talhi and Djedjiga Mouheb and Djedjiga Mouheb and Mourad Debbabi and Mourad Debbabi and L. Wang and Lingyu Wang and Makan Pourzandi and Makan Pourzandi},doi={10.1016/j.entcs.2009.09.064},pmid={null},pmcid={null},mag_id={2028905856},journal={Electronic Notes in Theoretical Computer Science},abstract={A major challenge in software development process is to advance error detection to early phases of the software life cycle. For this purpose, the Verification and Validation (V&V) of UML diagrams play a very important role in detecting flaws at the design phase. It has a distinct importance for software security, where it is crucial to detect security flaws before they can be exploited. This paper presents a formal V&V technique for one of the most popular UML diagrams: sequence diagrams. The proposed approach creates a PROMELA-based model from UML interactions expressed in sequence diagrams, and uses SPIN model checker to simulate the execution and to verify properties written in Linear Temporal Logic (LTL). The whole technique is implemented as an Eclipse plugin, which hides the model-checking formalism from the user. The main contribution of this work is to provide an efficient mechanism to be able to track the execution state of an interaction, which allows designers to write relevant properties involving send/receive events and source/destination of messages using LTL. Another important contribution is the definition of the PROMELA structure that provides a precise semantics of most of the newly UML 2.0 introduced combined fragments, allowing the execution of complex interactions. Finally, we illustrate the benefits of our approach through a security-related case study in a real world scenario.}}
@ARTICLE{Ouchani_2013,title={A probabilistic verification framework of SysML activity diagrams},year={2013},author={Samir Ouchani and Samir Ouchani and Otmane Aït Mohamed and Otmane Ait Mohamed and Otmane Ait Mohamed and Otmane Ait Mohamed and Mourad Debbabi and Mourad Debbabi},doi={10.1109/somet.2013.6645657},pmid={null},pmcid={null},mag_id={2035375594},journal={null},abstract={SysML activity diagrams are OMG/INCOSE standard used for modeling and analyzing probabilistic systems. In this paper, we propose a formal verification framework that is based on PRISM probabilistic symbolic model checker to verify the correctness of these diagrams. To this end, we present an efficient algorithm that transforms a composition of SysML activity diagrams to an equivalent probabilistic automata encoded in PRISM input language. To clarify the quality of our verification framework, we formalize both SysML activity diagrams and PRISM input language. Finally, we demonstrate the effectiveness of our approach by presenting a case study.}}
@ARTICLE{Canevet_2004,title={Analysing UML 2.0 activity diagrams in the software performance engineering process},year={2004},author={C. Canevet and C. Canevet and Stephen Gilmore and Stephen Gilmore and Jane Hillston and Jane Hillston and Leïla Kloul and Leïla Kloul and Perdita Stevens and Perdita Stevens},doi={10.1145/974044.974055},pmid={null},pmcid={null},mag_id={2035700707},journal={null},abstract={In this paper we present an original method of analysing the newly-revised UML2.0 activity diagrams. Our analysis method builds on our formal interpretation of these diagrams with respect to the UML2.0 standard. The mapping into another formalism is the first stage of a refinement process which ultimately delivers derived analytical results on the model. This process highlights latent performance problems hidden in the high-level design, allowing software developers to fix these design flaws before they are concretised in implementation code. We exercise our analysis approach on a substantial example of modelling a multi-player distributed role-playing game.}}
@ARTICLE{Ouchani_2015,title={Specification, verification, and quantification of security in model-based systems},year={2015},author={Samir Ouchani and Samir Ouchani and Mourad Debbabi and Mourad Debbabi},doi={10.1007/s00607-015-0445-x},pmid={null},pmcid={null},mag_id={2038514592},journal={Computing},abstract={Modern systems are more and more complex and security has become a key component in the success of software and systems development. The main challenge encountered in industry as well as in academia is to develop secure products, prove their security correctness, measure their resilience to attacks, and check if vulnerabilities exist. In this paper, we review the state-of-the-art related to security specification, verification, and quantification for software and systems that are modeled by using UML or SysML language. The reviewed work fall into the field of secure software and systems engineering that aims at fulfilling the security as an afterthought in the development of secure systems.}}
@ARTICLE{Jouault_2006,title={TCS: a DSL for the specification of textual concrete syntaxes in model engineering},year={2006},author={Frédéric Jouault and Frédéric Jouault and Jean Bézivín and Jean Bézivin and Ivan Kurtev and Ivan Kurtev},doi={10.1145/1173706.1173744},pmid={null},pmcid={null},mag_id={2049008406},journal={null},abstract={Domain modeling promotes the description of various facets of information systems by a coordinated set of domain-specific languages (DSL). Some of them have visual/graphical and other may have textual concrete syntaxes. Model Driven Engineering (MDE) helps defining the concepts and relations of the domain by the way of metamodel elements. For visual languages, it is necessary to establish links between these concepts and relations on one side and visual symbols on the other side. Similarly, with textual languages it is necessary to establish links between metamodel elements and syntactic structures of the textual DSL. To successfully apply MDE in a wide range of domains we need tools for fast implementation of the expected growing number of DSLs. Regarding the textual syntax of DSLs, we believe that most current proposals for bridging the world of models (MDE) and the world of grammars (Grammarware) are not completely adapted to this need. We propose a generative solution based on a DSL called TCS (Textual Concrete Syntax). Specifications expressed in TCS are used to automatically generate tools for model-to-text and text-to-model transformations. The proposed approach is illustrated by a case study in the definition of a telephony language.}}
@ARTICLE{Yang_2012,title={Modeling UML sequence diagrams using extended Petri nets},year={2012},author={Nanying Yang and Nianhua Yang and Huiqun Yu and Huiqun Yu and Haitao Sun and Hua Sun and Zhiqin Qian and Zhilin Qian},doi={10.1007/s11235-011-9424-5},pmid={null},pmcid={null},mag_id={2051181155},journal={Telecommunication Systems},abstract={Unified modeling language (UML) sequence diagrams combined with the UML profile for modeling and analysis of real-time and embedded (MARTE) systems are used to represent systems' requirements. To enhance formal analysis abilities, sequence diagrams annotated with MARTE stereotypes are mapped into timed colored Petri nets with inhibitor arcs (TCPNIA). The mapping rules for the fragments of sequence diagrams and MARTE stereotypes are proposed respectively. They are proposed both in graphical and formal forms. The soundness of mapping rules is analyzed. The data related issues are handled through colored properties in TCPNIA models, guard functions and operational functions. A mapping rule for state invariant is proposed based on data related information. Through state invariant, complicated control relations can be expressed. Formal definitions for morphing and substitution in TCPNIA models are given. They provide modular and hierarchical modeling methods for TCPINA models. To show the applicability and feasibility of our method, an application example in vehicular ad hoc networks (VANETs) domain is studied.}}
@ARTICLE{Jarraya_2012,title={Formal Specification and Probabilistic Verification of SysML Activity Diagrams},year={2012},author={Yosr Jarraya and Yosr Jarraya and Mourad Debbabi and Mourad Debbabi},doi={10.1109/tase.2012.34},pmid={null},pmcid={null},mag_id={2053488873},journal={null},abstract={Model-driven engineering refers to a range of engineering approaches that uses models throughout systems and software development life cycle. Towards sustaining the success in practice of model-driven engineering, we present a probabilistic verification framework supporting the analysis of SysML activity diagrams against a set of quantitative and qualitative requirements. To this end, we propose an algorithm that maps SysML activity diagrams into probabilistic models, specifically Markov decision processes, expressed in the probabilistic symbolic model-checker (PRISM) language. The generated model can be verified against a set of properties expressed in the probabilistic computation tree logic. In order to automate our approach, we developed a prototype tool that interfaces both a modeling environment and the model-checker PRISM. In order to illustrate the usability and benefit of our approach, we investigate its scalability and present a case study.}}
@ARTICLE{Störrle_2004,title={Semantics of Control-Flow in UML 2.0 Activities},year={2004},author={Harald Störrle and Harald Störrle},doi={10.1109/vlhcc.2004.46},pmid={null},pmcid={null},mag_id={2070123002},journal={null},abstract={The recent major revision of the UML has introduced significant changes and additions. In particular, the metamodel portion underlying Activity Diagrams has been completely reengineered, with Activity being the central concept, the successor of ActivityGraph in UML 1.5. A denotational and compositional semantics for Activities is defined as a mapping from Activities into procedural Petri nets. The semantics excludes data type annotations and all features based on them, but includes all kinds of control flow, including non well-formed concurrency and, particularly, procedure calling}}
@ARTICLE{Zhou_2013,title={Towards a Formal Semantics for UML/MARTE State Machines Based on Hierarchical Timed Automata},year={2013},author={Yu Zhou and Yu Zhou and Luciano Baresi and Luciano Baresi and Matteo Rossi and Matteo Rossi},doi={10.1007/s11390-013-1322-8},pmid={null},pmcid={null},mag_id={2073173980},journal={Journal of Computer Science and Technology},abstract={UML is a widely-used, general purpose modeling language. But its lack of a rigorous semantics forbids the thorough analysis of designed solution, and thus precludes the discovery of significant problems at design time. To bridge the gap, the paper investigates the underlying semantics of UML state machine diagrams, along with the time-related modeling elements of MARTE, the profile for modeling and analysis of real-time embedded systems, and proposes a formal operational semantics based on extended hierarchical timed automata. The approach is exemplified on a simple example taken from the automotive domain. Verification is accomplished by translating designed models into the input language of the UPPAAL model checker.}}
@ARTICLE{Doligalski_2013,title={UML state machine implementation in FPGA devices by means of dual model and Verilog},year={2013},author={Michał Doligalski and Michał Doligalski and Marian Adamski and Marian Adamski},doi={10.1109/indin.2013.6622878},pmid={null},pmcid={null},mag_id={2074974238},journal={null},abstract={The paper presents the methodology of the logic controller development process based on the UML state machine diagram. The development process covers the logic synthesis and the implementation by means of the intermediate model based on Petri net formalism. The transformation between these two formal models is performed at the metamodels level according to the Model Driven Architecture (MDA). Semantics of the hierarchical configurable Petri net (HCfgPN) was adopted for the preemption and resumption mechanism. Operational subnet of HCfgPN model may be verified using formal methods.}}
@ARTICLE{Norman_2013,title={Model checking for probabilistic timed automata},year={2013},author={Gethin Norman and Gethin Norman and David Parker and David Parker and Jeremy Sproston and Jeremy Sproston},doi={10.1007/s10703-012-0177-x},pmid={null},pmcid={null},mag_id={2086673120},journal={null},abstract={Probabilistic timed automata (PTAs) are a formalism for modelling systems whose behaviour incorporates both probabilistic and real-time characteristics. Applications include wireless communication protocols, automotive network protocols and randomised security protocols. This paper gives an introduction to PTAs and describes techniques for analysing a wide range of quantitative properties, such as "the maximum probability of the airbag failing to deploy within 0.02 seconds", "the maximum expected time for the protocol to terminate" or "the minimum expected energy consumption required to complete all tasks". We present a temporal logic for specifying such properties and then give a survey of available model-checking techniques for formulae specified in this logic. We then describe two case studies in which PTAs are used for modelling and analysis: a probabilistic non-repudiation protocol and a task-graph scheduling problem.}}
@ARTICLE{Bernardi_2002,title={From UML sequence diagrams and statecharts to analysable petri net models},year={2002},author={Simona Bernardi and Simona Bernardi and Susanna Donatelli and Susanna Donatelli and José Merseguer and José Merseguer},doi={10.1145/584369.584376},pmid={null},pmcid={null},mag_id={2093056009},journal={null},abstract={In this paper we study the use of Sequence Diagrams and Statecharts of the Unified Modeling Language (UML) for the validation and the performance evaluation of systems. We assume that the system is specified as a set of Statecharts and that Sequence Diagrams are used to represent "executions of interest". UML lacks a formal semantics and hence it is not possible to apply, directly, mathematical techniques on UML models for system validation. To reach this goal we propose an automatic translation of Statecharts and Sequence Diagrams into Generalized Stochastic Petri Nets, and a composition of the resulting net models suitable for reaching a given analysis goal. The translation into Petri nets is based on the abstract syntax of the UML Collaborations and of the State Machines packages (from which Sequence Diagrams and Statecharts are derived) and the construction of the complete model heavily uses compositionality.}}
@ARTICLE{Kwiatkowska_2007,title={Symbolic model checking for probabilistic timed automata},year={2007},author={Marta Kwiatkowska and Marta Kwiatkowska and Gethin Norman and Gethin Norman and Jeremy Sproston and Jeremy Sproston and Fuzhi Wang and Fuzhi Wang},doi={10.1016/j.ic.2007.01.004},pmid={null},pmcid={null},mag_id={2095602520},journal={Information & Computation},abstract={Probabilistic timed automata are timed automata extended with discrete probability distributions, and can be used to model timed randomised protocols or fault-tolerant systems. We present symbolic model-checking algorithms for probabilistic timed automata to verify both qualitative temporal logic properties, corresponding to satisfaction with probability 0 or 1, and quantitative properties, corresponding to satisfaction with arbitrary probability. The algorithms operate on zones, which represent sets of valuations of the probabilistic timed automaton's clocks. Our method considers only those system behaviours which guarantee the divergence of time with probability 1. The paper presents a symbolic framework for the verification of probabilistic timed automata against the probabilistic, timed temporal logic PTCTL. We also report on a prototype implementation of the algorithms using Difference Bound Matrices, and present the results of its application to the CSMA/CD and FireWire root contention protocol case studies.}}
@ARTICLE{Lindemann_2002,title={Performance analysis of time-enhanced UML diagrams based on stochastic processes},year={2002},author={Christoph Lindemann and Christoph Lindemann and Axel Thümmler and Axel Thümmler and Alexander Klemm and Alexander Klemm and Marco Lohmann and Marco Lohmann and Oliver P. Waldhorst and Oliver P. Waldhorst},doi={10.1145/584369.584375},pmid={null},pmcid={null},mag_id={2095977474},journal={null},abstract={In this paper, we propose extensions to UML state diagrams and activity diagrams in order to allow the association of events with exponentially distributed and deterministic delays. We present an efficient algorithm for the state space generation out of these UML diagrams that allows a quantitative analysis by means of an underlying stochastic process. We identify a particular stochastic process, the generalized semi-Markov process (GSMP), as the appropriate vehicle on which quantitative analysis is performed. As innovative feature the algorithm removes vanishing states, i.e. states with no timed events active, and considers branching probabilities within activity diagrams. Furthermore, we introduce a performance evaluation framework that allows a system designer to predict performance measures at several steps in the design process. The applicability of our approach for practical performance and dependability projects is demonstrated by an UML specification of the General Packet Radio Service, a packet switched extension in GSM wireless networks.}}
@ARTICLE{Lasnier_2009,title={Ocarina: An Environment for AADL Models Analysis and Automatic Code Generation for High Integrity Applications},year={2009},author={Gilles Lasnier and Gilles Lasnier and Béchir Zalila and Bechir Zalila and Laurent Pautet and Laurent Pautet and Laurent Pautet and Jérôme Hugues and Jérôme Hugues},doi={10.1007/978-3-642-01924-1_17},pmid={null},pmcid={null},mag_id={2096203497},journal={null},abstract={Developing safety-critical distributed applications is a difficult challenge. A failure may cause important damages as loss of human life or mission's failure. Such distributed applications must be designed and built with rigor. Reducing the tedious and error-prone development steps is required; we claim that automatic code generation is a natural solution. In order to ease the process of verification and certification, the user can use modeling languages to describe application critical aspects. In this paper we introduce the use of AST as a modeling language for Distributed Real-time Embedded (DRE) systems. Then we present our tool-suite  ocarina  which allows automatic code generation from AST models. Finally, we present a comparison between  ocarina  and traditional approaches.}}
@ARTICLE{Das_2006,title={Timing Verification of UML Activity Diagram Based Code Block Level Models for Real Time Multiprocessor System-on-Chip Applications},year={2006},author={Dipankar Das and Dipankar Das and Rajeev Kumar and Rajeev Kumar and P. P. Chakrabarti and Partha Chakrabarti},doi={10.1109/apsec.2006.56},pmid={null},pmcid={null},mag_id={2096799623},journal={null},abstract={The UML activity diagram language is the de facto language for behavioral modeling capable of block level modeling of real time multiprocessor SoC applications where timing behavior is a critical aspect. Although there are several tools for timing verification of logics with branching time semantics, there are no known model checkers for timing verification of logics with linear time semantics as needed for many verification tasks. This work deals with timing verification of UML activity diagram models of applications. We propose a subset of TPTL (timed prepositional temporal logic) for specifying timing queries. We develop an automata based model checker for verifying such queries. We present a comparison of the proposed timing verification with the state of the art for random test-cases.}}
@ARTICLE{Chen_2009,title={Modeling System Safety Requirements Using Input/Output Constraint Meta-automata},year={2009},author={Zhe Chen and Gilles Motet and Gilles Motet},doi={10.1109/icons.2009.24},pmid={null},pmcid={null},mag_id={2099149960},journal={null},abstract={Most recent software related accidents have been system accidents. To validate the absence of system hazards concerning dysfunctional interactions, industrials call for approaches of modeling system safety requirements and interaction constraints among components and with environments (e.g., between humans and machines). This paper proposes a framework based on input/output constraint meta-automata, which restricts system behavior at the meta level. This approach can formally model safe interactions between a system and its environment or among its components. This framework differs from the framework of the traditional model checking. It explicitly separates the tasks of product engineers and safety engineers, and provides a top-down technique for modeling a system with safety constraints, and for automatically composing a safe system that conforms to safety requirements. The contributions of this work include formalizing system safety requirements and a way of automatically ensuring system safety.}}
@ARTICLE{Jansen_2002,title={A Probabilistic Extension of UML Statecharts},year={2002},author={David N. Jansen and David N. Jansen and Holger Hermanns and Holger Hermanns and Joost-Pieter Katoen and Joost-Pieter Katoen},doi={10.1007/3-540-45739-9_21},pmid={null},pmcid={null},mag_id={2100571517},journal={null},abstract={This paper introduces means to specify system randomness within UML statecharts, and to verify probabilistic temporal properties over such enhanced statecharts which we call probabilistic UML statecharts. To achieve this, we develop a general recipe to extend a statechart semantics with discrete probability distributions, resulting in Markov decision processes as semantic models. We apply this recipe to the requirements-level UML semantics of [8]. Properties of interest for probabilistic statecharts are expressed in PCTL, a probabilistic variant of CTL for processes that exhibit both non-determinism and probabilities. Verification is performed using the model checker PRISM. A model checking example shows the feasibility of the suggested approach.}}
@ARTICLE{Ball_2010,title={SLAM2: static driver verification with under 4% false alarms},year={2010},author={Thomas Ball and Thomas Ball and Ella Bounimova and Ella Bounimova and Rahul Kumar and Rahul Kumar and Rahul Kumar and Rahul Kumar and Rahul Kumar and Vladimir Levin and Vladimir Levin},doi={null},pmid={null},pmcid={null},mag_id={2107002931},journal={null},abstract={In theory, counterexample-guided abstraction refinement (CEGAR) uses spurious counterexamples to refine overapproximations so as to eliminate provably false alarms. In practice, CEGAR can report false alarms because: (1) the underlying problem CEGAR is trying to solve is undecidable; (2) approximations introduced for optimization purposes may cause CEGAR to be unable to eliminate a false alarm; (3) CEGAR has no termination guarantee — if it runs out of time or memory then the last counterexample generated is provably a false alarm. We report on advances in the SLAM analysis engine, which implements CEGAR for C programs using predicate abstraction, that greatly reduce the false alarm rate. SLAM is used by the Static Driver Verifier (SDV) tool. Compared to the first version of SLAM (SLAM1, shipped in SDV 1.6), the improved version (SLAM2, shipped in SDV 2.0) reduces the percentage of false alarms from 25.7% to under 4% for the WDM class of device drivers. For the KMDF class of device drivers, SLAM2 has under 0.05% false alarms. The variety and the volume of our experiments of SDV with SLAM2, significantly exceed those performed for other CEGAR-based model checkers. These results made it possible for SDV 2.0 to be applied as an automatic and required quality gate for Windows 7 device drivers.}}
@ARTICLE{Norman_2007,title={Model checking the probabilistic pi-calculus},year={2007},author={Gethin Norman and Gethin Norman and Catuscia Palamidessi and Catuscia Palamidessi and David Parker and David Parker and Peng Wu and Peng Wu},doi={10.1109/qest.2007.27},pmid={null},pmcid={null},mag_id={2108293102},journal={null},abstract={We present an implementation of model checking for the probabilistic pi-calculus-calculus, a process algebra which supports modelling of concurrency, mobility and discrete probabilistic behaviour. Formal verification techniques for this calculus have clear applications in several domains, including mobile ad-hoc network protocols and random security protocols. Despite this, no implementation of automated verification exists. Building upon the (non-probabilistic) pi-calculus model checker MMC, we first show an automated procedure for constructing the Markov decision process representing a probabilistic pi-calculus process. This can then be verified using existing probabilistic model checkers such as PRISM. Secondly, we demonstrate how for a large class of systems a more efficient, compositional approach can be applied, which uses our extension of MMC on each parallel component of the system and then translates the results into a high-level model description for the PRISM tool. The feasibility of our techniques is demonstrated through three case studies from the pi-calculus literature.}}
@ARTICLE{Chen_2009,title={A Language-Theoretic View on Guidelines and Consistency Rules of UML},year={2009},author={Zhe Chen and Zhe Chen and Gilles Motet and Gilles Motet and Gilles Motet},doi={10.1007/978-3-642-02674-4_6},pmid={null},pmcid={null},mag_id={2112775311},journal={null},abstract={Guidelines and consistency rules of UML are used to control the degrees of freedom provided by the language to prevent faults. Guidelines are used in specific domains (e.g., avionics) to recommend the proper use of technologies. Consistency rules are used to deal with inconsistencies in models. However, guidelines and consistency rules use informal restrictions on the uses of languages, which makes checking difficult. In this paper, we consider these problems from a language-theoretic view. We propose the formalism of C-Systems, short for "formal language control systems". A C-System consists of a controlled grammar and a controlling grammar. Guidelines and consistency rules are formalized as controlling grammars that control the uses of UML, i.e. the derivations using the grammar of UML. This approach can be implemented as a parser, which can automatically verify the rules on a UML user model in XMI format. A comparison to related work shows our contribution: a generic top-down and syntax-based approach that checks language level constraints at compile-time.}}
@ARTICLE{Kawahara_2009,title={Verification of embedded system's specification using collaborative simulation of SysML and simulink models},year={2009},author={Ryo Kawahara and Ryo Kawahara and Dolev Dotan and Dolev Dotan and Takashi Sakairi and Takashi Sakairi and Kohichi Ono and Kohichi Ono and Hiroaki Nakamura and Hiroaki Nakamura and Andrei Kirshin and Andrei Kirshin and Shinichi Hirose and Shinichi Hirose and Shinichi Hirose and Hiroshi Ishikawa and Hiroshi Ishikawa and Hiroshi Ishikawa and Hiroshi Ishikawa},doi={10.1109/mbse.2009.5031716},pmid={null},pmcid={null},mag_id={2116957228},journal={null},abstract={The authors propose an extension of SysML which enables description of continuous-time behavior. The authors also develop its execution tool integrated on Eclipse-based platform by exploiting co-simulation of SysML and MATLAB / Simulink. To demonstrate the effectiveness of the tool and the extension to SysML in verifying specifications of an embedded system, we create a sample model and analyze its execution results by checking constraints under a test case.}}
@ARTICLE{Clarke_1986,title={Automatic verification of finite-state concurrent systems using temporal logic specifications},year={1986},author={Edmund M. Clarke and Edmund M. Clarke and E. Allen Emerson and E. A. Emerson and A. Prasad Sistla and A. P. Sistla},doi={10.1145/5397.5399},pmid={null},pmcid={null},mag_id={2117189826},journal={ACM Transactions on Programming Languages and Systems},abstract={We give an efficient procedure for verifying that a finite-state concurrent system meets a specification expressed in a (propositional, branching-time) temporal logic. Our algorithm has complexity linear in both the size of the specification and the size of the global state graph for the concurrent system. We also show how this approach can be adapted to handle fairness. We argue that our technique can provide a practical alternative to manual proof construction or use of a mechanical theorem prover for verifying many finite-state concurrent systems. Experimental results show that state machines with several hundred states can be checked in a matter of seconds.}}
@ARTICLE{Bundy_2006,title={Constructing Induction Rules for Deductive Synthesis Proofs},year={2006},author={Alan Bundy and Alan Bundy and Lucas Dixon and Lucas Dixon and Jeremy Gow and Jeremy Gow and Jacques Fleuriot and Jacques Fleuriot},doi={10.1016/j.entcs.2005.08.003},pmid={null},pmcid={null},mag_id={2120926795},journal={Electronic Notes in Theoretical Computer Science},abstract={We describe novel computational techniques for constructing induction rules for deductive synthesis proofs. Deductive synthesis holds out the promise of automated construction of correct computer programs from specifications of their desired behaviour. Synthesis of programs with iteration or recursion requires inductive proof, but standard techniques for the construction of appropriate induction rules are restricted to recycling the recursive structure of the specifications. What is needed is induction rule construction techniques that can introduce novel recursive structures. We show that a combination of rippling and the use of meta-variables as a least-commitment device can provide such novelty.}}
@ARTICLE{Elmansouri_2011,title={From UML Activity Diagrams to CSP Expressions: A Graph Transformation Approach using Atom 3 Tool},year={2011},author={Raida Elmansouri and Raida Elmansouri and Houda Hamrouche and Houda Hamrouche and Allaoua Chaoui and Allaoua Chaoui},doi={null},pmid={null},pmcid={null},mag_id={2121047523},journal={null},abstract={The Unified Modeling Language (UML) has become a widely accepted standard in the object oriented software development industry. However, the UML is a semi-formal language which lacks precisely defined constructs. On the other hand, CSP language is a formal specification language. So, UML and CSP have complementary features: UML can be used for modeling while CSP can be used for analysis. In this paper we propose an approach and a tool to transform UML activity diagrams to CSP. Our approach is based on graph transformation and uses ATOM 3 tool. The}}
@ARTICLE{Rafe_2009,title={Verification and Validation of Activity Diagrams Using Graph Transformation},year={2009},author={Vahid Rafe and Vahid Rafe and Reza Rafeh and Reza Rafeh and Reza Rafeh and Somayeh Azizi and Somayeh Azizi and Mohamad Reza Zand Miralvand and Mohamad Reza Zand Miralvand and Mohamad Reza Zand Miralvand and Mohamad Reza Zand Miralvand},doi={10.1109/icctd.2009.172},pmid={null},pmcid={null},mag_id={2121398316},journal={null},abstract={Graphical structures (like graphs, diagrams, visual sentences and others) are very useful to describe complex structures and systems. These structures are often augmented by formalisms which add a further dimension to the static description allowing for the modeling of the evolution of systems via any kind of transformation of such graphical structures. Graph transformation has been widely used for modeling. Graphs are well suited to describe the underlying structures of models. They provide a good method to carry out the analysis and verification activities and using the AGG toolset for designing them. A major goal of this paper is the ability to determine the correctness behavior and formal semantics of UML2.0 activity diagrams by Graph Transformation Systems.}}
@ARTICLE{Suryadevara_2013,title={Verifying MARTE/CCSL Mode Behaviors Using UPPAAL},year={2013},author={Jagadish Suryadevara and Jagadish Suryadevara and Cristina Seceleanu and Cristina Seceleanu and Frédéric Mallet and Frédéric Mallet and Paul Pettersson and Paul Pettersson},doi={10.1007/978-3-642-40561-7_1},pmid={null},pmcid={null},mag_id={2128110618},journal={null},abstract={In the development of safety-critical embedded systems, the ability to formally analyze system behavior models, based on timing and causality, helps the designer to get insight into the systems overall timing behavior. To support the design and analysis of real-time embedded systems, the UML modeling profile MARTE provides CCSL --- a time model and a clock constraint specification language. CCSL is an expressive language that supports specification of both logical and chronometric constraints for MARTE models. On the other hand, semantic frameworks such as timed automata provide verification support for real-time systems. To address the challenge of verifying CCSL-based behavior models, in this paper, we propose a technique for transforming MARTE/CCSL mode behaviors into Timed Automata for model-checking using the UPPAAL tool. This enables verification of both logical and chronometric properties of the system, which has not been possible before. We demonstrate the proposed transformation and verification approach using two relevant examples of real-time embedded systems.}}
@ARTICLE{Feiler_2010,title={Model-based validation of safety-critical embedded systems},year={2010},author={Peter H. Feiler and Peter H. Feiler},doi={10.1109/aero.2010.5446809},pmid={null},pmcid={null},mag_id={2128905514},journal={null},abstract={Safety-critical systems have become increasingly software reliant and the current development process of “build, then integrate” has become unaffordable.1,2 This paper examines two major contributors to today's exponential growth in cost: system-level faults that are not discovered until late in the development process; and multiple truths of analysis results when predicting system properties through model-based analysis and validating them against system implementations. We discuss the root causes of such system-level problems, and an architecture-centric model-based analysis approach of different operational quality aspects from an architecture model. A key technology is the SAE Architecture Analysis & Design Language (AADL) standard for embedded software-reliant system. It supports a single source approach to analysis of operational qualities such as responsiveness, safety-criticality, security, and reliability through model annotations. The paper concludes with a summary of an industrial case study that demonstrates the feasibility of this approach.}}
@ARTICLE{Chen_2009,title={System Safety Requirements as Control Structures},year={2009},author={Zhe Chen and Zhe Chen and Gilles Motet and Gilles Motet},doi={10.1109/compsac.2009.50},pmid={null},pmcid={null},mag_id={2132008977},journal={null},abstract={Along with the popularity of software-intensive systems, the interactions between system components and between humans and software applications are becoming more and more complex. This results in system accidents related to system safety issues. System accidents are different to failures related to component reliability. System safety is not well addressed, because functional requirements and safety requirements are separately handled in practice. In this paper, we consider safety requirements as control structures that restrict system behaviors at meta-model level. We propose the formalism of interface C-Systems, short for "interface control systems''. In this framework, functional requirements and safety requirements are separately formalized as interface automata and controlling automata respectively, as what we are doing in practice. The controlling automaton may guarantee safety requirements at design-time or runtime. Then the global system is a safe specification. The underlying mechanism differs from that of model checking. It explicitly separates the tasks of product engineers and safety engineers, and provides a new top-down methodology for designing and modeling a system with safety constraints, and for automatically composing a safe system that conforms to safety requirements. In practice, this methodology may be also used for safety checking, incident reporting and service restoration.}}
@ARTICLE{Alawneh_2006,title={A unified approach for verification and validation of systems and software engineering models},year={2006},author={Luay Alawneh and Luay Alawneh and Mourad Debbabi and Mourad Debbabi and Fawzi Hassaïne and F. Hassaine and Fawzi Hassaïne and Yosr Jarraya and Yosr Jarraya and Andrei Soeanu and Andrei Soeanu},doi={10.1109/ecbs.2006.17},pmid={null},pmcid={null},mag_id={2132877703},journal={null},abstract={We present in this paper a unified paradigm for the verification and validation of software and systems engineering design models expressed in UML 2.0 or SysML. This paradigm relies on an established synergy between three salient approaches, which are model-checking, program analysis, and software engineering techniques. To illustrate the accomplishment of our results, we have designed and implemented an integrated and automated computer-aided assessment tool. We provide three case studies for sequence, state machine, and class and package diagrams to demonstrate the benefits of our methodology.}}
@ARTICLE{Bock_2005,title={Systems engineering in the product lifecycle},year={2005},author={Conrad Bock and Conrad E. Bock},doi={10.1504/ijpd.2005.006672},pmid={null},pmcid={null},mag_id={2133602955},journal={International Journal of Product Development},abstract={This paper introduces basic elements of systems engineering that are useful in managing the product lifecycle, as expressed in an extension to the Unified Modeling Language. It presents models of product requirements for capturing stakeholder needs, system structure for defining the static relations of its elements, behaviour for the transformation of inputs to outputs, parametrics for constraining properties of structure and allocation for assigning behaviour to structure. The relation of behaviour to structure is identified as a central issue in the integration of systems and software engineering.}}
@ARTICLE{Kwiatkowska_2002,title={PRISM: Probabilistic Symbolic Model Checker},year={2002},author={Marta Kwiatkowska and Marta Kwiatkowska and Gethin Norman and Gethin Norman and David Parker and David Parker},doi={10.1007/3-540-46029-2_13},pmid={null},pmcid={null},mag_id={2134991157},journal={Lecture Notes in Computer Science},abstract={In this paper we describe PRISM, a tool being developed at the University of Birmingham for the analysis of probabilistic systems. PRISM supports three probabilistic models: discrete-time Markov chains, Markov decision processes and continuous-time Markov chains. Analysis is performed through model checking such systems against specifications written in the probabilistic temporal logics PCTL and CSL. The tool features three model checking engines: one symbolic, using BDDs (binary decision diagrams) and MTBDDs (multi-terminal BDDs); one based on sparse matrices; and one which combines both symbolic and sparse matrix methods. PRISM has been successfully used to analyse probabilistic termination, performance, and quality of service properties for a range of systems, including randomized distributed algorithms, manufacturing systems and workstation clusters.}}
@ARTICLE{vanGlabbeek_1995,title={Reactive, generative, and stratified models of probabilistic processes},year={1995},author={R.J. vanGlabbeek and R.J. vanGlabbeek and Rob J. VanGlabbeek and Scott A. Smolka and Scott A. Smolka and Bernhard Steffen and Bernhard Steffen},doi={10.1006/inco.1995.1123},pmid={null},pmcid={null},mag_id={2135657750},journal={Information & Computation},abstract={Abstract   We introduce three models of probabilistic processes, namely, reactive, generative, and stratified. These models are investigated within the context of PCCS, an extension of Milner′s SCCS in which each summand of a process summation expression is guarded by a probability and the sum of these probabilities is 1. For each model, we present a structural operational semantics of PCCS and a notion of bisimulation equivalence which we prove to be a congruence. We also show that the models form a hierarchy: the reactive model is derivable from the generative model by abstraction from the relative probabilities of different actions, and the generative model is derivable from the stratified model by abstraction from the purely probabilistic branching structure. Moreover, the classical nonprobabilistic model is derivable from each of these models by abstraction from all probabilities.}}
@ARTICLE{Kwiatkowska_2006,title={Quantitative Analysis With the Probabilistic Model Checker PRISM},year={2006},author={Marta Kwiatkowska and Marta Kwiatkowska and Gethin Norman and Gethin Norman and David Parker and David Parker},doi={10.1016/j.entcs.2005.10.030},pmid={null},pmcid={null},mag_id={2140597298},journal={Electronic Notes in Theoretical Computer Science},abstract={Probabilistic model checking is a formal verification technique for establishing the correctness, performance and reliability of systems which exhibit stochastic behaviour. As in conventional verification, a precise mathematical model of a real-life system is constructed first, and, given formal specifications of one or more properties of this system, an analysis of these properties is performed. The exploration of the system model is exhaustive and involves a combination of graph-theoretic algorithms and numerical methods. In this paper, we give a brief overview of the probabilistic model checker PRISM (www.cs.bham.ac.uk/~dxp/prism) implemented at the University of Birmingham. PRISM supports a range of probabilistic models and specification languages based on temporal logic, and has been recently extended with costs and rewards. We describe our experience with using PRISM to analyse a number of case studies from a wide range of application domains. We demonstrate the usefulness of probabilistic model checking techniques in detecting flaws and unusual trends, focusing mainly on the quantitative analysis of a range of best, worst and average-case system characteristics.}}
@ARTICLE{Tribastone_2008,title={Automatic Translation of UML Sequence Diagrams into PEPA Models},year={2008},author={Mirco Tribastone and Mirco Tribastone and Stephen Gilmore and Stephen Gilmore},doi={10.1109/qest.2008.18},pmid={null},pmcid={null},mag_id={2141171981},journal={null},abstract={The UML profile for modeling and analysis of real time and embedded systems (MARTE) provides a powerful, standardised framework for the specification of non-functional properties of UML models. In this paper we present an automatic procedure to derive PEPA process algebra models from sequence diagrams (SD) to carry out quantitative evaluation. PEPA has recently been enriched with a fluid-flow semantics facilitating the analysis of models of a scale and complexity which would defeat Markovian analysis.}}
@ARTICLE{Pietriga_2005,title={A toolkit for addressing HCI issues in visual language environments},year={2005},author={Emmanuel Pietriga and Emmanuel Pietriga},doi={10.1109/vlhcc.2005.11},pmid={null},pmcid={null},mag_id={2141293686},journal={null},abstract={As noted almost a decade ago, HCI (human-computer interaction) aspects of visual language environments are under-developed. This remains a fact, in spite of the central role played by user interfaces in the acceptance and usability of visual languages. We introduce ZVTM, a toolkit aimed at promoting the development of HCI aspects of visual environments by making the creation of interactive structured graphical editors easier, while favoring the rapid integration of novel interaction techniques such as zoomable user interfaces, distortion lenses, superimposed layers, and alternate scrolling and pointing methods.}}
@ARTICLE{Chen_2010,title={Towards better support for the evolution of safety requirements via the model monitoring approach},year={2010},author={Zhe Chen and Zhe Chen and Gilles Motet and Gilles Motet},doi={10.1145/1810295.1810334},pmid={null},pmcid={null},mag_id={2141499275},journal={null},abstract={The research is motivated by the challenge from the evolution of safety requirements, which leads to revision of system designs at design-time or post-implementation at a high cost. This paper proposes a complementary methodology, namely the model monitoring approach, to better support the evolution throughout the life-cycle at a lower cost.}}
@ARTICLE{Berezin_1997,title={Compositional Reasoning in Model Checking},year={1997},author={Sergey Berezin and Sergey Berezin and Sérgio Vale Aguiar Campos and Sérgio Campos and Edmund M. Clarke and Edmund M. Clarke},doi={10.1007/3-540-49213-5_4},pmid={null},pmcid={null},mag_id={2142634894},journal={null},abstract={The main problem in model checking that prevents it from being used for verification of large systems is the state explosion problem. This problem often arises from combining parallel processes together. Many techniques have been proposed to overcome this difficulty and, thus, increase the size of the systems that model checkers can handle. We describe several compositional model checking techniques used in practice and show a few examples demonstrating their performance.}}
@ARTICLE{Jacobs_2013,title={Towards a Process Algebra Framework for Supporting Behavioural Consistency and Requirements Traceability in SysML},year={2013},author={Jaco Jacobs and Jaco Jacobs and Andrew Simpson and Andrew Simpson},doi={10.1007/978-3-642-41202-8_18},pmid={null},pmcid={null},mag_id={2149338503},journal={null},abstract={The Systems Modeling Language (SysML), an extension of a subset of the Unified Modeling Language (UML), is a visual modelling language for systems engineering applications. At present, the semi-formal SysML, which is widely utilised for the design of complex heterogeneous systems, lacks integration with other more formal approaches. In this paper, we describe how Communicating Sequential Processes (CSP) and its associated refinement checker, Failures Divergence Refinement (FDR), may be used to underpin an approach that facilitates the refinement checking of behavioural consistency of SysML diagrams; we also show how the proposed approach supports requirements traceability. We illustrate our contribution by means of a small case study.}}
@ARTICLE{Störrle_2005,title={Semantics and Verification of Data Flow in UML 2.0 Activities},year={2005},author={Harald Störrle and Harald Störrle},doi={10.1016/j.entcs.2004.08.046},pmid={null},pmcid={null},mag_id={2152178541},journal={Electronic Notes in Theoretical Computer Science},abstract={One of the major changes in going from UML 1.5 to UML 2.0 is the reengineering of activity diagrams. This paper examines activity diagramies as described in the current version of the UML 2.0 standard by defining a denotational semantics. It covers basic control flow and data flow, but excludes hierarchy, expansion nodes, and exception handling (see Storrle, H., Semantics of Control-Flow in UML 2.0 Activities, in: P. Bottoni, C. Hundhausen, S. Levialdi and G. Tortora, editors, Proc. IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC) (2004), pp. 235--242, Storrle, H., Semantics of Exceptions in UML 2.0 Activities (2004), submitted to Journal of Software and Systems Modeling, May, 9th, available at www.pst.informatik.uni-muenchen.de/~stoerrle, Storrle, H., Semantics of Expansion Nodes in UML 2.0 Activities, in: I. Porres, editor, Proc. 2nd Nordic Ws. on UML, Modeling, Methods and Tools (NWUML'04), 2004] for these issues). The paper shows, where the constructs proposed in the standard are not so easily formalized, and how the formalisation may be used for formal analysis.}}
@ARTICLE{Amstel_2007,title={Four Automated Approaches to Analyze the Quality of UML Sequence Diagrams},year={2007},author={M.F. van Amstel and M.F. van Amstel and Christian F. J. Lange and Christian F. J. Lange and C.F.J. Lange and Mrv Michel Chaudron and Michel R. V. Chaudron},doi={10.1109/compsac.2007.119},pmid={null},pmcid={null},mag_id={2153575705},journal={null},abstract={UML sequence diagrams describe the interaction between objects of a system. In this paper, we present four approaches to analyze the quality of sequence diagrams. First, we propose formal model checking techniques and visualization to analyze the possible interaction traces and to identify ambiguities in a sequence diagram. Second, we identified patterns of common interactive behavior and we present an approach to identify these patterns. This approach is useful to identify implicit patterns and make them explicit. Third, we propose a series of checks to identify syntactic defects in sequence diagrams. The fourth approach consists of metrics describing properties such as coverage. The proposed approaches complement each other rather than being competing alternatives. We implemented these approaches in our SquAT tool and conducted a multi case study on three industrial and five research models to validate them. These models showed a large number of defects which were acknowledged by their designers.}}
@ARTICLE{Soares_2008,title={Model-Driven User Requirements Specification using SysML},year={2008},author={Michel S. Soares and Michel S. Soares and Jos Vrancken and Jos Vrancken},doi={10.4304/jsw.3.6.57-68},pmid={null},pmcid={null},mag_id={2160616386},journal={Journal of Software},abstract={Requirements engineering is an important phase in a system’s life cycle. When poorly performed, various problems may occur, such as failures, cost overrun and delays. The increasing complexity of systems makes requirements engineering activities both more important and more difficult. Model-driven engineering, in which models are the main artifact during system development, is an emergent approach that tries to address system complexity by the intense use of models. This article proposes a model-driven approach to requirements engineering based on SysML Requirements and Use Case Diagrams. The main advantages are that user requirements are graphically modeled, their relationships are explicitly mapped, and system decomposition is considered in the early system development activities. In addition, requirements traceability is enhanced by using the SysML Requirements tables. The approach is illustrated by a list of user requirements for a road traffic management system.}}
@ARTICLE{Ouchani_2011,title={Model-based systems security quantification},year={2011},author={Samir Ouchani and Samir Ouchani and Yosr Jarraya and Yosr Jarraya and Otmane Aït Mohamed and Otmane Ait Mohamed and Otmane Ait Mohamed and Otmane Ait Mohamed},doi={10.1109/pst.2011.5971976},pmid={null},pmcid={null},mag_id={2161404485},journal={null},abstract={In this paper, we address the issue of security verification and evaluation of systems at the design level. To this end, we elaborate a practical and formal framework that enables security risk assessment and security requirements verification on systems that are designed using SysML activity diagrams. Our approach is based on probabilistic adversarial interactions between potential attackers and the system design models. These interactions result in a global model that is used to quantify security risks by applying probabilistic model-checking. We rely on a standard catalogue of attack patterns to build a library of attacks' design patterns. To demonstrate the effectiveness of our approach, we apply it on a real-life case study related to the Secure Real Time Streaming Protocol.}}
@ARTICLE{Tribastone_2008,title={Automatic extraction of PEPA performance models from UML activity diagrams annotated with the MARTE profile},year={2008},author={Mirco Tribastone and Mirco Tribastone and Stephen Gilmore and Stephen Gilmore},doi={10.1145/1383559.1383569},pmid={null},pmcid={null},mag_id={2163669879},journal={null},abstract={Recent trends in software engineering lean towards modelcentric development methodologies, a context in which the UML plays a crucial role. To provide modellers with quantitative insights into their artifacts, the UML benefits from a framework for software performance evaluation provided by MARTE, the UML profile for model-driven development of Real Time and Embedded Systems. MARTE offers a rich semantics which is general enough to allow different quantitative analysis techniques to act as underlying performance engines. In the present paper we explore the use of the stochastic process algebra PEPA as one such engine, providing a procedure to systematically map activity diagrams onto PEPA models. Independent activity flows are translated into sequential automata which co-ordinate at the synchronisation points expressed by fork and join nodes of the activity. The PEPA performance model is interpreted against a Markovian semantics which allows the calculation of performance indices such as throughput and utilisation. We also discuss the implementation of a new software tool powered by the popular Eclipse platform which implements the fully automatic translation from MARTE-annotated UML activity diagrams to PEPA models.}}
@ARTICLE{Pedroza_2011,title={AVATAR: A SysML Environment for the Formal Verification of Safety and Security Properties},year={2011},author={Gabriel Pedroza and Gabriel Pedroza and Ludovic Apvrille and Ludovic Apvrille and Daniel Knorreck and Daniel Knorreck},doi={10.1109/notere.2011.5957992},pmid={null},pmcid={null},mag_id={2164045217},journal={null},abstract={Critical embedded systems - e.g., automotive systems - are now commonly distributed, thus exposing their communication links to attackers. The design of those systems shall therefore handle new security threats whilst maintaining a high level of safety. To address that issue, the paper introduces a SysML-based environment named AVATAR. AVATAR can capture both safety and security related elements in the same SysML model. TTool [1], an open-source UML toolkit, provides AVATAR editing capabilities, and offers a press-button approach for property proof. Indeed, after having modeled an abstract representation of the system and given a description of the safety and security properties, the designer may formally and directly verify those properties with the well established UPPAAL and ProVerif toolkits, respectively. The applicability of our approach is highlighted with a realistic embedded automotive system taken from an ongoing joint project of academia and industry called EVITA [2].}}
@ARTICLE{Banti_2011,title={An accessible verification environment for UML models of services},year={2011},author={Federico Banti and Federico Banti and Rosario Pugliese and Rosario Pugliese and Francesco Tiezzi and Francesco Tiezzi},doi={10.1016/j.jsc.2010.08.005},pmid={null},pmcid={null},mag_id={2167935884},journal={Journal of Symbolic Computation},abstract={Service-Oriented Architectures (SOAs) provide methods and technologies for modelling, programming and deploying software applications that can run over globally available network infrastructures. Current software engineering technologies for SOAs, however, remain at the descriptive level and lack rigorous foundations enabling formal analysis of service-oriented models and software. To support automated verification of service properties by relying on mathematically founded techniques, we have developed a software tool that we called Venus (Verification ENvironment for UML models of Services). Our tool takes as an input service models specified by UML 2.0 activity diagrams according to the UML4SOA profile, while its theoretical bases are the process calculus COWS and the temporal logic SocL. A key feature of Venus is that it provides access to verification functionalities also to those users not familiar with formal methods. Indeed, the tool works by first automatically translating UML4SOA models and natural language statements of service properties into, respectively, COWS terms and SocL formulae, and then by automatically model checking the formulae over the COWS terms. In this paper we present the tool, its architecture and its enabling technologies by also illustrating the verification of a classical 'travel agency' scenario.}}
@ARTICLE{Siveroni_2008,title={Property Specification and Static Verification of UML Models},year={2008},author={Igor Siveroni and Igor Siveroni and Andrea Zisman and Andrea Zisman and George Spanoudakis and George Spanoudakis},doi={10.1109/ares.2008.194},pmid={null},pmcid={null},mag_id={2168352701},journal={null},abstract={We present a static verification tool (SVT), a system that performs static verification on UML models composed of UML class and state machine diagrams. Additionally, the SVT allows the user to add extra behavior specification in the form of guards and effects by defining a small action language. UML models are checked against properties written in a special-purpose property language that allows the user to specify linear temporal logic formulas that explicitly reason about UML components. Thus, the SVT provides a strong foundation for the design of reliable systems and a step towards model-driven security.}}
@ARTICLE{Jansen_2002,title={A probabilistic extension of UML statecharts: Specification and Verification.},year={2002},author={David N. Jansen and Holger Hermanns and Holger Hermanns and Holger Hermanns and Joost-Pieter Katoen and Joost P. Katoen},doi={10.1007/3-540-45739-9},pmid={null},pmcid={null},mag_id={2170136168},journal={Lecture Notes in Computer Science},abstract={This paper is the extended technical report that corresponds to a published paper [14]. This paper introduces means to specify system randomness within UML statecharts, and to verify probabilistic temporal properties over such enhanced statecharts which we call probabilistic UML statecharts. To achieve this, we develop a general recipe to extend a statechart semantics with discrete probability distributions, resulting in Markov decision processes as semantic models. We apply this recipe to the requirements-level UML semantics of [8]. Properties of interest for probabilistic statecharts are expressed in PCTL, a probabilistic variant of CTL for processes that exhibit both non-determinism and probabilities. Verification is performed using the model checker Prism. A model checking example shows the feasibility of the suggested approach.}}
@ARTICLE{Carlson_2006,title={SaveCCM: An Analysable Component Model for Real-Time Systems},year={2006},author={Jan Carlson and Jan Carlson and John Håkansson and John Håkansson and Paul Pettersson and Paul Pettersson},doi={10.1016/j.entcs.2006.05.019},pmid={null},pmcid={null},mag_id={2171206721},journal={Electronic Notes in Theoretical Computer Science},abstract={Component based development is a promising approach for embedded systems. Typical for embedded software is the presence of resource constraints in multiple dimensions. An essential dimension is time, since many embedded systems have real-time requirements. We define a formal semantics of a component language for embedded systems, SaveCCM, a language designed with vehicle applications and safety concerns in focus. The semantics is defined by a transformation into timed automata with tasks, a formalism that explicitly models timing and real-time task scheduling. A simple SaveCCM system with a PI controller is used as a case study. Temporal properties of the PI controller have been successfully verified using the timed automata model checker Uppaal.}}
@ARTICLE{Hoare_2002,title={Communicating sequential processes},year={2002},author={C. A. R. Hoare and C. A. R. Hoare},doi={null},pmid={null},pmcid={null},mag_id={2176300081},journal={null},abstract={This paper suggests that input and output are basic primitives of programming and that parallel composition of communicating sequential processes is a fundamental program structuring method. When combined with a development of Dijkstra's guarded command, these concepts are surprisingly versatile. Their use is illustrated by sample solutions of a variety of familiar programming exercises.}}
@ARTICLE{Grobelna_2014,title={Model Checking of UML Activity Diagrams in Logic Controllers Design},year={2014},author={Iwona Grobelna and Iwona Grobelna and Michał Grobelny and Michał Grobelny and Marian Adamski and Marian Adamski},doi={10.1007/978-3-319-07013-1_22},pmid={null},pmcid={null},mag_id={2280489473},journal={null},abstract={The article presents a novel approach to model checking of UML activity diagrams (in version 2.x) for logic controller specification. A novel idea to design embedded systems by means of activity diagrams is introduced, using the previously proposed rule-based logical model suitable both for formal verification and logic synthesis. As the result implemented solution is consistent with the verified specification delivered in form of an user-friendly UML activity diagram. The idea is presented on a simple control process of two vehicles movement. Model checking technique is used to verify system model against behavioral properties expressed in temporal logic. In case of detected errors appropriate counterexamples are generated.}}
@ARTICLE{Shen_2011,title={MDA-based Method on Resource Modeling and Model Transformation of Real-time Software},year={2011},author={Guohua Shen and Shen Guo-hua},doi={null},pmid={null},pmcid={null},mag_id={2356857966},journal={Computer Science},abstract={Model Driven Architecture(MDA) is a model-centric software development framework.Its nature is meta modeling and model transformation.In this paper,a MDA-based method on resource modeling and model transformation of real-time software was proposed.This method first abstracts MARTE meta-model which contains some resource information and Priced Timed Automata(PTA) meta-model through meta-modeling.Secondly it uses ATL model transformation language to transform instance models from MARTE model to PTA model.The transformation is to construct transformation rules for MARTE meta-model and PTA meta-model.Finally,the result is formal verified through formal tool UPPAAL.The case shows the feasibility and effectiveness of the method which can improve the reliability of resource modeling of real-time software.}}
@ARTICLE{Ma_2013,title={Research on Model Transformation and Model Checking of UML Based on Timed Automata},year={2013},author={Jun Ma and MA Jian-hong},doi={null},pmid={null},pmcid={null},mag_id={2367745794},journal={Journal of Zhengzhou University},abstract={There was no existing formal verification method for UML models.A method was developed to transform UML models into timed automata models that were verified in meta-model level.The structure of UML state machines was formalized and the meta-models of UML and timed automata were constructed in this method.Model transformation language ATL was used to construct mapping rules from UML meta-model to timed automata meta-model,and to transform UML models into timed automata models.The transformation result was verified by model checking tool Uppaal.A case was studied and it was shown that this method was effective and advanced.}}
@ARTICLE{Kerzhner_2011,title={Combining SysML and Model Transformations to Support Systems Engineering Analysis},year={2011},author={Aleksandr A. Kerzhner and Aleksandr A. Kerzhner and Christiaan J. J. Paredis and Christiaan J. J. Paredis},doi={10.14279/tuj.eceasst.42.613},pmid={null},pmcid={null},mag_id={2395013004},journal={Electronic Communication of The European Association of Software Science and Technology},abstract={As modern systems become increasingly complex, there is a growing need to support the systems engineering process with a variety of formal models, such that the team of experts involved in the process can express and share knowledge
precisely, succinctly and unambiguously. However, creating such formal models can be expensive and time-consuming, making a broad exploration of different system architectures cost-prohibitive. In this paper, we investigate an approach
for reducing such costs and hence enabling broader architecture space exploration through the use of model transformations. Specifically, a method is presented for verifying design alternatives with respect to design requirements through automated generation of analyses from formal models of the systems engineering problem. Formal models are used to express the structure of design alternatives, the system
requirements, and experiments to verify the requirements as well as the relationships between the models. These formal models are all represented in a common modeling language, the Object Management Group’s Systems Modeling Language
(OMG SysMLTM). To then translate descriptive models of system alternatives into a set of corresponding analysis models, a model transformation approach is used
to combine knowledge from the experiment models with knowledge from reusable model libraries. This set of analysis models is subsequently transformed into executable
simulations, which are used to guide the search for suitable system alternatives. To facilitate performing this search using commercially available optimization tools, the analyses are represented using the General Algebraic Modeling System
(GAMS). The approach is demonstrated on the design of a hydraulic subsystem for a log splitter.}}
@ARTICLE{Katoen_2011,title={The ins and outs of the probabilistic model checker MRMC},year={2011},author={Joost-Pieter Katoen and Joost-Pieter Katoen and Ivan S. Zapreev and Ivan S. Zapreev and Ernst Moritz Hahn and Ernst Moritz Hahn and Holger Hermanns and Holger Hermanns and David N. Jansen and David N. Jansen},doi={10.1016/j.peva.2010.04.001},pmid={null},pmcid={null},mag_id={2410243683},journal={Performance Evaluation},abstract={The Markov Reward Model Checker (MRMC) is a software tool for verifying properties over probabilistic models. It supports PCTL and CSL model checking, and their reward extensions. Distinguishing features of MRMC are its support for computing time- and reward-bounded reachability probabilities, (property-driven) bisimulation minimization, and precise on-the-fly steady-state detection. Recent tool features include time-bounded reachability analysis for continuous-time Markov decision processes (CTMDPs) and CSL model checking by discrete-event simulation. This paper presents the tool's current status and its implementation details.}}
@ARTICLE{Baldan_2005,title={Specifying and Verifying UML Activity Diagrams via Graph Transformation},year={2005},author={Paolo Baldan and Andrea Corradini and Andrea Corradini and Andrea Corradini and Fabio Gadducci},doi={null},pmid={null},pmcid={null},mag_id={2519101978},journal={Lecture Notes in Computer Science},abstract={We propose a methodology for system specification and verification based on UML diagrams and interpreted in terms of graphs and graph transformations. Once a system is modeled in this framework, a temporal graph logic can be used to express some of its relevant behavioral properties. Then, under certain constraints, such properties can be checked automatically.The approach is illustrated over a simple case study, the so-called Airport Case Study, which has been widely used along the first two years of the AGILE GC project.}}
@ARTICLE{Casse_2018,title={SysML: Object Management Group (OMG) Systems Modeling Language},year={2018},author={Olivier Casse and Olivier Casse},doi={10.1016/b978-1-78548-171-0.50001-3},pmid={null},pmcid={null},mag_id={2769171049},journal={null},abstract={null}}
@ARTICLE{Alur_1999,title={Reactive Modules},year={1999},author={Rajeev Alur and Rajeev Alur and Thomas A. Henzinger and Thomas A. Henzinger},doi={10.1023/a:1008739929481},pmid={null},pmcid={null},mag_id={2912904668},journal={null},abstract={We present a formal model for concurrent systems. The model represents synchronous and asynchronous components in a uniform framework that supports compositional (assume-guarantee) and hierarchical (stepwise-refinement) design and verification. While synchronous models are based on a notion of atomic computation step, and asynchronous models remove that notion by introducing stuttering, our model is based on a flexible notion of what constitutes a computation step: by applying an abstraction operator to a system, arbitrarily many consecutive steps can be collapsed into a single step. The abstraction operator, which may turn an asynchronous system into a synchronous one, allows us to describe systems at various levels of temporal detail. For describing systems at various levels of spatial detail, we use a hiding operator that may turn a synchronous system into an asynchronous one. We illustrate the model with diverse examples from synchronous circuits, asynchronous shared-memory programs, and synchronous message-passing protocols.}}
@ARTICLE{Ouchani_2019,title={Towards a fractionation-based verification: application on SysML activity diagrams},year={2019},author={Samir Ouchani and Samir Ouchani and Samir Ouchani and Samir Ouchani},doi={10.1145/3297280.3297480},pmid={null},pmcid={null},mag_id={2942526555},journal={null},abstract={This work contributes to reduce the cost of the verification process of model-based systems, especially the ones designed as SysML activity diagrams, by relying on the concept of diagram calls defined in SysML standard. By exploiting the diagram calls concept, we propose a mechanism to transform a given diagram into its equivalent fractal (hierarchical) form. Further, we present an abstraction algorithm to reduce the size of the obtained SysML activity diagram by ignoring the irrelevant behaviors and by merging similar artifacts. To do verification, the abstracted diagram is transformed automatically into PRISM source code to check the system's requirements that are specified in the probabilistic temporal logic, PCTL. The soundness of the provided framework is presented for each step, and, its practical effectiveness is demonstrated on diagrams obtained by reversing the open source of OpenSAF middle-ware.}}
@ARTICLE{Chen_2013,title={A Review of Automated Formal Verification of Ad Hoc Routing Protocols for Wireless Sensor Networks},year={2013},author={Zhe Chen and Daqiang Zhang and Daqiang Zhang and Daqiang Zhang and Dongliang Zhang and Daqiang Zhang and Rongbo Zhu and Yinxue Ma and Ping Yin and Feng Xie},doi={10.1166/sl.2013.2653},pmid={null},pmcid={null},mag_id={3101780538},journal={Sensor Letters},abstract={This paper surveys how formal verification can be used to prove the correctness of ad hoc routing protocols, which are fundamental infrastructure of wireless sensor networks. The existing techniques fall into two classes: verification on small-scale networks and verification on unbounded networks. The former one is always fully automatic and easy to use, thanks to the limited state space generated in verification. However, it cannot prove the correctness over all cases. The latter one can provide a complete proof based on abstractions of unbounded network. However, it usually needs user intervention and expertise in verification. The two kinds of technique are illustrated by verifications against some key properties such as stability, loop-freedom and deadlock-freedom. To conclude, they can be used to find faults and prove correctness, respectively. We believe that they can together aid the development of correct ad hoc routing protocols and their reliable implementations.}}
@ARTICLE{Chen_2011,title={On the Generative Power of ω-Grammars and ω-Automata},year={2011},author={Zhe Chen and Zhe Chen and Zhe Chen},doi={10.3233/fi-2011-557},pmid={null},pmcid={null},mag_id={3102837764},journal={Fundamenta Informaticae},abstract={An ω-grammar is a formal grammar used to generate ω-words (i.e. infinite length words), while an ω-automaton is an automaton used to recognize ω-words. This paper gives clean and uniform definitions for ω-grammars and ω-automata, provides a systematic study of the generative power of ω-grammars with respect to ω-automata, and presents a complete set of results for various types of ω-grammars and acceptance modes. We use the tuple (σ, ρ, π) to denote various acceptance modes, where σ denotes that some designated elements should appear at least once or infinitely often, ρ denotes some binary relation between two sets, and π denotes normal or leftmost derivations. Technically, we propose (σ, ρ, π)-accepting ω-grammars, and systematically study their relative generative power with respect to (σ, ρ)-accepting ω-automata. We show how to construct some special forms of ω-grammars, such as e-production-free ω-grammars. We study the equivalence or inclusion relations between ω-grammars and ω-automata by establishing the translation techniques. In particular, we show that, for some acceptance modes, the generative power of ω-CFG is strictly weaker than ω-PDA, and the generative power of ω-CSG is equal to ω-TM (rather than linear-bounded ω-automata-like devices). Furthermore, we raise some remaining open problems for two of the acceptance modes.}}
@ARTICLE{Chen_2009,title={Modeling System Safety Requirements Using Input/Output Constraint Meta-Automata},year={2009},author={Zhe Chen and Zhe Chen and Gilles Motet and Gilles Motet and Gilles Motet},doi={10.1109/icons.2009.24},pmid={null},pmcid={null},mag_id={3106223272},journal={arXiv: Software Engineering},abstract={Most recent software related accidents have been system accidents. To validate the absence of system hazards concerning dysfunctional interactions, industrials call for approaches of modeling system safety requirements and interaction constraints among components and with environments (e.g., between humans and machines). This paper proposes a framework based on input/output constraint meta-automata, which restricts system behavior at the meta level. This approach can formally model safe interactions between a system and its environment or among its components. This framework differs from the framework of the traditional model checking. It explicitly separates the tasks of product engineers and safety engineers, and provides a top-down technique for modeling a system with safety constraints, and for automatically composing a safe system that conforms to safety requirements. The contributions of this work include formalizing system safety requirements and a way of automatically ensuring system safety.}}
@ARTICLE{CanevetC._2004,title={Analysing UML 2.0 activity diagrams in the software performance engineering process},year={2004},author={CanevetC. and GilmoreS. and HillstonJ. and KloulL. and StevensP.},doi={10.1145/974043.974055},pmid={null},pmcid={null},mag_id={3141602074},journal={ACM Sigsoft Software Engineering Notes},abstract={In this paper we present an original method of analysing the newly-revised UML2.0 activity diagrams. Our analysis method builds on our formal interpretation of these diagrams with respect to the UM...}}
@ARTICLE{Hoare_1985,title={Communicating Sequential Processes},year={1985},author={Tony Hoare and Tony Hoare and Tony Hoare},doi={null},pmid={null},pmcid={null},mag_id={3144368627},journal={null},abstract={null}}
@ARTICLE{Singhoff_2004,title={Cheddar},year={2004},author={F. Singhoff and Frank Singhoff and J. Legrand and Jérôme Legrand and L. Nana and Laurent Nana and L. Marcé and Lionel Marcé},doi={10.1145/1046191.1032298},pmid={null},pmcid={null},mag_id={4214706592},journal={Ada letters},abstract={This paper describes an Ada framework called Cheddar which provides tools to check if a real time application meets its temporal constraints. The framework is based on the real time scheduling theory and is mostly written for educational purposes. With Cheddar, an application is defined by a set of processors, tasks, buffers, shared resources and messages. Cheddar provides feasibility tests in the cases of monoprocessor, multiprocessor and distributed systems. It also provides a flexible simulation engine which allows the designer to describe and run simulations of specific systems. The framework is open and has been designed to be easily connected to CASE tools such as editors, design tools, simulators, ...}}
@ARTICLE{Fredlund_null,title={McErlang},year={null},author={Lars–Åke Fredlund and Lars-Åke Fredlund and H. Svensson and Hans Svensson},doi={10.1145/1291220.1291171},pmid={null},pmcid={null},mag_id={4239707615},journal={Sigplan Notices},abstract={We present a model checker for verifying distributed programs written in the Erlang programming language. Providing a model checker for Erlang is especially rewarding since the language is by now being seen as a very capable platform for developing industrial strength distributed applications with excellent failure tolerance characteristics. In contrast to most other Erlang verification attempts, we provide support for a very substantial part of the language. The model checker has full Erlang data type support, support for general process communication, node semantics (inter-process behave subtly different from intra-process communication), fault detection and fault tolerance through process linking, and can verify programs written using the OTP Erlang component library (used by most modern Erlang programs). As the model checking tool is itself implemented in Erlang we benefit from the advantages that a (dynamically typed) functional programming language offers: easy prototyping and experimentation with new verification algorithms, rich executable models that use complex data structures directly programmed in Erlang, the ability to treat executable models interchangeably as programs (to be executed directly by the Erlang interpreter) and data, and not least the possibility to cleanly structure and to cleanly combine various verification sub-tasks. In the paper we discuss the design of the tool and provide early indications on its performance.}}
