@ARTICLE{Larsen_1997,title={UPPAAL in a Nutshell},year={1997},author={Kim Guldstrand Larsen and Kim Guldstrand Larsen and Paul Pettersson and Paul Pettersson and Wang Yi and Wang Yi},doi={10.1007/s100090050010},pmid={null},pmcid={null},mag_id={2000947342},journal={International Journal on Software Tools for Technology Transfer},abstract={This paper presents the overal structure, the design criteria, and the main features of the tool box Uppaal. It gives a detailed user guide which describes how to use the various tools of Uppaal version 2.02 to construct abstract models of a real-time system, to simulate its dynamical behavior, to specify and verify its safety and bounded liveness properties in terms of its model. In addition, the paper also provides a short review on case-studies where Uppaal is applied, as well as references to its theoretical foundation.}}
@ARTICLE{Behrmann_2001,title={Minimum-Cost Reachability for Priced Timed Automata},year={2001},author={Gerd Behrmann and Gerd Behrmann and Ansgar Fehnker and Ansgar Fehnker and Thomas Hune and Thomas Hune and Kim Guldstrand Larsen and Kim Guldstrand Larsen and Paul Pettersson and Paul Pettersson and Judi Romijn and Judi Romijn and Frits Vaandrager and Frits W. Vaandrager},doi={10.1007/3-540-45351-2_15},pmid={null},pmcid={null},mag_id={2065323166},journal={null},abstract={This paper introduces the model of linearly priced timed automata as an extension of timed automata, with prices on both transitions and locations. For this model we consider the minimum-cost reachability problem: i.e. given a linearly priced timed automaton and a target state, determine the minimum cost of executions from the initial state to the target state. This problem generalizes the minimum-time reachability problem for ordinary timed automata. We prove decidability of this problem by offering an algorithmic solution, which is based on a combination of branch-and-bound techniques and a new notion of priced regions. The latter allows symbolic representation and manipulation of reachable states together with the cost of reaching them.}}
@ARTICLE{Alur_1994,title={A theory of timed automata},year={1994},author={Rajeev Alur and Rajeev Alur and David L. Dill and David L. Dill},doi={10.1016/0304-3975(94)90010-8},pmid={null},pmcid={null},mag_id={2101508170},journal={Theoretical Computer Science},abstract={Alur, R. and D.L. Dill, A theory of timed automata, Theoretical Computer Science 126 (1994) 183-235. We propose timed (j&e) automata to model the behavior of real-time systems over time. Our definition provides a simple, and yet powerful, way to annotate state-transition graphs with timing constraints using finitely many real-valued clocks. A timed automaton accepts timed words-infinite sequences in which a real-valued time of occurrence is associated with each symbol. We study timed automata from the perspective of formal language theory: we consider closure properties, decision problems, and subclasses. We consider both nondeterministic and deterministic transition structures, and both Biichi and Muller acceptance conditions. We show that nondeterministic timed automata are closed under union and intersection, but not under complementation, whereas deterministic timed Muller automata are closed under all Boolean operations. The main construction of the paper is an (PSPACE) algorithm for checking the emptiness of the language of a (nondeterministic) timed automaton. We also prove that the universality problem and the language inclusion problem are solvable only for the deterministic automata: both problems are undecidable (II i-hard) in the nondeterministic case and PSPACE-complete in the deterministic case. Finally, we discuss the application of this theory to automatic verification of real-time requirements of finite-state systems.}}
@ARTICLE{Alur_2001,title={Optimal Paths in Weighted Timed Automata},year={2001},author={Rajeev Alur and Rajeev Alur and Salvatore La Torre and Salvatore La Torre and George J. Pappas and George J. Pappas},doi={10.1007/3-540-45351-2_8},pmid={null},pmcid={null},mag_id={1573865009},journal={null},abstract={We consider an optimal-reachability problem for a timed automaton with respect to a linear cost function which results in a weighted timed automaton. Our solution to this optimization problem consists of reducing it to a (parametric) shortest-path problem for a finite directed graph. The directed graph we construct is a refinement of the region automaton due to Alur and Dill. We present an exponential time algorithm to solve the shortest-path problem for weighted timed automata starting from a single state, and a doubly-exponential time algorithm to solve this problem starting from a zone of the state space.}}
@ARTICLE{Behrmann_2001,title={Efficient Guiding Towards Cost-Optimality in UPPAAL},year={2001},author={Gerd Behrmann and Gerd Behrmann and Ansgar Fehnker and Ansgar Fehnker and Thomas Hune and Thomas S. Hune and Kim G. Larsen and Kim Guldstrand Larsen and Paul Pettersson and Paul Pettersson and Judi Romijn and Judi Romijn},doi={10.1007/3-540-45319-9_13},pmid={null},pmcid={null},mag_id={1820192350},journal={null},abstract={In this paper we present an algorithm for efficiently computing the minimum cost of reaching a goal state in the model of Uniformly Priced Timed Automata (UPTA). This model can be seen as a submodel of the recently suggested model of linearly priced timed automata, which extends timed automata with prices on both locations and transitions. The presented algorithm is based on a symbolic semantics of UTPA, and an efficient representation and operations based on difference bound matrices. In analogy with Dijkstra's shortest path algorithm, we show that the search order of the algorithm can be chosen such that the number of symbolic states explored by the algorithm is optimal, in the sense that the number of explored states can not be reduced by any other search order. We also present a number of techniques inspired by branch-and-bound algorithms which can be used for limiting the search space and for quickly finding near-optimal solutions.The algorithm has been implemented in the verification tool UPPAAL. When applied on a number of experiments the presented techniques reduced the explored state-space with up to 90%.}}
@ARTICLE{Behrmann_2001,title={Guiding and Cost-Optimality in UPPAAL},year={2001},author={Gerd Behrmann and Gerd Behrmann and Ansgar Fehnker and Ansgar Fehnker and Thomas Hune and T. Hune and Kim Guldstrand Larsen and Kim Guldstrand Larsen and Paul Pettersson and Paul Pettersson and Judi Romijn and Judi Romijn},doi={null},pmid={null},pmcid={null},mag_id={2131637201},journal={null},abstract={In this paper we present an algorithm for efficiently computing the minimum cost of reaching a goal state in the model of Uniformly Priced Timed Automata (UPTA). This model can be seen as a submodel of the recently suggested model of linearly priced timed automata, which extends timed automata with prices on both locations and transitions. The presented algorithm is based on a symbolic semantics of UTPA, and an efficient representation and operations based on difference bound matrices. In analogy with Dijkstra’s shortest path algorithm, we show that the search order of the algorithm can be chosen such that the number of symbolic states explored by the algorithm is optimal, to be optimal, in the sense that the number of explored states can not be reduced by any other search order. We also present a number of techniques inspired by branch-and-bound algorithms which can be used for limiting the search space and for quickly finding near-optimal solutions. The algorithm has been implemented in the verification tool UPPAAL. When applied on a number of experiments the presented techniques reduced the explored state-space with up to 90%.}}
@ARTICLE{Fehnker_1999,title={Scheduling a steel plant with timed automata},year={1999},author={Ansgar Fehnker and Ansgar Fehnker},doi={10.1109/rtcsa.1999.811256},pmid={null},pmcid={null},mag_id={1878516677},journal={null},abstract={Scheduling in an environment with constraints of many different types is known to be a hard problem. We tackle this problem for an integrated steel plant in Ghent, Belgium, using UPPAAL, a model checker for networks of timed automata. We show how to translate schedulability to reachability, enabling us to use UPPAAL's model checking algorithms.}}
@ARTICLE{Alur_1993,title={Model-Checking in Dense Real-Time},year={1993},author={Rajeev Alur and Rajeev Alur and Costas Courcoubetis and Costas Courcoubetis and David L. Dill and David L. Dill},doi={10.1006/inco.1993.1024},pmid={null},pmcid={null},mag_id={1981808971},journal={null},abstract={Model-checking is a method of verifying concurrent systems in which a state-transition graph model of the system behavior is compared with a temporal logic formula. This paper extends model-checking for the branching-time logic CTL to the analysis of real-time systems, whose correctness depends on the magnitudes of the timing delays. For specifications, we extend the syntax of CTL to allow quantitative temporal operators such as ?? <5, meaning "possibly within 5 time units." The formulas of the resulting logic, Timed CTL (TCTL), are interpreted over continuous computation trees, trees in which paths are maps from the set of nonnegative reals to system states. To model finite-state systems we introduce timed graphs-state-transition graphs annotated with timing constraints. As our main result, we develop an algorithm for model-checking, for determining the truth of a TCTL-formula with respect to a timed graph. We argue that choosing a dense domain instead of a discrete domain to model time does not significantly blow up the complexity of the model-checking problem. On the negative side, we show that the denseness of the underlying time domain makes the validity problem for TCTL ?11-hard. The question of deciding whether there exists a timed graph satisfying a TCTL-formula is also undecidable.}}
@ARTICLE{Clarke_1996,title={Model checking},year={1996},author={Edmund M. Clarke and Edmund M. Clarke and Orna Grumberg and Orna Grumberg and David E. Long and D. Long},doi={null},pmid={null},pmcid={null},mag_id={2913459036},journal={null},abstract={null}}
@ARTICLE{Alur_1990,title={Automata for modeling real-time systems},year={1990},author={Rajeev Alur and Rajeev Alur and David L. Dill and David L. Dill},doi={10.1007/bfb0032042},pmid={null},pmcid={null},mag_id={59365162},journal={null},abstract={To model the behavior of finite-state asynchronous real-time systems we propose the notion of timed Buchi automata (TBA). TBAs are Buchi automata coupled with a mechanism to express constant bounds on the timing delays between system events. These automata accept languages of timed traces, traces in which each event has an associated real-valued time of occurrence.}}
@ARTICLE{Alur_1999,title={``Next'' Heuristic for On-the-Fly Model Checking},year={1999},author={Rajeev Alur and Rajeev Alur and Bow-Yaw Wang and Bow-Yaw Wang},doi={10.1007/3-540-48320-9_9},pmid={null},pmcid={null},mag_id={1487141335},journal={null},abstract={We present a new heuristic for on-the-fly enumerative invariant verification. The heuristic is based on a construct for temporal scaling, called next, that compresses a sequence of transitions leading to a given target set into a single metatransition. First, we give an on-the-fly algorithm to search a process expression built using the constructs of hiding, parallel composition, and temporal scaling. Second, we show that as long the target set Θ of transitions includes all transitions that access variables shared with the environment, the process next Θ for P and P are equivalent according to the weak-simulation equivalence. As a result, to search the product of given processes, we can cluster processes into groups with as little communication among them as possible, and compose the groups only after applying appropriate hiding and temporal scaling operators. Applying this process recursively gives an expression that has multiple nested applications of next, and has potentially much fewer states than the original product. We report on an implementation, and show significant reductions for a tree-structured parity computer and a ring-structured leader-election protocol.}}
@ARTICLE{Milner_1989,title={Communication and Concurrency},year={1989},author={Robin Milner and Robin Milner},doi={null},pmid={null},pmcid={null},mag_id={1503973138},journal={null},abstract={Foreword. 1. Modelling Communication. 2. Basic Definitions. 3. Equational laws and Their Application. 4. Strong Bisimulation and Strong Equivalence. 5. Bisimulation and Observation Equivalence. 6. Further Examples. 7. The Theory of Observation Congruence. 8. Defining a Programming Language. 9. Operators and Calculi. 10. Specifications and Logic. 11. Determinancy and Confluence. 12. Sources and Related Work. Bibliography. Index.}}
@ARTICLE{Behrmann_2004,title={Priced timed automata: algorithms and applications},year={2004},author={Gerd Behrmann and Gerd Behrmann and Kim G. Larsen and Kim Guldstrand Larsen and Jacob Illum Rasmussen and Jacob Illum Rasmussen},doi={10.1007/11561163_8},pmid={null},pmcid={null},mag_id={1587691136},journal={null},abstract={This contribution reports on the considerable effort made recently towards extending and applying well-established timed automata technology to optimal scheduling and planning problems. The effort of the authors in this direction has to a large extent been carried out as part of the European projects Vhs [22] and Ametist [17] and are available in the recently released Uppaal Cora [12], a variant of the real-time verification tool Uppaal [20,5] specialized for cost-optimal reachability for the extended model of priced timed automata.}}
@ARTICLE{Queille_1982,title={Specification and verification of concurrent systems in CESAR},year={1982},author={Jean-Pierre Queille and Jean-Pierre Queille and Joseph Sifakis and Joseph Sifakis},doi={10.1007/3-540-11494-7_22},pmid={null},pmcid={null},mag_id={1593428110},journal={null},abstract={The aim of this paper is to illustrate by an example, the alternating bit protocol, the use of CESAR, an interactive system for aiding the design of distributed applications.}}
@ARTICLE{Fahrenberg_2013,title={Model-Based Verification, Optimization, Synthesis and Performance Evaluation of Real-Time Systems},year={2013},author={Uli Fahrenberg and Uli Fahrenberg and Kim Guldstrand Larsen and Kim Guldstrand Larsen and Axel Legay and Axel Legay},doi={10.1007/978-3-642-39721-9_2},pmid={null},pmcid={null},mag_id={1740082429},journal={null},abstract={This article aims at providing a concise and precise Travellers Guide, Phrase Book or Reference Manual to the timed automata modeling formalism introduced by Alur and Dill [8, 9]. The paper gives comprehensive definitions of timed automata, priced or weighted timed automata, timed games, stochastic timed automata and highlights a number of results on associated decision problems related to model checking, equivalence checking, optimal scheduling, the existence of winning strategies, and then statistical model checking.}}
@ARTICLE{Henzinger_1997,title={HYTECH: A Model Checker for Hybrid Systems},year={1997},author={Thomas A. Henzinger and Thomas A. Henzinger and Pei-Hsin Ho and Pei-Hsin Ho and Howard Wong-Toi and Howard Wong-Toi},doi={10.1007/3-540-63166-6_48},pmid={null},pmcid={null},mag_id={1905380539},journal={null},abstract={A hybrid system consists of a collection of digital programs that interact with each other and with an analog environment. Examples of hybrid systems include medical equipment, manufacturing controllers, automotive controllers, and robots. The formal analysis of the mixed digital-analog nature of these systems requires a model that incorporates the discrete behavior of computer programs with the continuous behavior of environment variables, such as temperature and pressure. Hybrid automata capture both types of behavior by combining finite automata with differential inclusions (i.e. differential inequalities). HyTech is a symbolic model checker for linear hybrid automata, an expressive, yet automatically analyzable, subclass of hybrid automata. A key feature of HyTech is its ability to perform parametric analysis, i.e. to determine the values of design parameters for which a linear hybrid automaton satisfies a temporal requirement.}}
@ARTICLE{Hune_2000,title={Guided Synthesis of Control Programs Using UPPAAL},year={2000},author={Thomas Hune and Thomas Hune and Kim Guldstrand Larsen and Kim Guldstrand Larsen and Paul Pettersson and Paul Pettersson},doi={null},pmid={null},pmcid={null},mag_id={1957639564},journal={null},abstract={In this paper we address the problem of scheduling and synthesizing distributed control programs for a batch production plant. We use a timed automata model of the batch plant and the verification tool UPPAAL to solve the scheduling problem.In modeling the plant, we aim at a level of abstraction which is sufficiently accurate in order that synthesis of control programs from generated timed traces is possible. Consequently, the models quickly become too detailed and complicated for immediate automatic synthesis. In fact, only models of plants producing two batches can be analyzed directly! To overcome this problem, we present a general method allowing the user to guide the model-checker according to heuristically chosen strategies. The guidance is specified by augmenting the model with additional guidance variables and by decorating transitions with extra guards on these. Applying this method have made synthesis of control programs feasible for a plant producing as many as 60 batches.The synthesized control programs have been executed in a physical plant. Besides proving useful in validating the plant model and in finding some modeling errors, we view this final step as the ultimate litmus test of our methodology's ability to generate executable (and executing) code from basic plant models.}}
@ARTICLE{Yang_1998,title={Validation with guided search of the state space},year={1998},author={Congguang Yang and C.H. Yang and C. Han Yang and C.H. Yang and David L. Dill and David L. Dill},doi={10.1145/277044.277201},pmid={null},pmcid={null},mag_id={1975112016},journal={null},abstract={In practice, model checkers are most useful when they find bugs, not when they prove a property. However, because large portions of the state space of the design actually satisfy the specification, model checkers devote much effort verifying correct portions of the design. In this paper, we enhance the bug-finding capability of a model checker by using heuristics to search the states that are most likely to lead to an error, first. Reductions of 1 to 3 orders of magnitude in the number of states needed to find bugs in industrial designs have been observed. Consequently, these heuristics can extend the capability of model checkers to find bugs in designs.}}
@ARTICLE{Abdeddaïm_2006,title={Scheduling with timed automata},year={2006},author={Yasmina Abdeddaïm and Yasmina Abdeddaïm and Eugène Asarin and Eugene Asarin and Oded Maler and Oded Maler},doi={10.1016/j.tcs.2005.11.018},pmid={null},pmcid={null},mag_id={1987234253},journal={Theoretical Computer Science},abstract={In this work, we present timed automata as a natural tool for posing and solving scheduling problems. We show how efficient shortest path algorithms for timed automata can find optimal schedules for the classical job-shop problem. We then extend these results to synthesize adaptive scheduling strategies for problems with uncertainty in task durations.}}
@ARTICLE{Behrmann_2005,title={Optimal scheduling using priced timed automata},year={2005},author={Gerd Behrmann and Gerd Behrmann and Kim G. Larsen and Kim Guldstrand Larsen and Jacob Illum Rasmussen and Jacob Illum Rasmussen},doi={10.1145/1059816.1059823},pmid={null},pmcid={null},mag_id={1987734880},journal={null},abstract={This contribution reports on the considerable effort made recently towards extending and applying well-established timed automata technology to optimal scheduling and planning problems. The effort of the authors in this direction has to a large extent been carried out as part of the European projects VHS [20] and AMETIST [16] and are available in the recently released UPPAAL CORA [12], a variant of the real-time verification tool UPPAAL [18, 5] specialized for cost-optimal reachability for the extended model of so-called priced timed automata.}}
@ARTICLE{McBratney_2005,title={Future Directions of Precision Agriculture},year={2005},author={Alex B. McBratney and Alex B. McBratney and Brett Whelan and Brett Whelan and Tihomir Ancev and Tihomir Ancev and J. Bouma and Johan Bouma},doi={10.1007/s11119-005-0681-8},pmid={null},pmcid={null},mag_id={2041137640},journal={Precision Agriculture},abstract={Precision Agriculture is advancing but not as fast as predicted 5 years ago. The development of proper decision-support systems for implementing precision decisions remains a major stumbling block to adoption. Other critical research issues are discussed, namely, insufficient recognition of temporal variation, lack of whole-farm focus, crop quality assessment methods, product tracking and environmental auditing. A generic research programme for precision agriculture is presented. A typology of agriculture countries is introduced and the potential of each type for precision agriculture discussed.}}
@ARTICLE{Largouët_2012,title={Use of timed automata and model-checking to explore scenarios on ecosystem models},year={2012},author={Christine Largouët and Christine Largouët and Christine Largouët and Christine Largouët and Marie-Odile Cordier and Marie-Odile Cordier and Yves‐Marie Bozec and Yves-Marie Bozec and Yulong Zhao and Yulong Zhao and Guy Fontenelle and Guy Fontenelle},doi={10.1016/j.envsoft.2011.08.005},pmid={null},pmcid={null},mag_id={2043586908},journal={Environmental Modelling and Software},abstract={null}}
@ARTICLE{Behrmann_2005,title={Production scheduling by reachability analysis - a case study},year={2005},author={Gerd Behrmann and Gerd Behrmann and Ed Brinksma and Ed Brinksma and Martijn Hendriks and Martijn Hendriks and Angelika Mader and Angelika Mader},doi={10.1109/ipdps.2005.363},pmid={null},pmcid={null},mag_id={2103655846},journal={null},abstract={Schedule synthesis based on reachability analysis of timed automata has received attention in the last few years. The main strength of this approach is that the expressiveness of timed automata allows - unlike many classical approaches - the modelling of scheduling problems of very different kinds. Furthermore, the models are robust against changes in the parameter setting and against changes in the problem specification. This paper presents a case study that was provided by Axxom, an industrial partner of the AMETIST project. It consists of a scheduling problem for lacquer production, and is treated with the timed automata approach. A number of problems have to be addressed for the modelling task: the information transfer from the industrial partner, the derivation of timed automaton model for the case study, and the heuristics that have to be added in order to reduce the search space. We try to isolate the generic problems of modelling for model checking, and suggest solutions that are also applicable for other scheduling cases. Model checking experiments and solutions are discussed.}}
@ARTICLE{Edelkamp_2001,title={Directed explicit model checking with HSF-SPIN},year={2001},author={Stefan Edelkamp and Stefan Edelkamp and Alberto Lafuente and Alberto Lluch Lafuente and Stefan Leue and Stefan Leue},doi={10.1007/3-540-45139-0_5},pmid={null},pmcid={null},mag_id={2136199343},journal={null},abstract={We present the explicit state model checker HSF-SPIN which is based on the model checker SPIN and its Promela modeling language. HSF-SPIN incorporates directed search algorithms for checking safety and a large class of LTL-specified liveness properties. We start off from the A* algorithm and define heuristics to accelerate the search into the direction of a specified failure situation. Next we propose an improved nested depth-first search algorithm that exploits the structure of Promela Never-Claims. As a result of both improvements, counterexamples will be shorter and the explored part of the state space will be smaller than with classical approaches, allowing to analyze larger state spaces. We evaluate the impact of the new heuristics and algorithms on a set of protocol models, some of which are real-world industrial protocols.}}
@ARTICLE{Bozga_1998,title={Kronos: A Model-Checking Tool for Real-Time Systems},year={1998},author={Marius Bozga and Marius Bozga and Conrado Daws and Conrado Daws and Oded Maler and Oded Maler and Alfredo Olivero and Alfredo Olivero and Alfredo Olivero and Stavros Tripakis and Stavros Tripakis and Sergio Yovine and Sergio Yovine},doi={10.1007/bfb0055357},pmid={null},pmcid={null},mag_id={2142718416},journal={null},abstract={Kronos [8,10,7,11,20,16,4,3,9] is a software tool aiming at assisting designers of real-time systems to develop projects meeting the specified requirements. One major objective of Kronos is to provide a verification engine to be integrated into design environments for real-time systems in a wide range of application areas. Real-time communication protocols [8,10], timed asynchronous circuits [16,4], and hybrid systems [18,10] are some examples of application domains where Kronos has already been used. Kronos has been also used in analyzing real-time systems modeled in several other process description formalisms, such as Atp [17], Aorta [5], Et-lotos [8], and T-argos [15]. On the other direction, the tool itself provides an interface to untimed formalisms such as labeled-transition systems (LTS) which has been used to exploit untimed verification techniques [20].}}
@ARTICLE{Larsen_1997,title={Efficient verification of real-time systems: compact data structure and state-space reduction},year={1997},author={Kim Guldstrand Larsen and Kim Guldstrand Larsen and Fredrik Larsson and Fredrik Larsson and Fredrik Larsson and Paul Pettersson and Paul Pettersson and Wang Yi and Wang Yi},doi={10.1109/real.1997.641265},pmid={null},pmcid={null},mag_id={2145000217},journal={null},abstract={During the past few years, a number of verification tools have been developed for real-time systems in the framework of timed automata (e.g. KRONOS and UPPAAL). One of the major problems in applying these tools to industrial-size systems is the huge memory-usage for the exploration of the state-space of a network (or product) of timed automata, as the model-checkers must keep information on not only the control structure of the automata but also the clock values specified by clock constraints. In this paper, we present a compact data structure for representing clock constraints. The data structure is based on an O(n/sup 3/) algorithm which, given a constraint system over real-valued variables consisting of bounds on differences, constructs an equivalent system with a minimal number of constraints. In addition, we have developed an on-the-fly, reduction technique to minimize the space-usage. Based on static analysis of the control structure of a network of timed automata, we are able to compute a set of symbolic states that cover all the dynamic loops of the network in an on-the-fly searching algorithm, and thus ensure termination in reachability analysis. The two techniques and their combination have been implemented in the tool UPPAAL. Our experimental results demonstrate that the techniques result in truly significant space-reductions: for six examples from the literature, the space saving is between 75% and 94%, and in (nearly) all examples time-performance is improved. Also noteworthy is the observation that the two techniques are completely orthogonal.}}
@ARTICLE{Behrmann_2005,title={Scheduling Lacquer Production by Reachability Analysis -- A Case Study},year={2005},author={Gerd Behrmann and Gerd Behrmann and Ed Brinksma and Ed Brinksma and Martijn Hendriks and Martijn Hendriks and Angelika Mader and Angelika Mader},doi={10.3182/20050703-6-cz-1902.01433},pmid={null},pmcid={null},mag_id={2163160103},journal={null},abstract={In this paper we describe a case study on lacquer production scheduling that was performed in the European IST-project AMETIST and was provided by one of the industrial partners. The approach is to derive schedules by means of reachability analysis: with this technique the search mechanism of model checkers, in our case here Uppaal, is used to find feasible or optimal schedules. The advantage of this approach is that the expressiveness of timed automata allows to model scheduling problems of different kinds, unlike many classical approaches, and the problem class is robust against changes in the parameter setting. To fight the typical state space explosion problem a number of standard heuristics have to be used. We discuss the difficulties when modelling an industrial case of this kind, describe the experiments we performed, the heuristics used, and the techniques applied to allow to optimize costs (storage costs, delay costs, etc.) while searching for schedules.}}
@ARTICLE{Briot_2015,title={A constraint-based approach to the differential harvest problem},year={2015},author={N. Briot and Nicolas Briot and Christian Bessière and Christian Bessiere and Philippe Vismara and Philippe Vismara},doi={10.1007/978-3-319-23219-5_38},pmid={null},pmcid={null},mag_id={2263731668},journal={null},abstract={In this paper, we study the problem of differential harvest in precision viticulture. Some recent prototypes of grape harvesting machines are supplied with two hoppers and are able to sort two types of grape quality. Given estimated qualities and quantities on the different areas of the vineyard, the problem is to optimize the routing of the grape harvester under several constraints. The main constraints are the amount of first quality grapes to harvest and the capacity of the hoppers. We model the differential harvest problem as a constraint optimization problem. We present preliminary results on real data. We also compare our constraint model to an integer linear programming approach and discuss expressiveness and efficiency.}}
@ARTICLE{Clarke_1999,title={Model Checking},year={1999},author={Edmund M. Clarke and Edmund M. Clarke and Bernd-Holger Schlingloff and Bernd-Holger Schlingloff},doi={null},pmid={null},pmcid={null},mag_id={2340735175},journal={null},abstract={null}}
@ARTICLE{Hune_2000,title={Guided Synthesis of Control Programs for a Batch Plant using UPPAAL},year={2000},author={Thomas Hune and Thomas Hune and Kim G. Larsen and Kim Guldstrand Larsen and Paul Pettersson and Paul Pettersson},doi={10.7146/brics.v7i37.20203},pmid={null},pmcid={null},mag_id={2379209625},journal={BRICS Report Series},abstract={In this paper we address the problem of scheduling and  synthesizing distributed control programs for a batch production plant. We use a timed automata model of the batch plant and the verification tool Uppaal to solve the scheduling problem. In modeling the plant, we aim at a level of abstraction which is sufficiently accurate in order that synthesis of control programs from generated timed traces is possible. Consequently, the models quickly become too detailed and complicated for immediate automatic synthesis. In fact, only models of plants producing two batches can be analyzed directly! To overcome this problem, we present a general method allowing the user to guide the model-checker according to heuristically chosen strategies. The guidance is specified by augmenting the model with additional guidance variables and by decorating transitions with extra guards on these. Applying this method has made synthesis of control programs feasible for a plant producing as many as 60 batches. The synthesized control programs have been executed in a physical plant.  Besides proving useful in validating the plant model and in finding some modeling errors, we view this final step as the ultimate litmus test of our methodology's ability to generate executable (and executing) code from basic plant models.}}
@ARTICLE{Briot_2015,title={Integration of Operational Constraints to Optimize Differential Harvest in Viticulture},year={2015},author={N. Briot and Nicolas Briot and Christian Bessière and Christian Bessiere and Bruno Tisseyre and Bruno Tisseyre and Bruno Tisseyre and Philippe Vismara and Philippe Vismara},doi={10.3920/978-90-8686-814-8_60},pmid={null},pmcid={null},mag_id={2475379419},journal={null},abstract={One of the most important applications of precision agriculture to viticulture is the management of the quality of grapes at the field level through selective harvest. The recent developments of prototypes of conventional grape harvesting machines are able to sort two types of harvest quality. In this paper, we propose a formal description of the problem of differential harvesting. The objective is to optimize the routing of the grape harvester under several constraints. Our approach is based on Constraint Programming (CP), which is a powerful paradigm to solve combinatorial problems. We give a formulation of the problem as a Constraint Optimization Problem. The last section of the paper is devoted to preliminary experimental results on real data from a French vineyard.}}
@ARTICLE{Saddem-yagoubi_2017,title={Precision spraying: from map to sprayer control using model-checking},year={2017},author={Rim Saddem-yagoubi and Rim Saddem-Yagoubi and Olivier Naud and Olivier Naud and Paul Cazenave and Paul Cazenave and Karen Godary-Dejean and Karen Godary-Dejean and Didier Crestani and Didier Crestani},doi={10.17700/jai.2017.8.3.392},pmid={null},pmcid={null},mag_id={2770275641},journal={Journal of Agricultural Informatics},abstract={Precision agriculture is a set of methods based on spatial and timed information which aims at making agricultural operations specific to local crop needs. This study was conducted to contribute to precision spraying for trellised perennial crops such as grapevine with a new method called Automata Modelling for Precision Spraying (AMPS). AMPS is based on the timed automata formalism and the UppAal-CORA model-checking tool with cost optimisation. It takes 2D ground-based LiDAR data of the canopy as input and computes a command sequence for the sprayer that is optimized for a cost criterion. AMPS was tested on LiDAR data from a vine row and with a hypothetical sprayer model based on pneumatic technology and individual command for each spout. The chosen cost criterion was the amount of product sprayed on the row. It was demonstrated on the example that a significant proportion of phytosanitary product can be saved. It was also shown that it is necessary to take into account spout control dynamics, because the savings are inferior to the ideal case in which spout response would be instantaneous.}}
@ARTICLE{Bozga_1998,title={kronos a model checking tool for real time systems},year={1998},author={Marius Bozga and Conrado Daws and Oded Maler and Alfredo Olivero and Stavros Tripakis and Sergio Yovine},doi={10.1007/bfb0055357},pmid={null},pmcid={null},mag_id={2999351791},journal={null},abstract={null}}
@ARTICLE{Edelkamp_null,title={Directed explicit model checking with HSF-SPIN},year={null},author={Stefan Edelkamp and Stefan Edelkamp and Alberto Lluch Lafuente and Alberto Lluch Lafuente and Stefan Leue and Stefan Leue},doi={10.1007/3-540-45139-0_5},pmid={null},pmcid={null},mag_id={4234244433},journal={Lecture Notes in Computer Science},abstract={We present the explicit state model checker HSF-SPIN which is based on the model checker SPIN and its Promela modeling language. HSF-SPIN incorporates directed search algorithms for checking safety and a large class of LTL-specified liveness properties. We start off from the A* algorithm and define heuristics to accelerate the search into the direction of a specified failure situation. Next we propose an improved nested depth-first search algorithm that exploits the structure of Promela Never-Claims. As a result of both improvements, counterexamples will be shorter and the explored part of the state space will be smaller than with classical approaches, allowing to analyze larger state spaces. We evaluate the impact of the new heuristics and algorithms on a set of protocol models, some of which are real-world industrial protocols.KeywordsModel CheckSafety PropertyLiveness PropertyStrongly Connect ComponentSymbolic Model CheckThese keywords were added by machine and not by the authors. This process is experimental and the keywords may be updated as the learning algorithm improves.}}
@ARTICLE{Behrmann_null,title={Minimum-Cost Reachability for Priced Timed Automata},year={null},author={Gerd Behrmann and Gerd Behrmann and Ansgar Fehnker and Ansgar Fehnker and Thomas Hune and Thomas S. Hune and Kim G. Larsen and Kim G. Larsen and Paul Pettersson and Paul Pettersson and Judi Romijn and Judi Romijn and Frits Vaandrager and Frits W. Vaandrager},doi={10.7146/brics.v8i3.20457},pmid={null},pmcid={null},mag_id={4245606633},journal={BRICS Report Series},abstract={&lt;p&gt;This paper introduces the model of linearly priced timed automata as an extension of timed automata, with prices on both transitions and locations. For this model we consider the minimum-cost reachability problem: i.e. given a linearly priced timed automaton and a target&lt;br /&gt;state, determine the minimum cost of executions from the initial state to the target state. This problem generalizes the minimum-time reachability problem for ordinary timed automata. We prove decidability of this problem by offering an algorithmic solution, which is based on a combination of branch-and-bound techniques and a new notion of priced regions. The latter allows symbolic representation and manipulation of reachable states together with the cost of reaching them.&lt;/p&gt;&lt;p&gt;Keywords: Timed Automata, Verification, Data Structures, Algorithms,&lt;br /&gt;Optimization.&lt;/p&gt;}}
@ARTICLE{Stern_1997,title={Parallelizing the Murϕ verifier},year={1997},author={Ulrich Stern and Ulrich Stern and David L. Dill and David L. Dill},doi={10.1007/3-540-63166-6_26},pmid={null},pmcid={null},mag_id={30961909},journal={null},abstract={With the use of state and memory reduction techniques in verification by explicit state enumeration, runtime becomes a major limiting factor. We describe a parallel version of the explicit state enumeration verifier Murϕ for distributed memory multiprocessors and networks of workstations that is based on the message passing paradigm. In experiments with three complex cache coherence protocols, parallel Murϕ shows close to linear speedups, which are largely insensitive to communication latency and bandwidth. There is some slowdown with increasing communication overhead, for which a simple yet relatively accurate approximation formula is given. Techniques to reduce overhead and required bandwidth and to allow heterogeneity and dynamically changing load in the parallel machine are discussed, which we expect will allow good speedups when using conventional networks of workstations.}}
@ARTICLE{Edelkamp_2001,title={Directed symbolic exploration and its application to AI-planning},year={2001},author={Stefan Edelkamp},doi={null},pmid={null},pmcid={null},mag_id={32073368},journal={null},abstract={null}}
@ARTICLE{Bozga_2004,title={Tools and Applications II: The IF Toolset},year={2004},author={Marius Bozga and Susanne Graf and Ileana Ober and Iulian Ober and Joseph Sifakis},doi={10.1007/b110123},pmid={null},pmcid={null},mag_id={36240330},journal={null},abstract={This paper presents an overview on the IF toolset which is an environment for modelling and validation of heterogeneous real-time systems. The toolset is built upon a rich formalism, the IF notation, allowing structured automata-based system representations. Moreover, the IF notation is expressive enough to support real-time primitives and extensions of high-level modelling languages such as SDL and UML by means of structure preserving mappings. The core part of the IF toolset consists of a syntactic transformation component and an open exploration platform. The syntactic transformation component provides language level access to IF descriptions and has been used to implement static analysis and optimisation techniques. The exploration platform gives access to the graph of possible executions. It has been connected to different state-of-the-art model-checking and test-case generation tools. A methodology for the use of the toolset is presented at hand of a case study concerning the Ariane-5 Flight Program for which both an SDL and a UML model have been validated.}}
@ARTICLE{Pardalos_2008,title={Nonconvex Optimization and Its Applications},year={2008},author={Pãnos M. Pardalos and Panos M. Pardalos and Shashi Kant Mishra and Shashi Kant Mishra and Shouyang Wang and Shouyang Wang and Kin Keung Lai and Kin Keung Lai},doi={null},pmid={null},pmcid={null},mag_id={75245544},journal={null},abstract={null}}
@ARTICLE{Panek_2005,title={Scheduling of a pipeless multi-product batch plant using mixed-integer programming combined with heuristics},year={2005},author={Sebastian Panek and Sebastian Panek and Sebastian Engell and Sebastian Engell and Cathrin Lessner and Cathrin Lessner},doi={10.1016/s1570-7946(05)80014-8},pmid={null},pmcid={null},mag_id={97779480},journal={Computer-aided chemical engineering},abstract={null}}
@ARTICLE{Stern_1997,title={Parallelizing the Murphi Verifier},year={1997},author={Ulrich Stern and Ulrich Stern and David L. Dill and David L. Dill},doi={null},pmid={null},pmcid={null},mag_id={107427404},journal={null},abstract={null}}
@ARTICLE{Ammann_2008,title={Introduction to Software Testing: List of Figures},year={2008},author={Paul Ammann and Paul Ammann and Jeff Offutt and Jeff Offutt},doi={10.1017/cbo9780511809163},pmid={null},pmcid={null},mag_id={163074494},journal={null},abstract={Extensively class-tested, this textbook takes an innovative approach to software testing: it defines testing as the process of applying a few well-defined, general-purpose test criteria to a structure or model of the software. It incorporates the latest innovations in testing, including techniques to test modern types of software such as OO, web applications, and embedded software. The book contains numerous examples throughout. An instructor's solution manual, PowerPoint slides, sample syllabi, additional examples and updates, testing tools for students, and example software programs in Java are available on an extensive website.}}
@ARTICLE{Stork_2001,title={Stochastic resource-constrained project scheduling},year={2001},author={Frederik Stork and Frederik Stork},doi={10.14279/depositonce-398},pmid={null},pmcid={null},mag_id={178659373},journal={null},abstract={null}}
@ARTICLE{Konrad_2004,title={4 Minimal Model Generation},year={2004},author={Karsten Konrad and Karsten Konrad},doi={10.1007/978-3-540-24640-4_4},pmid={null},pmcid={null},mag_id={189209848},journal={null},abstract={We now define a new class of models for \({\cal {MQL}}\) specification, the locally minimal models. They are an amalgamation of domain minimal models and subset-minimal models known from first-order model generation. The property of being a local minimal model in our logic \({\cal {MQL}}\) is decidable.}}
@ARTICLE{Bérard_2001,title={Systems and Software Verification},year={2001},author={Béatrice Bérard and Béatrice Bérard and Michel Bidoit and Michel Bidoit and Alain Finkel and Alain Finkel and François Laroussinie and François Laroussinie and Antoine Petit and Antoine Petit and Antoine Petit and Laure Petrucci and Laure Petrucci and Philippe Schnoebelen and Philippe Schnoebelen and Philippe Schnoebelen and Pierre McKenzie and Pierre McKenzie},doi={10.1007/978-3-662-04558-9},pmid={null},pmcid={null},mag_id={198918365},journal={null},abstract={null}}
@ARTICLE{Méndez_2003,title={An MILP Continuous-Time Framework for Short-Term Scheduling of Multipurpose Batch Processes Under Different Operation Strategies},year={2003},author={Carlos A. Méndez and Carlos A. Méndez and Carlos A. Méndez and Jaime Cerdá and Jaime Cerdá},doi={10.1023/a:1021856229236},pmid={null},pmcid={null},mag_id={249409625},journal={Optimization and Engineering},abstract={This work introduces a novel MILP continuous-time framework to the optimal short-term scheduling of non-sequential multipurpose batch processes with intermediate storage vessels. It is based on a problem representation that describes the batch sequence at any processing/storage unit by providing the full set of predecessors for every batch. Different operation modes can be considered by making minor changes in the problem model. The proposed framework can also handle sequence-dependent changeovers as well as multiple storage tanks available to receive material from one or several processing units. Three example problems involving up to fifteen batches and six processing tasks were successfully solved. Compared with previous work, a drastic reduction in both problem size and CPU time has been achieved.}}
@ARTICLE{Aguirre_2010,title={Towards Integrated Management of the Supply Chain for Enterprise Sustainability},year={2010},author={Laínez Aguirre and Lainez Aguirre and José Miguel and José Miguel},doi={null},pmid={null},pmcid={null},mag_id={282843943},journal={null},abstract={Las tendencias del mercado han hecho que las empresas cambien su forma de hacer negocios. La Globalizacion ha permitido a las empresas tener la posibilidad de acceder a distintos proveedores y mercados globalmente dispersos. Actualmente para mantener un nivel competitivo, el mercadoreclama productos amigables con el medio ambiente, rapido desarrollo de nuevos productos, alta calidad y fiabilidad, entre otros. Para cumplir con tales requisitos, las empresas dependen cada vez mas de su Cadena de Suministros (CS). De hecho, la competencia en el mercado ya no es unicamente entre empresas, sino entre CS. La comunidad cientifica es consciente de este cambio y ha dedicado esfuerzos a la concepcion de estrategias para el modelado y optimizacion de CS. Asimismo, la industria quimica Europea reconoce necesaria la mejora de la Gestion de la Cadena de Suministros (GCS) para mantenerse competitiva en un mercado global. La GCS trata de maximizar los retornos financieros sincronizando los flujos de materiales, informacion y efectivo existentes entre las distintas entidades interconectadas con el objetivo de proveer un producto al mercado. Recientemente, tambien se reconoce la necesidad de una Gestion Integrada de la CS (GICS), la cual consiste en la sincronizacion de otras funciones del negocio y de diferentes niveles de decision. El actual entorno dinamico de los negocios y de las propias operaciones hacen dificil la coordinacion de las actividades de la CS. Por tanto, es importante que los objetivos y planes sean desarrollados considerando explicitamente la incertidumbre del mercado y de las propias tareas de fabricacion y que sean revisados periodicamente. El proposito de esta tesis es contribuir al desarrollo de estrategias para la GICS. La tesis contempla CS centralizadas, es decir, se considera que existe una entidad central que es capaz de controlar las actividades de toda la CS. Despues de una revision de conceptos y de las estrategias existentes para abordar la GICS, la tesis se enfoca en el desarrollo de modelos queincluyen decisiones de diferentes funcionalidades del negocio. Esta parte explora como mejorar el comportamiento de la CS si conjuntamente con la gestion estrategica de la CS se integran decisiones asociadas con finanzas, marketing y desarrollo de nuevos productos. A continuacion la tesis se dedica a temas puramente relacionados con la gestion estrategica y tactica de las operaciones de la CS. Se investiga como obtener una representacion mas apropiada de los procesos productivos a nivel de CS. En esta parte se considera tambien el diseno de CS considerando su impacto ambiental asociado. La cuarta parte esta dedicada a la consideracion de la incertidumbre. Para ello se propone un control predictivo que incorpora como algoritmo de control un modelo estocastico. Se muestra como las incidencias pueden resolverse de mejor manera cuando se tiene en cuenta una vision completa de la CS en la busqueda de posibles soluciones. Ademas, se desarrolla una extension del metodo para programacion de operaciones (PO) S-graph para abordar problemas con incertidumbre. Esta propuesta posee la particularidad que el tamano del espacio de busqueda no crece con el numero de escenarios considerados. Dicha caracteristica permite reducir los tiempos de solucion, lo cual es uno de los desafios en esta area. La ultima contribucion esta relacionada con la integracion de los niveles de decision. Se muestra como la capacidad es el factor clave para llevar a cabo esta integracion. Se examinan las implicaciones de considerar la PO cuando se disena una CS. En esta parte se hace hincapie en la erronea sobreestimacion de la capacidad que se obtiene cuando la PO no es incluida en el diseno de CS. Aun mas, se demuestra como la capacidad permite la integracion del modulo de control de bajo nivel con la CS por medio de la formulacion de la PO. Dicha integracion permite actualizar la capacidad real y resolver adecuadamente interrupciones y fallos en los equipos.}}
@ARTICLE{Stump_2014,title={Starexec: A cross-community infrastructure for logic solving},year={2014},author={Aaron Stump and Aaron Stump and Geoff Sutcliffe and Geoff Sutcliffe and Geoffrey Sutcliffe and Cesare Tinelli and Cesare Tinelli},doi={10.1007/978-3-319-08587-6_28},pmid={null},pmcid={null},mag_id={333834217},journal={null},abstract={We introduce StarExec, a public web-based service built to facilitate the experimental evaluation of logic solvers, broadly understood as automated tools based on formal reasoning. Examples of such tools include theorem provers, SAT and SMT solvers, constraint solvers, model checkers, and software verifiers. The service, running on a compute cluster with 380 processors and 23 terabytes of disk space, is designed to provide a single piece of storage and computing infrastructure to logic solving communities and their members. It aims at reducing duplication of effort and resources as well as enabling individual researchers or groups with no access to comparable infrastructure. StarExec allows community organizers to store, manage and make available benchmark libraries; competition organizers to run logic solver competitions; and community members to do comparative evaluations of logic solvers on public or private benchmark problems.}}
@ARTICLE{Ammann_2008,title={introduction to software testing overview},year={2008},author={Paul Ammann and Jeff Offutt},doi={10.1017/cbo9780511809163},pmid={null},pmcid={null},mag_id={997216274},journal={null},abstract={null}}
@ARTICLE{Santone_2011,title={Heuristic for Simulation Checking},year={2011},author={Antonella Santone and Antonella Santone},doi={null},pmid={null},pmcid={null},mag_id={1019559270},journal={null},abstract={Equivalence checking is a common problem in formal software design. It is the process of determining whether two systems are equivalent to each other according to some mathematically deflned notion of equivalence. In this paper to improve e‐ciency we present a procedure, based on heuristic searches, for checking the well-know simulation relation deflned by Milner. We use heuristic mechanisms for the exploration of the search space, in order to avoid the construction of the complete state graph.}}
@ARTICLE{Fernandez_1993,title={Symbolic Equivalence Checking},year={1993},author={Jean-Claude Fernandez and Jean-Claude Fernandez and Alain Kerbrat and Alain Kerbrat and Laurent Mounier and Laurent Mounier},doi={10.1007/3-540-56922-7_8},pmid={null},pmcid={null},mag_id={1481841467},journal={null},abstract={We describe the implementation, within Aldebaran of an algorithmic method allowing the generation of a minimal labeled transition system from an abstract model; this minimality is relative to an equivalence relation. The method relies on a symbolic representation of the state space. We compute the minimal labeled transition system using the Binary Decision Diagram structures to represent the set of equivalence classes. Some experiments are presented, using a model obtained from LOTOS specifications.}}
@ARTICLE{Dill_1989,title={Timing assumptions and verification of finite-state concurrent systems},year={1989},author={David L. Dill and David L. Dill},doi={10.1007/3-540-52148-8_17},pmid={null},pmcid={null},mag_id={1482233117},journal={null},abstract={We have described a scheme that allows timing assumptions to be incorporated into automatic proofs of arbitrary finite-state temporal properties. The obvious extension is to be able to prove timing properties, not just assume them. This would provide a verification framework for finite-state hard real-time systems. We conjecture that the method presented can, in fact, be extended in this way.}}
@ARTICLE{Ammann_2008,title={Introduction To Software Testing},year={2008},author={Paul Ammann and Paul Ammann and Jeff Offutt and Jeff Offutt},doi={null},pmid={null},pmcid={null},mag_id={1486172410},journal={null},abstract={Extensively class tested, this text takes an innovative approach to explaining the process of software testing: it defines testing as the process of applying a few well-defined, general-purpose test criteria to a structure or model of the software. The structure of the text directly reflects the pedagogical approach and incorporates the latest innovations in testing, including techniques to test modern types of software such as OO, web applications, and embedded software.}}
@ARTICLE{D’Argenio_2001,title={MoDeST - A Modelling and Description Language for Stochastic Timed Systems},year={2001},author={Pedro R. D’Argenio and Pedro R. D'Argenio and Pedro R. D'Argenio and Holger Hermanns and Holger Hermanns and Joost-Pieter Katoen and Joost-Pieter Katoen and Ric Klaren and Ric Klaren},doi={10.1007/3-540-44804-7_6},pmid={null},pmcid={null},mag_id={1488069027},journal={Lecture Notes in Computer Science},abstract={This paper presents a modelling language, called MoDeST, for describing the behaviour of discrete event systems. The language combines conventional programming constructs - such as iteration, alternatives, atomic statements, and exception handling - with means to describe complex systems in a compositional manner. In addition, MoDeST incorporates means to describe important phenomena such as non-determinism, probabilistic branching, and hard real-time as well as soft real-time (i.e., stochastic) aspects. The language is influenced by popular and user-friendly specification languages such as Promela, and deals with compositionality in a light-weight process-algebra style. Thus, MoDeST (i) covers a very broad spectrum of modelling concepts, (ii) possesses a rigid, process-algebra style semantics, and (iii) yet provides modern and flexible specification constructs.}}
@ARTICLE{Bohnenkamp_2003,title={The MoDeST modeling tool and its implementation},year={2003},author={Henrik Bohnenkamp and H. Bohnenkamp and Henrik C. Bohnenkamp and Holger Hermanns and Holger Hermanns and Joost-Pieter Katoen and Joost-Pieter Katoen and Ric Klaren and Ric Klaren},doi={10.1007/978-3-540-45232-4_8},pmid={null},pmcid={null},mag_id={1489504177},journal={Lecture Notes in Computer Science},abstract={This paper is about the tool-suite Motor that supports the modeling and analysis of Modest specifications. In particular, we discuss its tool architecture, and the implementation details of the tool components that do already exist, in particular, the parser, the SOS implementation, an interactive simulator, and a state-space generator. As the expressiveness of Modest goes beyond existing notations for real-time as well as probabilistic systems, the implementation of these tool components has a non-trivial intrinsic complexity.}}
@ARTICLE{Holzmann_2012,title={Parallelizing the spin model checker},year={2012},author={Gerard J. Holzmann and Gerard J. Holzmann},doi={10.1007/978-3-642-31759-0_12},pmid={null},pmcid={null},mag_id={1492584664},journal={null},abstract={We describe an extension of the Spin model checker that allows us to take advantage of the increasing number of cpu-cores available on standard desktop systems. Our main target is to speed up the verification process for safety properties, the mode used most frequently, but we also describe a small modification of the parallel search algorithm, called the piggyback algorithm, that is remarkably effective in catching violations for an interesting class of liveness properties at little cost.}}
@ARTICLE{Hong_2002,title={A Temporal Logic Based Theory of Test Coverage and Generation},year={2002},author={Henry Hong and Hyoung Seok Hong and Insup Lee and Insup Lee and Oleg Sokolsky and Oleg Sokolsky and Hasan Ural and Hasan Ural},doi={10.1007/3-540-46002-0_23},pmid={null},pmcid={null},mag_id={1495461922},journal={null},abstract={This paper presents a theory of test coverage and generation from specifications written in EFSMs. We investigate a family of coverage criteria based on the information of control flow and data flow and characterize them in the branching time temporal logic CTL. We discuss the complexity of minimal cost test generation and describe a method for automatic test generation which employs the capability of model checkers to construct counterexamples. Our approach extends the range of applications of model checking from formal verification of finite state systems to test generation from finite state systems.}}
@ARTICLE{Fernandez_1991,title={"On the Fly" Verification of Behavioural Equivalences and Preorders},year={1991},author={Jean-Claude Fernandez and Jean-Claude Fernandez and Laurent Mounier and Laurent Mounier},doi={10.1007/3-540-55179-4_18},pmid={null},pmcid={null},mag_id={1499481996},journal={null},abstract={This paper describes decision procedures for bisimulation and simulation relations between two transition systems. The algorithms proposed here do not need to previously construct them: the verification can be performed during their generation. In addition, a diagnosis is computed when the two transitions systems are not equivalent.}}
@ARTICLE{Clarke_2008,title={DESIGN AND SYNTHESIS OF SYNCHRONIZATION SKELETONS USING BRANCHING TIME TEMPORAL LOGIC},year={2008},author={Edmund M. Clarke and Edmund M. Clarke and E. Allen Emerson and E. Allen Emerson},doi={10.1007/978-3-540-69850-0_12},pmid={null},pmcid={null},mag_id={1501731334},journal={null},abstract={We Propose a method of constructing concurrent programs in which the synchronization skeletonof the program is automatically synthesized from a high-level (branching time) Temporal Logic specification. The synchronization skeleton is an abstraction of the actual program where detail irrelevant to synchronization is suppressed. For example, in the synchronization skeleton for a solution to the critical section problem each process's critical section may be viewed as a single node since the internal structure of the critical section is unimportant. Most solutions to synchronization problems in the literature are in fact given as synchronization skeletons. Because synchronization skeletons are in general finite state, the propositional version of Temporal Logic can be used to specify their properties.}}
@ARTICLE{Clarke_1993,title={Symbolic Model Checking},year={1993},author={Edmund M. Clarke and Edmund M. Clarke and Edmund M. Clarke and Kenneth L. McMillan and Kenneth L. McMillan and Sérgio Vale Aguiar Campos and Sérgio Campos and Vasiliki Hartonas-Garmhausen and Vassili Hartonas-Garmhausen},doi={null},pmid={null},pmcid={null},mag_id={1503170978},journal={null},abstract={Symbolic model checking is a powerful formal specification and verification method that has been applied successfully in several industrial designs. Using symbolic model checking techniques it is possible to verify industrial-size finite state systems. State spaces with up to 1030 states can be exhaustively searched in minutes. Models with more than 10120 states have been verified using special techniques.}}
@ARTICLE{Groote_1996,title={A Bounded Retransmission Protocol for Large Data Packets},year={1996},author={Jan Friso Groote and Jan Friso Groote and Jaco van de Pol and Jaco van de Pol},doi={10.1007/bfb0014338},pmid={null},pmcid={null},mag_id={1503762954},journal={null},abstract={A protocol is described for the transmission of large data packets over unreliable channels. The protocol splits each data packet and broadcasts it in parts. In case of failure of transmission, only a limited number of retries is allowed (bounded retransmission), hence the protocol may give up the delivery of a part of the packet. Both the sending and the receiving client are informed adequately. This protocol is used in one of Philips' products.}}
@ARTICLE{Cleaveland_1996,title={The NCSU Concurrency Workbench},year={1996},author={Rance Cleaveland and Rance Cleaveland and Steve Sims and Steve Sims},doi={10.1007/3-540-61474-5_87},pmid={null},pmcid={null},mag_id={1507985299},journal={null},abstract={The NCSU Concurrency Workbench is a tool for verifying finite-state systems. A key feature is its flexibility; its modular design eases the task of adding new analyses and changing the language users employ for describing systems. This note gives an overview of the system's features, including its capacity for generating diagnostic information for incorrect systems, and discusses some of its applications.}}
@ARTICLE{Edelkamp_2001,title={Protocol verification with heuristic search},year={2001},author={Stefan Edelkamp and Stefan Edelkamp and Alberto Lluch Lafuente and Alberto Lluch-Lafuente and Stefan Leue and Stefan Leue},doi={null},pmid={null},pmcid={null},mag_id={1509439117},journal={null},abstract={We present an approach to reconcile explicit state model checking and heuristic directed search and provide experimental evidence that the model checking problem for concurrent systems, such as communications protocols, can be solved more efficiently, since finding a state violating a property can be understood as a directed search problem. In our work we combine the expressive power and implementation efficiency of the SPIN model checker with the HSF heuristic search workbench, yielding the HSF-SPIN tool that we have implemented. We start off from the A* algorithm and some of its derivatives and define heuristics for various system properties that guide the search so that it finds error states faster. In this paper we focus on safety properties and provide heuristics for invariant and assertion violation and deadlock detection. We provide experimental results for applying HSF-SPIN to two toy protocols and one real world protocol, the CORBA GIOP protocol.}}
@ARTICLE{Baumgart_2014,title={A recipe for tool interoperability},year={2014},author={Andreas Baumgart and Andreas Baumgart and Christian Ellen and Christian Ellen},doi={10.5220/0004702203000308},pmid={null},pmcid={null},mag_id={1509976113},journal={null},abstract={Typical engineering and verification workflows for safety-relevant systems are performed with many different tools. For such workflows safety standards like the automotive ISO 26262 require traceability of all V&V-related work products. Therefore, efficient tool-integration, while ensuring all traceability needs for functional safety, is a highly relevant topic for industrial domains. Recent research projects like CESAR have addressed this topic by reusing tools and methods for different workflows in the context of requirements and systems engineering as well as verification and validation. This reuse is done in a Reference Technology Platform (RTP) with common services and a common understanding of exchanged information based on an Interoperability Specification (IOS). Recently, OSLC is discussed for such an IOS. The open question is how tools are connected efficiently and how traceability is ensured. This document provides a guideline on how to use the IOS for engineering workflows performed with different tools based on OSLC. We call it recipe. The recipe was developed in the MBAT project. It considers a systematic definition of semantic concepts for an IOS ensuring traceability and the level of granularity required to perform workflows with a set of tools.}}
@ARTICLE{Niebert_2000,title={Computing Optimal Operation Schemes for Chemical Plants in Multi-batch Mode},year={2000},author={Peter Niebert and Peter Niebert and Sergio Yovine and Sergio Yovine},doi={10.1007/3-540-46430-1_29},pmid={null},pmcid={null},mag_id={1511152484},journal={null},abstract={We propose a computer-aided methodology to automatically generate time optimal production schemes for chemical batch plants operating in multi-batch mode. Our approach is based on the following principles: (1) the plant is modeled at the level of process operations whose behavior is specified by timed automata, (2) the optimal production schemes are generated using algorithms for reachability analysis of timed automata implemented in OpenKronos, (3) the output of the verification tool is post-processed to derive high-level control code. We apply our methodology to the batch plant at the University of Dortmund. The automatically computed operation schemes turned out to be more efficient than the previously used handwritten ones.}}
@ARTICLE{Daly_2000,title={Möbius: An Extensible Tool for Performance and Dependability Modeling},year={2000},author={David Daly and David M. Daly and Daniel D. Deavours and Daniel D. Deavours and Jay M. Doyle and Jay M. Doyle and Patrick G. Webster and Patrick G. Webster and William H. Sanders and William H. Sanders},doi={10.1007/3-540-46429-8_25},pmid={null},pmcid={null},mag_id={1513249631},journal={Lecture Notes in Computer Science},abstract={Mobius is a system-level performance and dependability modeling tool. Mobius makes validation of large dependability models possible by supporting many different model solution methods as well as model specification in multiple modeling formalisms.}}
@ARTICLE{Möller_2001,title={Heuristics for Hierarchical Partitioning with Application to Model Checking},year={2001},author={M. Oliver Möller and M. Oliver Möller and M. Oliver Möller and Rajeev Alur and Rajeev Alur},doi={10.1007/3-540-44798-9_5},pmid={null},pmcid={null},mag_id={1515691539},journal={Lecture Notes in Computer Science},abstract={Given a collection of connected components, it is often desired to cluster together parts of strong correspondence, yielding a hierarchical structure. We address the automation of this process and apply heuristics to battle the combinatorial and computational complexity. We define a cost function that captures the quality of a structure relative to the connections and favors shallow structures with a low degree of branching. Finding a structure with minimal cost is NP-complete. We present a greedy polynomial-time algorithm that approximates good solutions incrementally by local evaluation of a heuristic function. We argue for a heuristic function based on four criteria: the number of enclosed connections, the number of components, the number of touched connections and the depth of the structure.

We report on an application in the context of formal verification, where our algorithm serves as a preprocessor for a temporal scaling technique, called "Next" heuristic [2]. The latter is applicable in reachability analysis and is included in a recent version of the Mocha model checking tool. We demonstrate performance and benefits of our method and use an asynchronous parity computer and an opinion poll protocol as case studies.}}
@ARTICLE{Bruns_1993,title={A Practical Technique for Process Abstraction},year={1993},author={Glenn Bruns and Glenn Bruns},doi={10.1007/3-540-57208-2_4},pmid={null},pmcid={null},mag_id={1516326834},journal={null},abstract={With algebraic laws a process can be simplified before verifying its equivalence with another process. Also needed are laws to allow a process to be simplified before verifying that it satisfies a temporal logic formula. Most previous work on this problem is based on property-preserving mappings between transition systems. The results presented here allow direct simplification of process terms for some important classes of temporal properties.}}
@ARTICLE{Bouajjani_1990,title={Minimal Model Generation},year={1990},author={Ahmed Bouajjani and Ahmed Bouajjani and Jean-Claude Fernandez and Jean-Claude Fernandez and Nicolas Halbwachs and Nicolas Halbwachs},doi={10.1007/bfb0023733},pmid={null},pmcid={null},mag_id={1517157359},journal={null},abstract={This paper adresses the problem of generating a minimal state graph from a program, without building first the whole state graph. The minimality is considered here with respect to bisimulation. A generation algorithm is presented and illustrated.}}
@ARTICLE{Zhang_2016,title={Time optimal reachability analysis using swarm verification},year={2016},author={Zhengkui Zhang and Zhengkui Zhang and Brian Nielsen and Brian Nielsen and Kim G. Larsen and Kim Guldstrand Larsen},doi={10.1145/2851613.2851828},pmid={null},pmcid={null},mag_id={1522826534},journal={null},abstract={Time optimal reachability analysis employs model-checking to compute goal states that can be reached from an initial state with a minimal accumulated time duration. The model-checker may produce a corresponding diagnostic trace which can be interpreted as a feasible schedule for many scheduling and planning problems, response time optimization etc. We propose swarm verification to accelerate time optimal reachability using the real-time model-checker U ppaal . In swarm verification, a large number of model checker instances execute in parallel on a computer cluster using different, typically randomized search strategies. We develop four swarm algorithms and evaluate them with four models in terms scalability, and time- and memory consumption. Three of these cooperate by exchanging costs of intermediate solutions to prune the search using a branch-and-bound approach. Our results show that swarm algorithms work much faster than sequential algorithms, and especially two using combinations of random-depth-first and breadth-first show very promising performance.}}
@ARTICLE{Jard_1991,title={Bounded-memory Algorithms for Verification On-the-fly},year={1991},author={Claude Jard and Claude Jard and Thierry Jéron and Thierry Jéron},doi={10.1007/3-540-55179-4_19},pmid={null},pmcid={null},mag_id={1525928754},journal={null},abstract={Program verification is a branch of computer science whose business is "to prove programs correctness". It has been studied in theoretical computer science departments for a long time but it is rarely and laboriously applied to real world problems. As a matter of fact, we must pay much more attention to practical problems like the amount of space and time needed to perform verification. Let us recall that proofs of correctness are proofs of the relative consistency between two formal specifications: those of the program, and of the properties that the program is supposed to satisfy. Such a formal proof tries to increase the confidence that a computer system will make it right when executing the program under consideration. A considerable need for such methods appeared these last ten years in different domains, such as design of asynchronous circuits, communication protocols and distributed software in general. A lot of us accepted the challenge to design automated verification tools, and many different theories have been suggested for the automated analysis of distributed systems. There now exist elaborate methods that can verify quite subtle behaviors. A simple method for performing automated verification is symbolic execution which is the core of most existing and planned verification systems. The practical limits of this method are the size of the state space and the time it may take to inspect all reachable states in this state space. Those quantities can dramatically rise with the problem size.}}
@ARTICLE{Peled_1993,title={All from One, One for All: on Model Checking Using Representatives},year={1993},author={Doron Peled and Doron Peled},doi={10.1007/3-540-56922-7_34},pmid={null},pmcid={null},mag_id={1528441743},journal={null},abstract={Checking that a given finite state program satisfies a linear temporal logic property is suffering in many cases from a severe space and time explosion. One way to cope with this is to reduce the state graph used for model checking. We define an equivalence relation between infinite sequences, based on infinite traces such that for each equivalence class, either all or none of the sequences satisfy the checked formula. We present an algorithm for constructing a state graph that contains at least one representative sequence for each equivalence class. This allows applying existing model checking algorithms to the reduced state graph rather than on the larger full state graph of the program. It also allows model checking under fairness assumptions, and exploits these assumptions to obtain smaller state graphs. A formula rewriting technique is presented to allow coarser equivalence relation among sequences, such that less representatives are needed.}}
@ARTICLE{Jee_2010,title={Automated test coverage measurement for reactor protection system software implemented in function block diagram},year={2010},author={Eunkyoung Jee and Eunkyoung Jee and Suin Kim and Suin Kim and Sungdeok Cha and Sungdeok Cha and Insup Lee and Insup Lee},doi={10.1007/978-3-642-15651-9_17},pmid={null},pmcid={null},mag_id={1528525962},journal={null},abstract={We present FBDTestMeasurer, an automated test coverage measurement tool for function block diagram (FBD) programs which are increasingly used in implementing safety critical systems such as nuclear reactor protection systems. We have defined new structural test coverage criteria for FBD programs in which dataflow-centric characteristics of FBD programs were well reflected. Given an FBD program and a set of test cases, FBDTestMeasurer produces test coverage score and uncovered test requirements with respect to the selected coverage criteria. Visual representation of uncovered data paths enables testers to easily identify which parts of the program need to be tested further. We found many aspects of the FBD logic that were not tested sufficiently when conducting a case study using test cases prepared by domain experts for reactor protection system software. Domain experts found this technique and tool highly intuitive and useful to measure the adequacy of FBD testing and generate additional test cases.}}
@ARTICLE{Behrmann_2000,title={Distributing Timed Model Checking - How the Search Order Matters},year={2000},author={Gerd Behrmann and Gerd Behrmann and Thomas Hune and Thomas Hune and Thomas Hune and Frits Vaandrager and Frits W. Vaandrager},doi={10.1007/10722167_19},pmid={null},pmcid={null},mag_id={1529559025},journal={null},abstract={In this paper we address the problem of distributing model checking of timed automata. We demonstrate through four real life examples that the combined processing and memory resources of multi-processor computers can be effectively utilized. The approach assumes a distributed memory model and is applied to both a network of workstations and a symmetric multiprocessor machine. However, certain unexpected phenomena have to be taken into account. We show how in the timed case the search order of the state space is crucial for the effectiveness and scalability of the exploration. An effective heuristic to counter the effect of the search order is provided. Some of the results open up for improvements in the single processor case.}}
@ARTICLE{Gentilini_2003,title={From Bisimulation to Simulation: Coarsest Partition Problems},year={2003},author={Raffaella Gentilini and Raffaella Gentilini and Raffaella Gentilini and Raffaella Gentilini and Carla Piazza and Carla Piazza and Alberto Policriti and Alberto Policriti},doi={10.1023/a:1027328830731},pmid={null},pmcid={null},mag_id={1543732613},journal={Journal of Automated Reasoning},abstract={The notions of bisimulation and simulation are used for graph reduction and are widely employed in many areas: modal logic, concurrency theory, set theory, formal verification, and so forth. In particular, in the context of formal verification they are used to tackle the so-called state-explosion problem. The faster algorithms to compute the maximum bisimulation on a given labeled graph are based on the crucial equivalence between maximum bisimulation and relational coarsest partition problem. As far as simulation is concerned, many algorithms have been proposed that turn out to be relatively inexpensive in terms of either time or space. In this paper we first revisit the state of the art about bisimulation and simulation, pointing out the analogies and differences between the two problems. Then, we propose a generalization of the relational coarsest partition problem, which is equivalent to the simulation problem. Finally, we present an algorithm that exploits such a characterization and improves on previously proposed algorithms for simulation.}}
@ARTICLE{Yi_1994,title={Automatic verification of real-time communicating systems by constraint-solving.},year={1994},author={Wang Yi and Wang Yi and Paul Pettersson and Paul Pettersson and Mats Daniels and Mats Daniels},doi={null},pmid={null},pmcid={null},mag_id={1546631539},journal={null},abstract={In this paper, an algebra of timed processes with real-valued clocks is presented, which serves as a formal description language for real-time communicating systems. We show that requirements such as “a process will never reach an undesired state” can be verified by solving a simple class of constraint systems on the clock-variables. A complete method for reachability analysis associated with the language is developed, and implemented as an automatic verification tool based on constraint-solving techniques. Finally as examples, we study and verify the safety-properties of Fischer’s mutual exclusion protocol and a railway crossing controller.}}
@ARTICLE{Friedler_1996,title={Combinatorially Accelerated Branch-and-Bound Method for Solving the MIP Model of Process Network Synthesis},year={1996},author={Ferenc Friedler and Ferenc Friedler and J.B. Varga and J. B. Varga and Jozsef Varga and Erika Fehér and E. Fehér and Liang‐Shih Fan and L.T. Fan},doi={10.1007/978-1-4613-3437-8_35},pmid={null},pmcid={null},mag_id={1546978002},journal={null},abstract={Process network synthesis (PNS) has enormous practical impact; however, its mixed integer programming (MIP) model is tedious to solve because it usually involves a large number of binary variables. The present work elucidates the recently proposed accelerated branch-and- bound algorithm that exploits the unique feature of the MIP model of PNS. Implementation of the algorithm is based on the so-called decision-mapping that consistently organizes the system of complex decisions. The accelerated branch-and-bound algorithm of PNS reduces both the number and size of the partial problems. The efficacy of the algorithm is demonstrated with a realistic example.}}
@ARTICLE{Grumberg_2008,title={25 Years of Model Checking: History, Achievements, Perspectives},year={2008},author={Orna Grumberg and Orna Grumberg and Helmut Veith and Helmut Veith},doi={null},pmid={null},pmcid={null},mag_id={1547246349},journal={null},abstract={Model checking technology is among the foremost applications of logic to computer science and computer engineering. The model checking community has achieved many breakthroughs, bridging the gap between theoretical computer science and hardware and software engineering, and it is reaching out to new challenging areas such as system biology and hybrid systems. Model checking is extensively used in the hardware industry and has also been applied to the verification of many types of software. Model checking has been introduced into computer science and electrical engineering curricula at universities worldwide and has become a universal tool for the analysis of systems. This Festschrift volume, published in celebration of the 25th Anniversary of Model Checking, includes a collection of 11 invited papers based on talks at the symposium "25 Years of Model Checking", 25MC, which was part of the 18th International Conference on Computer Aided Verification (CAV 2006), which in turn was part of the Federated Logic Conference (FLoC 2006) held in Seattle, WA, USA, in August 2006. Model checking is currently attracting considerable attention beyond the core technical community, and the ACM Turing Award 2007 was given in recognition of the paradigm-shifting work on this topic initiated a quarter century ago. Here we honor that achievement with the inclusion of facsimile reprints of the visionary papers on model checking by Edmund Clarke and Allen Emerson, and by Jean-Pierre Queille and Joseph Sifakis.}}
@ARTICLE{Laxsen_1995,title={diagnostic model checking for real time systems},year={1995},author={Kim G. Laxsen and Paul Pettersson and Wang Yi},doi={10.1007/bfb0020977},pmid={null},pmcid={null},mag_id={1556560989},journal={null},abstract={Uppaal is a new tool suit for automatic verification of networks of timed automata. In this paper we describe the diagnostic model-checking feature of Uppaal and illustrates its usefulness through the debugging of (a version of) the Philips Audio-Control Protocol. Together with a graphical interface of Uppaal this diagnostic feature allows for a number of errors to be more easily detected and corrected.}}
@ARTICLE{Black_2002,title={Model Checkers in Software Testing},year={2002},author={Paul E. Black and Paul E. Black and Paul Ammann and Paul Ammann and Wei Ding and Wei Ding},doi={10.1002/https://dx.doi.org/10.6028/nist.ir.6777},pmid={null},pmcid={null},mag_id={1558093988},journal={null},abstract={null}}
@ARTICLE{Bengtsson_1998,title={Partial Order Reductions for Timed Systems},year={1998},author={Johan Bengtsson and Johan Bengtsson and Bengt Jönsson and Bengt Jonsson and Johan Lilius and Johan Lilius and Wang Yi and Wang Yi},doi={10.1007/bfb0055643},pmid={null},pmcid={null},mag_id={1560730347},journal={null},abstract={In this paper, we present a partial-order reduction method for timed systems based on a local-time semantics for networks of timed automata. The main idea is to remove the implicit clock synchronization between processes in a network by letting local clocks in each process advance independently of clocks in other processes, and by requiring that two processes resynchronize their local time scales whenever they communicate. A symbolic version of this new semantics is developed in terms of predicate transformers, which enjoys the desired property that two predicate transformers are independent if they correspond to disjoint transitions in different processes. Thus we can apply standard partial order reduction techniques to the problem of checking reachability for timed systems, which avoid exploration of unnecessary interleavings of independent transitions. The price is that we must introduce extra machinery to perform the resynchronization operations on local clocks. Finally, we present a variant of DBM representation of symbolic states in the local time semantics for efficient implementation of our method.}}
@ARTICLE{Godefroid_1996,title={Partial-Order Methods for the Verification of Concurrent Systems: An Approach to the State-Explosion Problem},year={1996},author={Patrice Godefroid and Patrice Godefroid and Jan van Leeuwen and J. Van Leeuwen and Juris Hartmanis and Juris Hartmanis and Juris Hartmanis and Gerhard Goos and Gerhard Goos and Pierre Wolper and Pierre Wolper},doi={null},pmid={null},pmcid={null},mag_id={1568729458},journal={null},abstract={Concurrent systems and semantics.- Using partial orders to tackle state explosion.- Persistent sets.- Sleep sets.- Verification of safety properties.- Model checking.- Experiments.- Conclusions.}}
@ARTICLE{Pinedo_2008,title={Planning and Scheduling in Manufacturing and Services},year={2008},author={Michael Pinedo and Michael Pinedo},doi={null},pmid={null},pmcid={null},mag_id={1570584007},journal={null},abstract={Introduction.- Manufacturing Models.- Service Models.- Project Planning and Scheduling.- Machine Scheduling and Job Shop Scheduling.- Scheduling of Flexible Assembly Systems.- Economic Lot Scheduling.- Planning and Scheduling in Supply Chains.- Interval Scheduling, Reservations, and Timetabling.- Planning and Scheduling in Sports and Entertainment.- Planning, Scheduling, and Timetabling in Transportation.- Workforce Scheduling.- Systems Design and Implementation.- Advanced Concepts in Systems Design.- What Lies Ahead?- Mathematical Programming Formulations.- Exact Optimization Methods.- Heuristic Methods.- Constraint Programing Methods.- Selected Scheduuling Sytems.- The LEKIN Systems User's Guide.- Notation.- References.- Index.}}
@ARTICLE{Reffel_1999,title={Error Detection with Directed Symbolic Model Checking},year={1999},author={Frank Reffel and Frank Reffel and Stefan Edelkamp and Stefan Edelkamp},doi={10.1007/3-540-48119-2_13},pmid={null},pmcid={null},mag_id={1572955246},journal={null},abstract={In practice due to entailed memory limitations the most important problem in model checking is state space explosion. Therefore, to prove the correctness of a given design binary decision diagrams (BDDs) are widely used as a concise and symbolic state space representation. Nevertheless, BDDs are not able to avoid an exponential blow-up in general. If we restrict ourselves to find an error of a design which violates a safety property, in many cases a complete state space exploration is not necessary and the introduction of a heuristic to guide the search can help to keep both the explored part and the associated BDD representation smaller than with the classical approach.

In this paper we will show that this idea can be extended with an automatically generated heuristic and that it is applicable to a large class of designs. Since the proposed algorithm can be expressed in terms of BDDs it is even possible to use an existent model checker without any internal changes.}}
@ARTICLE{Alur_1992,title={Minimization of Timed Transition Systems},year={1992},author={Rajeev Alur and Rajeev Alur and Costas Courcoubetis and Costas Courcoubetis and Nicolas Halbwachs and Nicolas Halbwachs and David L. Dill and David L. Dill and Howard Wong-Toi and Howard Wong-Toi},doi={10.1007/bfb0084802},pmid={null},pmcid={null},mag_id={1574289075},journal={null},abstract={null}}
@ARTICLE{Fielding_2000,title={Architectural styles and the design of network-based software architectures},year={2000},author={Roy T. Fielding and Roy T. Fielding and Richard N. Taylor and Richard N. Taylor},doi={null},pmid={null},pmcid={null},mag_id={1577231857},journal={null},abstract={null}}
@ARTICLE{Clarke_2008,title={The Birth of Model Checking},year={2008},author={Edmund M. Clarke and Edmund M. Clarke},doi={10.1007/978-3-540-69850-0_1},pmid={null},pmcid={null},mag_id={1577525693},journal={null},abstract={"When the time is ripe for certain things, these things appear in different places in the manner of violets coming to light in early spring." (Wolfgang Bolyai to his son Johann in urging him to claim the invention of non- Euclidean geometry without delay [Vit88]).}}
@ARTICLE{Jeannet_1999,title={Dynamic Partitioning in Analyses of Numerical Properties},year={1999},author={Bertrand Jeannet and Bertrand Jeannet and Nicolas Halbwachs and Nicolas Halbwachs and Pascal Raymond and Pascal Raymond},doi={10.1007/3-540-48294-6_3},pmid={null},pmcid={null},mag_id={1582451030},journal={null},abstract={We apply linear relation analysis [CH78, HPR97] to the verification of declarative synchronous programs [Hal98]. In this approach, state partitioning plays an important role: on one hand the precision of the results highly depends on the fineness of the partitioning; on the other hand, a too much detailed partitioning may result in an exponential explosion of the analysis. In this paper, we propose to dynamically select a suitable partitioning according to the property to be proved.}}
@ARTICLE{Cassandras_1999,title={Introduction to Discrete Event Systems},year={1999},author={Christos G. Cassandras and Christos G. Cassandras and Stéphane Lafortune and Stéphane Lafortune},doi={null},pmid={null},pmcid={null},mag_id={1587663028},journal={null},abstract={Introduction to Discrete Event Systems is a comprehensive introduction to the field of discrete event systems, offering a breadth of coverage that makes the material accessible to readers of varied backgrounds. The book emphasizes a unified modeling framework that transcends specific application areas, linking the following topics in a coherent manner: language and automata theory, supervisory control, Petri net theory, Markov chains and queuing theory, discrete-event simulation, and concurrent estimation techniques. This edition includes recent research results pertaining to the diagnosis of discrete event systems, decentralized supervisory control, and interval-based timed automata and hybrid automata models.}}
@ARTICLE{Godefroid_2004,title={Exploring very large state spaces using genetic algorithms},year={2004},author={Patrice Godefroid and Patrice Godefroid and Sarfraz Khurshid and Sarfraz Khurshid},doi={10.1007/s10009-004-0141-1},pmid={null},pmcid={null},mag_id={1588201901},journal={null},abstract={We present a novel framework for exploring very large state spaces of concurrent reactive systems. Our framework exploits application-independent heuristics using genetic algorithms to guide a state-space search toward error states. We have implemented this framework in conjunction with VeriSoft, a tool for exploring the state spaces of software applications composed of several concurrent processes executing arbitrary code. We present experimental results obtained with several examples of programs, including a C implementation of a public-key authentication protocol. We discuss heuristics and properties of state spaces that help a genetic search detect deadlocks and assertion violations. For finding errors in very large state spaces, our experiments show that a genetic search using simple heuristics can significantly outperform random and systematic searches.}}
@ARTICLE{Clarke_1981,title={Design and Synthesis of Synchronization Skeletons Using Branching-Time Temporal Logic},year={1981},author={Edmund M. Clarke and Edmund M. Clarke and E. Allen Emerson and E. Allen Emerson},doi={10.1007/bfb0025774},pmid={null},pmcid={null},mag_id={1590315663},journal={null},abstract={We have shown that it is possible to automatically synthesize the synchronization skeleton of a concurrent program from a Temporal Logic specification. We believe that this approach may in the long run turn out to be quite practical. Since synchronization skeletons are, in general, quite small, the potentially exponential behavior of our algorithm need not be an insurmountable obstacle. Much additional research will be needed, however, to make the approach feasible in practice.}}
@ARTICLE{Mahanti_2003,title={A Framework for Searching AND/OR Graphs with Cycles},year={2003},author={Ambuj Mahanti and Ambuj Mahanti and Supriyo Ghose and Supriyo Ghose and Samir K. Sadhukhan and Samir K. Sadhukhan},doi={null},pmid={null},pmcid={null},mag_id={1593601264},journal={arXiv: Artificial Intelligence},abstract={Search in cyclic AND/OR graphs was traditionally known to be an unsolved problem. In the recent past several important studies have been reported in this domain. In this paper, we have taken a fresh look at the problem. First, a new and comprehensive theoretical framework for cyclic AND/OR graphs has been presented, which was found missing in the recent literature. Based on this framework, two best-first search algorithms, S1 and S2, have been developed. S1 does uninformed search and is a simple modification of the Bottom-up algorithm by Martelli and Montanari. S2 performs a heuristically guided search and replicates the modification in Bottom-up's successors, namely HS and AO*. Both S1 and S2 solve the problem of searching AND/OR graphs in presence of cycles. We then present a detailed analysis for the correctness and complexity results of S1 and S2, using the proposed framework. We have observed through experiments that S1 and S2 output correct results in all cases.}}
@ARTICLE{Yoo_2003,title={SLURM: Simple Linux Utility for Resource Management},year={2003},author={Andy Yoo and Andy Yoo and Morris A. Jette and Morris A. Jette and Mark Grondona and Mark Grondona},doi={10.1007/10968987_3},pmid={null},pmcid={null},mag_id={1596936080},journal={null},abstract={A new cluster resource management system called Simple Linux Utility Resource Management (SLURM) is described in this paper. SLURM, initially developed for large Linux clusters at the Lawrence Livermore National Laboratory (LLNL), is a simple cluster manager that can scale to thousands of processors. SLURM is designed to be flexible and fault-tolerant and can be ported to other clusters of different size and architecture with minimal effort. We are certain that SLURM will benefit both users and system architects by providing them with a simple, robust, and highly scalable parallel job execution environment for their cluster system.}}
@ARTICLE{Harrison_1993,title={Performance modelling of communication networks and computer architectures},year={1993},author={Peter G. Harrison and Peter G. Harrison and Niki Patel and Naresh M. Patel},doi={null},pmid={null},pmcid={null},mag_id={1598438696},journal={null},abstract={(Each chapter concludes with Exercises.) Preface. 1. Essentials of Probability Theory. Sample space, events and probability. Conditional probability. Independence. 2. Random Variables and Distributions. Probability distribution functions. Discrete random variable. Continuous random variables. Joint random variables. Conditional distributions. Independence and sums. 3. Expected Values and Moments. Expectation. Generating functions and transforms. Asymptotic properties. 4. Stochastic Processes. Random walks. Markov chains. Markov processes. Reversibility. Renewal theory. 5. Queues. Simple Markovian queues. The M/G/1 queue. The G/G/1 queue. 6. Single Class Queueing Networks. Introduction. Open queueing networks. Closed queueing networks. Mean value analysis. Performance measures for the state-dependent case. The flow equivalent server method. 7. Multi-class Queueing Networks. Service time distributions. Types of service centre. Multi-class traffic model. BCMP theorem. Properties and extensions of BCMP networks. Computational algorithms for BCMP networks. Priority disciplines. Quasi-reversibility. 8. Approximate Methods. Decomposition. Fixed point methods. Diffusion approximation. Maximum entropy methods. 9. Time Delays. Time delays in the single server queue. Time delays in networks of queues. Inversion of the Laplace transforms. Approximate methods. 10. Blocking in Queueing Networks. Introduction. Types of blocking. Two finite queues in a closed network. Aggregating Markovian states. BAS blocking. BBS blocking. Repetitive service blocking. 11. Switching Network Models. Telephone networks. Interconnection networks for parallel processing systems. Models of the full crossbar switch. Multi-stage interconnection networks. Models of synchronous MINS. Models of asynchronous MINS. Interconnection networks in a queueing model. Appendix: Outline Solutions. References. Index. 0201544199T04062001}}
@ARTICLE{Rayadurgam_2003,title={Generating MC/DC adequate test sequences through model checking},year={2003},author={Sanjai Rayadurgam and Sanjai Rayadurgam and Mats P. E. Heimdahl and Mats P. E. Heimdahl},doi={10.1109/sew.2003.1270730},pmid={null},pmcid={null},mag_id={1600161649},journal={null},abstract={We present a method for automatically generating test sequences to satisfy MC/DC like structural coverage criteria of software behavioral models specified in state-based formalisms. The use of temporal logic for characterizing test criteria and the application of model-checking techniques for generating test sequences to those criteria have been of interest in software verification research for some time. Nevertheless, criteria for which constraints span more than one test sequence, such as the modified condition/decision coverage (MC/DC) mandated for critical avionics software, cannot be characterized in terms of a single temporal property. This paper discusses a method for recasting two-sequence constraints in the original model as a single sequence constraint expressed in temporal logic on a slightly modified model. The test-sequence generated by a model-checker for the modified model can be easily separated into two different test-sequences for the original model, satisfying the given test criteria. The approach has been successful in generating MC/DC test sequences from a model of the mode-logic in a flight-guidance system.}}
@ARTICLE{Rokicki_1994,title={Representing and modeling digital circuits},year={1994},author={Tomas Rokicki and Tomas Rokicki},doi={null},pmid={null},pmcid={null},mag_id={1601699262},journal={null},abstract={A computer-aided circuit design tool can be described as a set of algorithms applied to an internal representation of a circuit design or specification in order to answer specific questions or perform certain operations. The representation directly limits the operations that can be performed as well as the accuracy of the resulting answers. This dissertation concerns the development and exploration of one such design representation and shows how it is appropriate for a wide range of circuit design tasks. Along the way, we discover some new techniques for specification, modeling, simulation, and verification of circuits. We especially consider real-time aspects of circuit behavior, and we present some significant enhancements to existing real-time verification algorithms.
We present a rich and expressive formalism, called orbital nets, that precisely describes control, timing, and data flow aspects of circuit behavior. We develop the concepts of synchronization, composition, and receptiveness for this formalism, and illustrate how it can be used to specify, model, simulate, and verify digital circuits.
We present a textual description language that provides convenient access to orbital nets through parameterization, partial evaluation, and structural and functional decomposition.
We present efficient hierarchical real-time simulation and verification algorithms. We prove the equivalence of continuous time and discrete time semantics for orbital nets, and develop some new geometric timing algorithms that exploit concurrency to efficiently verify real-time safety properties.}}
@ARTICLE{Finkel_1998,title={Fundamental Structures in Well-Structured Infinite Transition Systems},year={1998},author={Alain Finkel and Alain Finkel and Philippe Schnoebelen and Ph. Schnoebelen},doi={10.1007/bfb0054314},pmid={null},pmcid={null},mag_id={1602938474},journal={null},abstract={We suggest a simple and clean definition for Well-Structured Transition Systems [20, 1], a general class of infinite state systems for which decidability results exist. As a consequence we can (1) generalize the definition in many ways, (2) find examples of (general) WSTS's in many fields, and (3) present new decidability results.}}
@ARTICLE{Brinksma_2002,title={Verification and Optimization of a PLC Control Schedule},year={2002},author={Ed Brinksma and Ed Brinksma and Angelika Mader and Angelika Mader and Ansgar Fehnker and Ansgar Fehnker},doi={10.1007/s10009-002-0079-0},pmid={null},pmcid={null},mag_id={1605437280},journal={International Journal on Software Tools for Technology Transfer},abstract={We report on the use of model checking techniques for both the verification of a process control program and the derivation of optimal control schedules. Most of this work has been carried out as part of a case study for the EU VHS project (Verification of Hybrid Systems), in which the program for a Programmable Logic Controller (PLC) of an experimental chemical plant had to be designed and verified. The original intention of our approach was to see how much could be achieved here using the standard model checking environment of SPIN/Promela. As the symbolic calculations of real-time model checkers can be quite expensive it is interesting to try and exploit the efficiency of established non-real-time model checkers like SPIN in those cases where promising work-arounds seem to exist. In our case we handled the relevant real-time properties of the PLC controller using a time-abstraction technique; for the scheduling we implemented in Promela a so-called variable time advance procedure . To compare and interpret the results we carried out the same case study with the aid of the real-time model checker Uppaal, enhanced with facilities for cost-guided state space exploration. Both approaches proved sufficiently powerful to verify the design of the controller and/or derive (time-)optimal schedules within reasonable time and space requirements.}}
@ARTICLE{Asarin_1998,title={Controller Synthesis for Timed Automata 1},year={1998},author={Eugène Asarin and Eugene Asarin and Oded Maler and Oded Maler and Amir Pnueli and Amir Pnueli and Joseph Sifakis and Joseph Sifakis},doi={10.1016/s1474-6670(17)42032-5},pmid={null},pmcid={null},mag_id={1606824214},journal={IFAC Proceedings Volumes},abstract={Abstract   In this work we tackle the following problem: given a timed automaton, restrict its transition relation in a systematic way so that all the remaining behaviors satisfy certain properties. This is an extension of the problem of controller synthesis for discrete event dynamical systems, where in addition to choosing among actions, the controller have the option of doing nothing and let the time pass. The problem is formulated using the notion of a real-time game, and a winning strategy is constructed as a fixed-point of an operator on the space of states and clock configurations.}}
@ARTICLE{Kilby_2006,title={Chapter 23 - Vehicle Routing},year={2006},author={Philip Kilby and Philip Kilby and Paul Shaw and Paul Shaw},doi={10.1016/s1574-6526(06)80027-1},pmid={null},pmcid={null},mag_id={1607880291},journal={null},abstract={null}}
@ARTICLE{Groce_2002,title={Heuristic Model Checking for Java Programs},year={2002},author={Alex Groce and Alex Groce and Willem Visser and Willem Visser},doi={10.1007/3-540-46017-9_21},pmid={null},pmcid={null},mag_id={1608367582},journal={null},abstract={Two recent areas of interest in software model checking are checking programs written in standard programming languages [1],[5] and using heuristics to guide the exploration of an explicit-state model checker [3]. Model checking real programs has the drawback that programs often contain a larger degree of detail than designs and hence are more dificult to check (due to the more acute stateexplosion problem); however the large amount of detail in a program allows more precise heuristics for narrowing down the search space when using a model checker for error-detection. This paper describes the addition of support for heuristic (or directed) search strategies to Java PathFinder (JPF), an explicit state model checker for Java bytecode that uses a custom-made Java Virtual Machine (JVM) [5].}}
@ARTICLE{Lind-Nielsen_2001,title={Verification of Large State/Event Systems Using Compositionality and Dependency Analysis},year={2001},author={Jørn Lind-Nielsen and Jørn Lind-Nielsen and Henrik Reif Andersen and Henrik Reif Andersen and Henrik Hulgaard and Henrik Hulgaard and Henrik Hulgaard and Gerd Behrmann and Gerd Behrmann and K. Kristoffersen and Kåre J. Kristoffersen and Kim Guldstrand Larsen and Kim Guldstrand Larsen},doi={10.1023/a:1008736219484},pmid={null},pmcid={null},mag_id={1625256512},journal={null},abstract={A state/event model is a concurrent version of Mealy machines used for describing embedded reactive systems. This paper introduces a technique that uses compositionality and dependency analysis to significantly improve the efficiency of symbolic model checking of state/event models. It makes possible automated verification of large industrial designs with the use of only modest resources (less than 5 minutes on a standard PC for a model with 1421 concurrent machines). The results of the paper are being implemented in the next version of the commercial tool visualSTATETM.}}
@ARTICLE{Lakehal_2005,title={Lustructu: a tool for the automatic coverage assessment of Lustre programs},year={2005},author={Abdesselam Lakehal and Abdesselam Lakehal and Ioannis Parissis and Ioannis Parissis},doi={10.1109/issre.2005.26},pmid={null},pmcid={null},mag_id={1644732418},journal={null},abstract={We present Lustructu, a tool measuring the structural coverage of LUSTRE programs. LUSTRE is a synchronous data-flow declarative language widely used for safety-critical applications (avionics, energy, transport...). Many coverage criteria are defined for sequential languages and are widely used in the software industry (for instance, statement or branch coverage). They are defined on the program control-flow graph and, hence, do not apply to LUSTRE programs, represented by data-flow diagrams. We have defined several criteria to measure the coverage achieved after the execution of a test set, based on symbolic computation of path activation conditions. These criteria, implemented in Lustructu, provide the user with meaningful automatically computed measures of the thoroughness of a given test set}}
@ARTICLE{Pearl_1984,title={Heuristics : intelligent search strategies for computer problem solving},year={1984},author={Judea Pearl and Judea Pearl},doi={null},pmid={null},pmcid={null},mag_id={1646038686},journal={null},abstract={null}}
@ARTICLE{Huth_2000,title={Logic in Computer Science: Modelling and Reasoning about Systems},year={2000},author={Michael Huth and Michael Huth and Mark Ryan and Mark Ryan},doi={10.1017/cbo9780511810275},pmid={null},pmcid={null},mag_id={1679534293},journal={null},abstract={From the Publisher:
Provides a simple and clear presentation, covering propositional and predicate logic and some specialized logics used for reasoning about the correctness of computer systems.}}
@ARTICLE{Bouyer_2004,title={Optimal strategies in priced timed game automata},year={2004},author={Patricia Bouyer and Patricia Bouyer and Franck Cassez and Franck Cassez and Emmanuel Fleury and Emmanuel Fleury and Kim G. Larsen and Kim Guldstrand Larsen},doi={10.1007/978-3-540-30538-5_13},pmid={null},pmcid={null},mag_id={1710659396},journal={null},abstract={Priced timed (game) automata extend timed (game) automata with costs on both locations and transitions. In this paper we focus on reachability priced timed game automata and prove that the optimal cost for winning such a game is computable under conditions concerning the non-zenoness of cost. Under stronger conditions (strictness of constraints) we prove that in case an optimal strategy exists, we can compute a state-based winning optimal strategy.}}
@ARTICLE{Khurshid_2003,title={Generalized symbolic execution for model checking and testing},year={2003},author={Sarfraz Khurshid and Sarfraz Khurshid and Corina S. Pǎsǎreanu and Corina S. Păsăreanu and Corina S. Păsăreanu and Willem Visser and Willem Visser},doi={10.1007/3-540-36577-x_40},pmid={null},pmcid={null},mag_id={1720848645},journal={null},abstract={Modern software systems, which often are concurrent and manipulate complex data structures must be extremely reliable. We present a novel framework based on symbolic execution, for automated checking of such systems. We provide a two-fold generalization of traditional symbolic execution based approaches. First, we define a source to source translation to instrument a program, which enables standard model checkers to perform symbolic execution of the program. Second, we give a novel symbolic execution algorithm that handles dynamically allocated structures (e.g., lists and trees), method preconditions (e.g., acyclicity), data (e.g., integers and strings) and concurrency. The program instrumentation enables a model checker to automatically explore different program heap configurations and manipulate logical formulae on program data (using a decision procedure). We illustrate two applications of our framework: checking correctness of multi-threaded programs that take inputs from unbounded domains with complex structure and generation of non-isomorphic test inputs that satisfy a testing criterion. Our implementation for Java uses the Java PathFinder model checker.}}
@ARTICLE{Madelaine_1990,title={Finiteness Conditions and Structural Construction of Automata for All Process Algebras},year={1990},author={Eric Madelaine and Eric Madelaine and Didier Vergamini and Didier Vergamini},doi={10.1007/bfb0023749},pmid={null},pmcid={null},mag_id={1820239421},journal={null},abstract={Finite automata are the basis of many verification methods and tools for process algebras. It is however undecidable in most process algebras whether the semantics of a given term is finite. We give sufficient finiteness conditions derived from the analysis of the operational rules of the algebra operators. From these rules we also generate the functions that compute automata from terms of the algebra. These constructions allow one to use our verification tools for programs written in many process algebras.}}
@ARTICLE{Edelkamp_1998,title={OBDDs in Heuristic Search},year={1998},author={Stefan Edelkamp and Stefan Edelkamp and Frank Reffel and Frank Reffel},doi={10.1007/bfb0095430},pmid={null},pmcid={null},mag_id={1822932058},journal={Lecture Notes in Computer Science},abstract={The use of a lower bound estimate in the search has a tremendous impact on the size of the resulting search trees, whereas OBDDs can be used to efficiently describe sets of states based on their binary encoding. This paper combines these two ideas into a new algorithm BDDA *. It challenges both the breadth-first search using OBDDs and the traditional A * algorithm. The problem with A * is that in many application areas the set of states is too huge to be kept in main memory. In contrast, brute-force breadth-first search using OBDDs unnecessarily expands several nodes. Therefore, we exhibit a new trade-off between time and space requirements and tackle the most important problem in heuristic search, the overcoming of space limitations while avoiding a strong penalty in time. We evaluate our approach in the (n 2−1)-Puzzle and within Sokoban.}}
@ARTICLE{Havelund_1996,title={Experiments in Theorem Proving and Model Checking for Protocol Verification},year={1996},author={Klaus Havelund and Klaus Havelund and Natarajan Shankar and Natarajan Shankar},doi={10.1007/3-540-60973-3_113},pmid={null},pmcid={null},mag_id={1825148885},journal={null},abstract={Communication protocols pose interesting and difficult challenges for verification technologies. The state spaces of interesting protocols are either infinite or too large for finite-state verification techniques like model checking and state exploration. Theorem proving is also not effective since the formal correctness proofs of these protocols can be long and complicated. We describe a series of protocol verification experiments culminating in a methodology where theorem proving is used to abstract out the sources of unboundedness in the protocol to yield a skeletal protocol that can be verified using model checking.}}
@ARTICLE{Lundqvist_1999,title={A Formal Model of the Ada Ravenscar Tasking Profile; Protected Objects},year={1999},author={Kristina Lundqvist and Kristina Lundqvist and Lars Asplund and Lars Asplund and Stephen Α. Mitchell and Stephen G. Mitchell},doi={10.1007/3-540-48753-0_2},pmid={null},pmcid={null},mag_id={1845105723},journal={null},abstract={The definition of the Ravenscar Tasking Profile for Ada95 provides a definition of a tasking runtime system with deterministic behaviour and low enough complexity to permit a formal description of the model. The complete model of the Protected Object portion of the Ravenscar Model is presented in Uppaal. Some important properties are verified such as timing of calls to protected procedure. This is the first time a part of an Ada run-time has been formally verified.}}
@ARTICLE{Behrmann_1999,title={Efficient Timed Reachability Analysis Using Clock Difference Diagrams},year={1999},author={Gerd Behrmann and Gerd Behrmann and Kim Guldstrand Larsen and Kim Guldstrand Larsen and Justin Pearson and Justin Pearson and Carsten Weise and Carsten Weise and Carsten Weise and Wang Yi and Wang Yi},doi={10.1007/3-540-48683-6_30},pmid={null},pmcid={null},mag_id={1874996599},journal={null},abstract={One of the major problems in applying automatic verification tools to industrial-size systems is the excessive amount of memory required during the state-space exploration of a model. In the setting of real-time, this problem of state-explosion requires extra attention as information must be kept not only on the discrete control structure but also on the values of continuous clock variables.

In this paper, we exploit Clock Difference Diagrams, CDD's, a BDD-like data-structure for representing and effectively manipulating certain nonconvex subsets of the Euclidean space, notably those encountered during verification of timed automata.

A version of the real-time verification tool Uppaal using CDD's as a compact data-structure for storing explored symbolic states has been implemented. Our experimental results demonstrate significant spacesavings: for eight industrial examples, the savings are in average 42% with moderate increase in runtime.

We further report on how the symbolic state-space exploration itself may be carried out using CDD's.}}
@ARTICLE{Gibson−Robinson_2014,title={FDR3 — A Modern Refinement Checker for CSP},year={2014},author={Thomas Gibson−Robinson and Thomas Gibson-Robinson and Philip Armstrong and Philip Armstrong and Alexandre Boulgakov and Alexandre Boulgakov and A. W. Roscoe and A. W. Roscoe},doi={10.1007/978-3-642-54862-8_13},pmid={null},pmcid={null},mag_id={1882160752},journal={null},abstract={FDR3 is a complete rewrite of the CSP refinement checker FDR2, incorporating a significant number of enhancements. In this paper we describe the operation of FDR3 at a high level and then give a detailed description of several of its more important innovations. This includes the new multi-core refinement-checking algorithm that is able to achieve a near linear speed up as the number of cores increase. Further, we describe the new algorithm that FDR3 uses to construct its internal representation of CSP processes—this algorithm is more efficient than FDR2’s, and is able to compile a large class of CSP processes to more efficient internal representations. We also present experimental results that compare FDR3 to related tools, which show it is unique (as far as we know) in being able to scale beyond the bounds of main memory.}}
@ARTICLE{Hune_2001,title={Guided synthesis of control programs using UPPAAL},year={2001},author={Thomas Hune and Thomas Hune and Kim G. Larsen and Kim Guldstrand Larsen and Paul Pettersson and Paul Pettersson},doi={null},pmid={null},pmcid={null},mag_id={1886297056},journal={Nordic Journal of Computing},abstract={In this paper we address the problem of scheduling and synthesizing distributed control programs for a batch production plant. We use a timed automata model of the batch plant and the verification tool UPPAAL to solve the scheduling problem.In modeling the plant, we aim at a level of abstraction which is sufficiently accurate in order that synthesis of control programs from generated timed traces is possible. Consequently, the models quickly become too detailed and complicated for immediate automatic synthesis. In fact, only models of plants producing two batches can be analyzed directly! To overcome this problem, we present a general method allowing the user to guide the model-checker according to heuristically chosen strategies. The guidance is specified by augmenting the model with additional guidance variables and by decorating transitions with extra guards on these. Applying this method have made synthesis of control programs feasible for a plant producing as many as 60 batches.The synthesized control programs have been executed in a physical plant. Besides proving useful in validating the plant model and in finding some modeling errors, we view this final step as the ultimate litmus test of our methodology's ability to generate executable (and executing) code from basic plant models.}}
@ARTICLE{Hessel_2003,title={Time-Optimal Real-Time Test Case Generation Using Uppaal},year={2003},author={Anders Hessel and Anders Hessel and Kim Guldstrand Larsen and Kim Guldstrand Larsen and Brian Nielsen and Brian Nielsen and Paul Pettersson and Paul Pettersson and Arne Skou and Arne Skou},doi={10.1007/978-3-540-24617-6_9},pmid={null},pmcid={null},mag_id={1895974704},journal={null},abstract={Testing is the primary software validation technique used by industry today, but remains ad hoc, error prone, and very expensive. A promising improvement is to automatically generate test cases from formal models of the system under test.}}
@ARTICLE{Valmari_1990,title={A Stubborn Attack On State Explosion},year={1990},author={Antti Valmari and Antti Valmari},doi={10.1007/bf00709154},pmid={null},pmcid={null},mag_id={1934074768},journal={null},abstract={The paper presents the LTL preserving stubborn set method for reducing the amount of work needed in the automatic verification of concurrent systems with respect to linear time temporal logic specifications. The method facilitates the generation of reduced state spaces such that the truth values of a collection of linear temporal logic formulas are the same in the ordinary and reduced state spaces. The only restrictions posed by the method are that the collection of formulas must be known before the reduced state space generation is commenced, the use of the temporal operator “next” is prohibited, and the (reduced) state space of the system must be finite. The method cuts down the number of states by utilising the fact that in concurrent systems the nett result of the occurrence of two events is often independent of the order of occurrence.}}
@ARTICLE{Larsen_1999,title={Clock difference diagrams},year={1999},author={Kim Guldstrand Larsen and Kim Guldstrand Larsen and Justin Pearson and Justin Pearson and Carsten Weise and Carsten Weise and Carsten Weise and Wang Yi and Wang Yi},doi={null},pmid={null},pmcid={null},mag_id={1939356072},journal={Nordic Journal of Computing},abstract={In this paper, we present Clock Difference Diagrams (CDD), a new BDD-like data-structure for effective representation and manipulation of certain non-convex subsets of the Euclidean space, notably those encountered in verification of timed automata. It is shown that all set-theoretic operations including inclusion checking may be carried out efficiently on Clock Difference Diagrams. Other clock operations needed for fully symbolic analysis of timed automata e.g. future- and reset-operations, can be obtained based on a so-called tight normalform for CDD. A version of the real-time verification tool UPPAAL using Clock Difference Diagrams as the main data-structure has been implemented. Experimental results demonstrate significant space-savings: for nine industrial examples the savings are in average 42% with moderate increase in runtime.}}
@ARTICLE{Holzmann_2011,title={The SPIN Model Checker: Primer and Reference Manual},year={2011},author={Gerard J. Holzmann and Gerard J. Holzmann},doi={null},pmid={null},pmcid={null},mag_id={1943502734},journal={null},abstract={The SPIN Model Checker is used for both teaching software verification techniques, and for validating large scale applications. The growing number of users has created a need for a more comprehensive user guide and a standard reference manual that describes the most recent version of the tool. This book fills that need. SPIN is used in over 40 countries. The offical SPIN web site, spinroot.com receives between 2500 and 3000 hits per day. It has been estimated that up to three-quarters of the $400 billion spent annually to hire programmers in the United States is ultimately spent on debugging}}
@ARTICLE{Behrmann_2004,title={A Tutorial on UPPAAL},year={2004},author={Gerd Behrmann and Gerd Behrmann and Albert David and Alexandre David and Kim Guldstrand Larsen and Kim Guldstrand Larsen},doi={10.1007/978-3-540-30080-9_7},pmid={null},pmcid={null},mag_id={1962072139},journal={null},abstract={This is a tutorial paper on the tool Uppaal. Its goal is to
be a short introduction on the flavor of timed automata implemented in
the tool, to present its interface, and to explain how to use the tool. The
contribution of the paper is to provide reference examples and modeling
patterns.}}
@ARTICLE{Finkel_2001,title={Well-structured transition systems everywhere!},year={2001},author={Alain Finkel and Alain Finkel and Philippe Schnoebelen and Ph. Schnoebelen},doi={10.1016/s0304-3975(00)00102-x},pmid={null},pmcid={null},mag_id={1967174286},journal={Theoretical Computer Science},abstract={null}}
@ARTICLE{Hélias_2008,title={Using timed automata and model-checking to simulate material flow in agricultural production systems-Application to animal waste management},year={2008},author={Arnaud Hélias and Arnaud Hélias and F Guerrin and François Guerrin and Jean‐Philippe Steyer and Jean-Philippe Steyer},doi={10.1016/j.compag.2008.02.008},pmid={null},pmcid={null},mag_id={1967516313},journal={Computers and Electronics in Agriculture},abstract={null}}
@ARTICLE{Thieme_2002,title={Model-based generation of modular PLC code using IEC61131 function blocks},year={2002},author={Jan Thieme and J. Thieme and Hans-Michael Hanisch and Hans-Michael Hanisch},doi={10.1109/isie.2002.1026065},pmid={null},pmcid={null},mag_id={1967946892},journal={null},abstract={Mathematical models and formal methods can be used for verifying/falsifying a discrete event controller just before it is put into operation. If the controller model is verified successfully, one has to translate it into an executable implementation. The complexity of technical systems requires a systematic design of needed models. Usually, modular and hierarchically structured models are the results of such a model design. It makes sense to keep the module structures of the controller model within its implementation. After a short introduction the paper illustrates an appropriate modeling formalism and suitable methods for automatic generation of modular control code for programmable logic controllers (PLC) using IEC61131 function blocks.}}
@ARTICLE{Hart_1968,title={A Formal Basis for the Heuristic Determination of Minimum Cost Paths},year={1968},author={P. D’Arcy Hart and Peter E. Hart and Nils J. Nilsson and Nils J. Nilsson and Benny Raphael and Bertram Raphael},doi={10.1109/tssc.1968.300136},pmid={null},pmcid={null},mag_id={1969483458},journal={IEEE Transactions on Systems Science and Cybernetics},abstract={Although the problem of determining the minimum cost path through a graph arises naturally in a number of interesting applications, there has been no underlying theory to guide the development of efficient search procedures. Moreover, there is no adequate conceptual framework within which the various ad hoc search strategies proposed to date can be compared. This paper describes how heuristic information from the problem domain can be incorporated into a formal mathematical theory of graph searching and demonstrates an optimality property of a class of search strategies.}}
@ARTICLE{Lundqvist_1999,title={A formal model of the Ada Ravenscar tasking profile; delay until},year={1999},author={Kristina Lundqvist and Kristina Lundqvist and Lars Asplund and Lars Asplund},doi={10.1145/319295.319298},pmid={null},pmcid={null},mag_id={1972809754},journal={ACM Sigada Ada Letters},abstract={The definition of the Ravenscar Tasking Profile for Ada 95 provides a definition of a tasking runtime system with deterministic behaviour and low enough complexity to permit a formal description and verification of the model. A complete run-time system is being modeled using the real-time model checker U PPAAL , and this work describes the handling of delay until. Since scheduling is not yet modelled a simple non-preemptive scheduler has been used when verifying the delay queue.}}
@ARTICLE{Fernandez_1990,title={An implementation of an efficient algorithm for bisimulation equivalence},year={1990},author={Jean-Claude Fernandez and J.-C. Fernandez},doi={10.1016/0167-6423(90)90071-k},pmid={null},pmcid={null},mag_id={1973642705},journal={Science of Computer Programming},abstract={null}}
@ARTICLE{Sanmartí_2002,title={Combinatorial framework for effective scheduling of multipurpose batch plants},year={2002},author={Eduard Sanmartí and Eduard Sanmartí and Luís Puigjaner and L. Puigjaner and Tibor Holczinger and Tibor Holczinger and Ferenc Friedler and Ferenc Friedler},doi={10.1002/aic.690481115},pmid={null},pmcid={null},mag_id={1974041901},journal={Aiche Journal},abstract={The production scheduling of multipurpose batch plants is considered. A novel graph representation that looks at the specific characteristics of production scheduling in chemical processes is proposed. In these graphs, the nodes represent the production tasks, the arcs of the precedence relationships among them. The representation is flexible enough to consider a wide variety of production structures, including complex recipes. Both nonintermediate storage (NIS) and unlimited intermediate storage (UIS) transfer policies can be considered simply by choosing the appropriate precedence relationships. This representation provides the opportunity of incorporating highly efficient graph algorithms together with an appropriate branch-and-bound algorithm for solving multipurpose scheduling problems. The efficiency of the proposed method is established by solving examples and a complex case study.}}
@ARTICLE{Călinescu_2012,title={Self-adaptive software needs quantitative verification at runtime},year={2012},author={Radu Călinescu and Radu Calinescu and Carlo Ghezzi and Carlo Ghezzi and Marta Kwiatkowska and Marta Kwiatkowska and Raffaela Mirandola and Raffaela Mirandola},doi={10.1145/2330667.2330686},pmid={null},pmcid={null},mag_id={1974641445},journal={Communications of The ACM},abstract={Continually verify self-adaptation decisions taken by critical software in response to changes in the operating environment.}}
@ARTICLE{Holzmann_2001,title={Software model checking: extracting verification models from source code*},year={2001},author={Gerard J. Holzmann and Gerard J. Holzmann and Margaret Smith and Margaret H. Smith},doi={10.1002/stvr.228},pmid={null},pmcid={null},mag_id={1974940962},journal={Software Testing, Verification & Reliability},abstract={SUMMARY To formally verify a large software application, the standard method is to invest a considerable amount of time and expertise into the manual construction of an abstract model, which is then analysed for its properties by either a mechanized or a human prover. There are two problems with this approach. The first problem is that this verification method can be no more reliable than the humans that perform the manual steps. If the average rate of error for human work is a function of the problem size, this holds not only for the construction of the original application, but also for the construction of the model. The standard verification trajectory therefore tends to become less reliable for larger applications. The second problem is one of timing and relevance. Software applications built by teams of programmers can change rapidly, often daily. Manually constructing an accurate abstraction of any one version of the application, though, can take weeks, which may jeopardize the validity of the results. In this paper a different verification method that avoids these problems is discussed. This method, which may be the precursor of a new class of testing techniques, was originally developed to allow for a thorough testing of parts of the software of a new commercial telephone switch. Here it is argued, though, that the method also has broad applicability to distributed software systems design in general.}}
@ARTICLE{Ferrer-Nadal_2008,title={Material Transfer Operations in Batch Scheduling. A Critical Modeling Issue},year={2008},author={Sergio Ferrer-Nadal and Sergio Ferrer-Nadal and Elisabet Capón-García and Elisabet Capón-García and Elisabet Capón-García and Carlos A. Méndez and Carlos A. Méndez and Carlos A. Méndez and Luís Puigjaner and Luis Puigjaner},doi={10.1021/ie800075u},pmid={null},pmcid={null},mag_id={1979773960},journal={Industrial & Engineering Chemistry Research},abstract={An effective short-term scheduling formulation must simultaneously deal with several problem difficulties commonly arising in batch processes operations. One of the key features to be considered is the representation of the material transfer operations between process stages. A nonzero time as well as certain conditions and resources are always required to move the material from one processing stage to the next one according to the specified product recipe. The transfer task consumes a period of time during which a proper synchronization of the equipment units supplying and receiving the material is enforced. Synchronization implies that during the execution of the transfer task, one unit will be supplying the material whereas the other one will be receiving it and consequently, no other task can be simultaneously performed in both units. Most of the existing mixed-integer linear programming (MILP) optimization approaches have traditionally dealt with the batch scheduling problem assuming zero transfer ti...}}
@ARTICLE{Garavel_2011,title={CADP 2010: a toolbox for the construction and analysis of distributed processes},year={2011},author={Hubert Garavel and Hubert Garavel and Frédéric Lang and Frédéric Lang and Radu Mateescu and Radu Mateescu and Wendelin Serwe and Wendelin Serwe and Wendelin Serwe and Wendelin Serwe},doi={10.1007/978-3-642-19835-9_33},pmid={null},pmcid={null},mag_id={1980824962},journal={null},abstract={Cadp (Construction and Analysis of Distributed Processes) is a comprehensive software toolbox that implements the results of concurrency theory. Started in the mid 80s, CADP has been continuously developed by adding new tools and enhancing existing ones. Today, CADP benefits from a worldwide user community, both in academia and industry. This paper presents the latest release CADP 2010, which is the result of a considerable development effort spanning the last four years. The paper first describes the theoretical principles and the modular architecture of CADP, which has inspired several other recent model checkers. The paper then reviews the main features of CADP 2010, including compilers for various formal specification languages, equivalence checkers, model checkers, performance evaluation tools, and parallel verification tools running on clusters and grids.}}
@ARTICLE{Jensen_2002,title={SetA*: an efficient BDD-based heuristic search algorithm},year={2002},author={Rune Møller Jensen and Rune Møller Jensen and Randal E. Bryant and Randal E. Bryant and Manuela Veloso and Manuela Veloso},doi={null},pmid={null},pmcid={null},mag_id={1983019803},journal={null},abstract={In this paper we combine the goal directed search of A* with the ability of BDDs to traverse an exponential number of states in polynomial time. We introduce a new algorithm, SetA*, that generalizes A* to expand sets of states in each iteration. SetA* has substantial advantages over BDDA*, the only previous BDD-based A* implementation we are aware of. Our experimental evaluation proves SetA* to be a powerful search paradigm. For some of the studied problems it outperforms BDDA*, A*, and BDD-based breadth-first search by several orders of magnitude. We believe exploring sets of states to be essential when the heuristic function is weak. For problems with strong heuristics, SetA* efficiently specializes to single-state search and consequently challenges single-state heuristic search in general.}}
@ARTICLE{Graf_1996,title={Compositional minimisation of finite state systems using interface specifications},year={1996},author={Susanne Graf and Susanne Graf and Bernhard Steffen and Bernhard Steffen and Gerald Lüttgen and Gerald Lüttgen and Gerald Lüttgen},doi={10.1007/bf01211911},pmid={null},pmcid={null},mag_id={1987298286},journal={Formal Aspects of Computing},abstract={We present a method for thecompositional construction of theminimal transition system that represents the semantics of a given distributed system. Our aim is to control thestate explosion caused by the interleavings of actions of communicating parallel components byreduction steps that exploitglobal communication constraints given in terms ofinterface specifications. Theeffect of the method, which is developed forbisimulation semantics here, depends on the structure of the distributed system under consideration, and theaccuracy of the interface specifications. However, itscorrectness is independent of the correctness of the interface specifications provided by the program designer.}}
@ARTICLE{Stirling_1991,title={Local model checking in the modal mu-calculus},year={1991},author={Colin Stirling and Colin Stirling and David Walker and David Walker},doi={10.1016/0304-3975(90)90110-4},pmid={null},pmcid={null},mag_id={1992582873},journal={null},abstract={The modal mu-calculus, due to Prat t and Kozen [Pr, Ko], is a natural extension of dynamic logic. It is also one method of obtaining a branching time temporal logic from a modal logic [EL]. Furthermore, it extends Hennessy-Milner logic, thereby offering a natural temporal logic for Milner's CCS, and process systems in general. (Discussion of the uses of the mu-calculus for CCS can be found in [GS,Ho,La,St,Sti2].) Within this context we are especially interested in whether or not a particular state, or process, in a finite model satisfies a mu-calculus formula. This is a different enterprise from that addressed by Emerson and Lei [EL] who ask if a given formula is satisfiable in a given finite model. Their model checker appeals to standard approximation techniques for computing the set of states which satisfy a fixpoint formula. But then one has to compute all the states or processes in the model which satisfy that formula. In this paper we present a local model checker for the mu-calculus, as a tableau system. It checks whether or not a particular state satisfies a formula. Instead of using approximation techniques there is an implicit use of fixpoint induction (inspired by [La]). A maximal fixpoint formula, in effect, expresses a safety property. One shows that the assumption that a state has such a property leads to no unforeseen consequences. In contrast, a minimal fixpoint formula expresses a liveness property. Therefore one has to establish that the property holds of a particular state. Formulae involving alternating fixpoints [EL] introduce subtleties. However the resulting tableau system is natural and an equivalent version of it has been implemented by Rance Cleaveland [C1]. In section 2 we describe the syntax and semantics of the modal mu-calculus. A small extension to the calculus, the addition of propositional constants, is detailed in section 3. The model checker, presented as a tableau system, is given in section 4, while the proofs of its soundness, completeness and decidability are the topic of section 6. Finally, in section 5 we use the model checker to analyse a mutual exclusion algorithm when translated into CCS.}}
@ARTICLE{Francesco_1998,title={State space reduction by non-standard semantics for deadlock analysis},year={1998},author={Nicoletta De Francesco and Nicoletta De Francesco and Antonella Santone and Antonella Santone and Gigliola Vaglini and Gigliola Vaglini},doi={10.1016/s0167-6423(97)00017-8},pmid={null},pmcid={null},mag_id={1993668481},journal={Science of Computer Programming},abstract={null}}
@ARTICLE{Efron_2001,title={An introduction to the bootstrap},year={2001},author={Bradley Efron and Bradley Efron and Roger W. Johnson and Robert Tibshirani and Robert Tibshirani},doi={10.1111/1467-9639.00050},pmid={null},pmcid={null},mag_id={1995945562},journal={Teaching Statistics},abstract={This article presents bootstrap methods for estimation, using simple arguments. Minitab macros for implementing these methods are given.}}
@ARTICLE{Friedler_1992,title={Graph-theoretic approach to process synthesis: axioms and theorems},year={1992},author={Ferenc Friedler and Ferenc Friedler and K. Tarján and K. Tarjan and Yue Huang and Y.W. Huang and L. T. Fan and L.T. Fan},doi={10.1016/0009-2509(92)80315-4},pmid={null},pmcid={null},mag_id={1997995643},journal={Chemical Engineering Science},abstract={null}}
@ARTICLE{Santone_2013,title={Incremental construction of systems: An efficient characterization of the lacking sub-system},year={2013},author={Antonella Santone and Antonella Santone and Gigliola Vaglini and Gigliola Vaglini and Maria Luisa Villani and Maria Luisa Villani},doi={10.1016/j.scico.2012.07.015},pmid={null},pmcid={null},mag_id={1999788023},journal={Science of Computer Programming},abstract={Abstract   Software engineering research is driven by the aim of making software development more dynamic, flexible and evolvable. Nowadays the emphasis is on the evolution of pre-existing sub-systems and component and service-based development, where often only a part of the system is totally under control of the designer, most components being remotely operated by external vendors. In this context, we tackle the following problem: given the formal specification of the (incomplete) system, say it    p   , already built, how to characterize collaborators of    p    to be selected, based on a given communication interface    L   , so that a given property    φ    is satisfied. Using properties described by temporal logic formulae and systems by CCS processes, if    φ    is the formula to be satisfied by the complete system, an efficient and automatic procedure is defined to identify a formula    ψ    such that, for each existing process    q    satisfying    ψ   , the process     (  p  ∣  q  )   ∖  L    satisfies    φ   . Important features of this result are simplicity of the derived property    ψ   , compared to the original one, and scalability of the verification process. Such characteristics are necessary for applying the method to both incremental design and system evolution scenarios where    p    is already in place, and one needs to understand the specification of the functionality of the new component that should correctly interact with    p   . Indeed, in general, finding a suitable partner for    p    is easier than finding a complete system satisfying the global property. Moreover, in this paper it is shown how    ψ    can be used also to select a set of possible candidate processes    q    through a property-directed and structural heuristic. From the verification point of view, the description of the lacking component through a logic formula guarantees correctness of the integration with    p    of any process that exhibits a behaviour compliant with the inferred formula.}}
@ARTICLE{Cassez_2006,title={Structural Translation from Time Petri Nets to Timed Automata},year={2006},author={Franck Cassez and Franck Cassez and Olivier H. Roux and Olivier Roux},doi={10.1016/j.jss.2005.12.021},pmid={null},pmcid={null},mag_id={2000518871},journal={Journal of Systems and Software},abstract={Abstract   In this paper, we consider Time Petri Nets (TPN) where time is associated with transitions. We give a formal semantics for TPNs in terms of Timed Transition Systems. Then, we propose a translation from TPNs to Timed Automata (TA) that preserves the behavioral semantics (timed bisimilarity) of the TPNs. For the theory of TPNs this result is twofold: (i) reachability problems and more generally TCTL model-checking are decidable for bounded TPNs; (ii) allowing strict time constraints on transitions for TPNs preserves the results described in (i). The practical applications of the translation are: (i) one can specify a system using both TPNs and Timed Automata and a precise semantics is given to the composition; (ii) one can use existing tools for analyzing timed automata (like K ronos , U ppaal  or C mc ) to analyze TPNs. In this paper we describe the new feature of the tool R omeo  that implements our translation of TPNs in the U ppaal  input format. We also report on experiments carried out on various examples and compare the result of our method to state-of-the-art tool for analyzing TPNs.}}
@ARTICLE{Mehta_1999,title={Predictable scheduling of a single machine subject to breakdowns},year={1999},author={Sanjay V. Mehta and Sanjay V. Mehta},doi={10.1080/095119299130443},pmid={null},pmcid={null},mag_id={2000764840},journal={International Journal of Computer Integrated Manufacturing},abstract={The predictive production schedule has two important functions; allocating shop resources to the different jobs to optimize some measure of shop performance and serving as a basis for planning activities such as material procurement, preventive maintenance and delivery of orders to external or internal customers. This schedule is modified during execution on the occurrence of disruptions such as machine breakdowns. The schedule modification process may delay or render infeasible the execution of activities planned on the basis of the predictive schedule. Thus it is of interest to develop predictive schedules which can absorb disruptions without affecting planned activities while maintaining high shop performance. A predictable scheduling approach is presented, where the predictive schedule is built with such objectives. The effects of disruptions on planned activities are measured by the difference between planned and realized job completion times. The specific scheduling model considered is minimizing ma...}}
@ARTICLE{Jackson_1956,title={An extension of Johnson's results on job IDT scheduling},year={1956},author={James R. Jackson and James R. Jackson},doi={10.1002/nav.3800030307},pmid={null},pmcid={null},mag_id={2001080175},journal={Naval Research Logistics Quarterly},abstract={Naval Research Logistics QuarterlyVolume 3, Issue 3 p. 201-203 Article An extension of Johnson's results on job IDT scheduling† James R. Jackson, James R. Jackson University of California Los AngelesSearch for more papers by this author James R. Jackson, James R. Jackson University of California Los AngelesSearch for more papers by this author First published: September 1956 https://doi.org/10.1002/nav.3800030307Citations: 153 † Prepared under contract to the Office of Naval Research. AboutPDF ToolsRequest permissionExport citationAdd to favoritesTrack citation ShareShare Give accessShare full text accessShare full-text accessPlease review our Terms and Conditions of Use and check box below to share full-text version of article.I have read and accept the Wiley Online Library Terms and Conditions of UseShareable LinkUse the link below to share a full-text version of this article with your friends and colleagues. Learn more.Copy URL Share a linkShare onFacebookTwitterLinked InRedditWechat No abstract is available for this article.Citing Literature Volume3, Issue3September 1956Pages 201-203 RelatedInformation}}
@ARTICLE{Kilic_2011,title={A discrete time formulation for batch processes with storage capacity and storage time limitations},year={2011},author={Onur A. Kilic and Onur A. Kilic and Dirk Pieter van Donk and Dirk Pieter van Donk and Jacob Wijngaard and Jacob Wijngaard},doi={10.1016/j.compchemeng.2010.10.004},pmid={null},pmcid={null},mag_id={2002849628},journal={Computers & Chemical Engineering},abstract={null}}
@ARTICLE{Gradara_2005,title={Using heuristic search for finding deadlocks in concurrent systems},year={2005},author={Sara Gradara and Sara Gradara and Antonella Santone and Antonella Santone and Maria Luisa Villani and Maria Luisa Villani and Maria Luisa Villani},doi={10.1016/j.ic.2005.07.004},pmid={null},pmcid={null},mag_id={2004043832},journal={Information & Computation},abstract={Model checking is a formal technique for proving the correctness of a system with respect to a desired behavior. This is accomplished by checking whether a structure representing the system (typically a labeled transition system) satisfies a temporal logic formula describing the expected behavior. Model checking has a number of advantages over traditional approaches that are based on simulation and testing: it is completely automatic and when the verification fails it returns a counterexample that can be used to pinpoint the source of the error. Nevertheless, model checking techniques often fail because of the state explosion problem: transition systems grow exponentially with the number of components. The aim of this paper is to attack the state explosion problem that may arise when looking for deadlocks in concurrent systems described through the Calculus of Communicating Systems. We propose to use heuristics-based techniques, namely the A* algorithm, both to guide the search without constructing the complete transition system, and to provide minimal counterexamples. We have realized a prototype tool to evaluate the methodology. Experiments we have conducted on processes of different size show the benefit from using our technique against building the whole state space, or applying some other methods.}}
@ARTICLE{Emerson_1986,title={“Sometimes” and “not never” revisited: on branching versus linear time temporal logic},year={1986},author={E. Allen Emerson and E. Allen Emerson and Joseph Y. Halpern and Joseph Y. Halpern},doi={10.1145/4904.4999},pmid={null},pmcid={null},mag_id={2004306067},journal={Journal of the ACM},abstract={The differences between and appropriateness of branching versus linear time temporal logic for reasoning about concurrent programs are studied. These issues have been previously considered by Lamport. To facilitate a careful examination of these issues, a language, CTL * , in which a universal or existential path quantifier can prefix an arbitrary linear time assertion, is defined. The expressive power of a number of sublanguages is then compared. CTL* is also related to the logics MPL of Abrahamson and PL of Harel, Kozen, and Parikh. The paper concludes with a comparison of the utility of branching and linear time temporal logics.}}
@ARTICLE{Candea_2010,title={Automated software testing as a service},year={2010},author={George Candea and George Candea and Stefan Bucur and Stefan Bucur and Cristian Zamfir and Cristian Zamfir},doi={10.1145/1807128.1807153},pmid={null},pmcid={null},mag_id={2005403724},journal={null},abstract={This paper makes the case for TaaS--automated software testing as a cloud-based service. We present three kinds of TaaS: a "programmer's sidekick" enabling developers to thoroughly and promptly test their code with minimal upfront resource investment; a "home edition" on-demand testing service for consumers to verify the software they are about to install on their PC or mobile device; and a public "certification service," akin to Underwriters Labs, that independently assesses the reliability, safety, and security of software.   TaaS automatically tests software, without human involvement from the service user's or provider's side. This is unlike today's "testing as a service" businesses, which employ humans to write tests. Our goal is to take recently proposed techniques for automated testing--even if usable only on to y programs--and make them practical by modifying them to harness the resources of compute clouds. Preliminary work suggests it is technically feasible to do so, and we find that TaaS is also compelling from a social and business point of view.}}
@ARTICLE{Hansson_1990,title={A logic for reasoning about time and reability},year={1990},author={Hans Hansson and Hans Hansson and Bengt Jönsson and Bengt Jonsson},doi={10.1007/bf01211866},pmid={null},pmcid={null},mag_id={2005998857},journal={Formal Aspects of Computing},abstract={We present a logic for stating properties such as, "after a request for service there is at least a 98\045 probability that the service will be carried out within 2 seconds". The logic extends the temporal logic CTL by Emerson, Clarke and Sistla with time and probabil- ities. Formulas are interpreted over discrete time Markov chains. We give algorithms for checking that a given Markov chain satis- fies a formula in the logic. The algorithms require a polynomial number of arithmetic operations, in size of both the formula and\003This research report is a revised and extended version of a paper that has appeared under the title "A Framework for Reasoning about Time and Reliability" in the Proceeding of the 10thIEEE Real-time Systems Symposium, Santa Monica CA, December 1989. This work was partially supported by the Swedish Board for Technical Development (STU) as part of Esprit BRA Project SPEC, and by the Swedish Telecommunication Administration.1the Markov chain. A simple example is included to illustrate the algorithms.}}
@ARTICLE{Gradara_2006,title={DELFIN+: An efficient deadlock detection tool for CCS processes},year={2006},author={Sara Gradara and Sara Gradara and Antonella Santone and Antonella Santone and Maria Luisa Villani and Maria Luisa Villani and Maria Luisa Villani},doi={10.1016/j.jcss.2006.03.003},pmid={null},pmcid={null},mag_id={2007866490},journal={Journal of Computer and System Sciences},abstract={Abstract    Model checking  is a formal technique for proving the correctness of a system with respect to a desired behavior. However, deadlock detection via model checking is particularly difficult for the following two problems: (i) the  state explosion problem , due to the exponential increase in the size of a finite state model as the number of system components grows; and (ii) the  output interpretation problem , as often counter-examples are so long that they are hard to understand. The aim of this paper is to solve both problems by using heuristic-based search strategies. We have realized DELFIN +  (DEadLock FINder) a tool supporting efficient deadlock detection in CCS processes. We have used this tool to verify a sample of CCS processes, in order to evaluate the method on them.}}
@ARTICLE{Bohnenkamp_2004,title={Synthesis and stochastic assessment of schedules for lacquer production},year={2004},author={Henrik Bohnenkamp and Henrik C. Bohnenkamp and H. Bohnenkamp and Holger Hermanns and Holger Hermanns and Ric Klaren and Ric Klaren and Angelika Mader and Angelika Mader and Yaroslav S. Usenko and Y.S. Usenko},doi={10.1109/qest.2004.42},pmid={null},pmcid={null},mag_id={2008988868},journal={null},abstract={The Modest modeling language pairs modeling features from stochastic process algebra and from timed and probabilistic automata with light-weight notations such as exception handling. It is supported by the Motor tool, which facilitates the execution and evaluation of Modest specifications by means of the discrete event simulation engine of the Mobius tool. This paper describes the application of Modest, Motor and Mobius to a highly nontrivial case. We investigate the effect of faulty behavior on a hard real-time scheduling problem from the domain of lacquer production. The scheduling problem is first solved using the timed model-checker Uppaal. The resulting schedules are then embedded in a Modest failure model of the lacquer production line, and analyzed with the discrete event simulator of Mobius. This approach allows one to assess the quality of the schedules with respect to timeliness, utilization of resources, and sensitivity to different assumptions about the reliability of the production line.}}
@ARTICLE{Iversen_2000,title={Model-checking real-time control programs: verifying LEGO MINDSTORMS TM systems using UPPAAL},year={2000},author={Torsten K. Iversen and Torsten K. Iversen and K. Kristoffersen and Kåre J. Kristoffersen and Kim Guldstrand Larsen and Kim Guldstrand Larsen and Morten Laursen and Morten Laursen and Rune G. Madsen and Rune G. Madsen and Steffen K. Mortensen and Steffen K. Mortensen and Paul Pettersson and Paul Pettersson and Chris B. Thomasen and Chris B. Thomasen},doi={10.1109/emrts.2000.854002},pmid={null},pmcid={null},mag_id={2011767010},journal={null},abstract={The authors present a method for automatic verification of real time control programs running on LEGO RCX TM bricks using the verification tool UPPAAL. The control programs, consisting of a number of tasks running concurrently, are automatically translated into the timed automata model of UPPAAL. The fixed scheduling algorithm used by the LEGO RCXTM processor is modeled in UPPAAL, and supply of similar (sufficient) timed automata models for the environment allows analysis of the overall real time system using the tools of UPPAAL. To illustrate our techniques, we have constructed, modeled and verified a machine for sorting LEGO bricks by color.}}
@ARTICLE{Herroelen_2004,title={Robust and reactive project scheduling: a review and classification of procedures},year={2004},author={Willy Herroelen and Willy Herroelen and Roel Leus and Roel Leus},doi={10.1080/00207540310001638055},pmid={null},pmcid={null},mag_id={2013822994},journal={International Journal of Production Research},abstract={The vast majority of the research efforts in project scheduling over the past several years has concentrated on the development of exact and suboptimal procedures for the generation of a baseline schedule assuming complete information and a deterministic environment. During execution, however, projects may be the subject of considerable uncertainty, which may lead to numerous schedule disruptions. Predictive-reactive scheduling refers to the process where a baseline schedule is developed prior to the start of the project and updated if necessary during project execution. It is the objective of this paper to review possible procedures for the generation of proactive (robust) schedules, which are as well as possible protected against schedule disruptions, and for the deployment of reactive scheduling procedures that may be used to revise or re-optimize the baseline schedule when unexpected events occur. We also offer a framework that should allow project management to identify the proper scheduling methodol...}}
@ARTICLE{Demeulemeester_2002,title={Project Scheduling: A Research Handbook},year={2002},author={Erik Demeulemeester and Erik Demeulemeester and Willy Herroelen and Willy Herroelen},doi={null},pmid={null},pmcid={null},mag_id={2016007273},journal={null},abstract={Scope and Relevance of Project Scheduling.- The Project Scheduling Process.- Classification of Project Scheduling Problems.- Temporal Analysis: The Basic Deterministic Case.- Temporal Analysis: Advanced Topics.- The Resource-Constrained Project Scheduling Problem.- Resource-Constrained Scheduling: Advanced Topics.- Project Scheduling with Multiple Activity Execution Modes.- Stochastic Project Scheduling.- Robust and Reactive Scheduling.}}
@ARTICLE{McVitie_1971,title={The stable marriage problem},year={1971},author={D. G. McVitie and D. G. McVitie and D. G. McVitie and L. B. Wilson and L. B. Wilson and L. B. Wilson},doi={10.1145/362619.362631},pmid={null},pmcid={null},mag_id={2017008045},journal={Communications of The ACM},abstract={The original work of Gale and Shapley on an assignment method using the stable marriage criterion has been extended to find all the stable marriage assignments. The algorithm derived for finding all the stable marriage assignments is proved to satisfy all the conditions of the problem. Algorithm 411 applies to this paper.}}
@ARTICLE{Kanellakis_1990,title={CCS expressions finite state processes, and three problems of equivalence},year={1990},author={Paris C. Kanellakis and Paris C. Kanellakis and Scott A. Smolka and Scott A. Smolka},doi={10.1016/0890-5401(90)90025-d},pmid={null},pmcid={null},mag_id={2021473546},journal={Information & Computation},abstract={null}}
@ARTICLE{Yovine_1997,title={KRONOS: a verification tool for real-time systems},year={1997},author={Sergio Yovine and Sergio Yovine},doi={10.1007/s100090050009},pmid={null},pmcid={null},mag_id={2023499821},journal={International Journal on Software Tools for Technology Transfer},abstract={null}}
@ARTICLE{Pnueli_1977,title={The temporal logic of programs},year={1977},author={Amir Pnueli and Amir Pnueli},doi={10.1109/sfcs.1977.32},pmid={null},pmcid={null},mag_id={2023808162},journal={null},abstract={A unified approach to program verification is suggested, which applies to both sequential and parallel programs. The main proof method suggested is that of temporal reasoning in which the time dependence of events is the basic concept. Two formal systems are presented for providing a basis for temporal reasoning. One forms a formalization of the method of intermittent assertions, while the other is an adaptation of the tense logic system Kb, and is particularly suitable for reasoning about concurrent programs.}}
@ARTICLE{Lin_1987,title={Protocol verification using reachability analysis: the state space explosion problem and relief strategies},year={1987},author={Fuchun Joseph Lin and Fuchun Joseph Lin and P. M. Chu and P. M. Chu and M. T. Liu and M. T. Liu},doi={10.1145/55483.55496},pmid={null},pmcid={null},mag_id={2023949272},journal={null},abstract={Reachability analysis has proved to be one of the most effective methods in verifying correctness of communication protocols based on the state transition model. Consequently, many protocol verification tools have been built based on the method of reachability analysis. Nevertheless, it is also well known that state space explosion is the most severe limitation to the applicability of this method. Although researchers in the field have proposed various strategies to relieve this intricate problem when building the tools, a survey and evaluation of these strategies has not been done in the literature. In searching for an appropriate approach to tackling such a problem for a grammar-based validation tool, we have collected and evaluated these relief strategies, and have decided to develop our own from yet another but more systematic approach. The results of our research are now reported in this paper. Essentially, the paper is to serve two purposes: first, to give a survey and evaluation of existing relief strategies; second, to propose a new strategy, called PROVAT (PROtocol VAlidation Testing), which is inspired by the heuristic search techniques in Artificial Intelligence. Preliminary results of incorporating the PROVAT strategy into our validation tool are reviewed in the paper. These results show the empirical evidence of the effectiveness of the PROVAT strategy.}}
@ARTICLE{Johnson_1954,title={Optimal two- and three-stage production schedules with setup times included},year={1954},author={Selmer Martin Johnson and S. M. Johnson},doi={10.1002/nav.3800010110},pmid={null},pmcid={null},mag_id={2024085737},journal={Naval Research Logistics Quarterly},abstract={Each of a collection of items are to be produced on two machines (or stages). Each machine can handle only one item at a time and each item must be processed through machine one and then through machine two. The setup time plus work time for each item for each machine is known. A simple decision rule is obtained in this paper for the optimal scheduling of the production so that the total elapsed time is a minimum. A three‐machine problem is also discussed and solved for a restricted case.}}
@ARTICLE{Alur_1993,title={Parametric real-time reasoning},year={1993},author={Rajeev Alur and Rajeev Alur and Thomas A. Henzinger and Thomas A. Henzinger and Moshe Y. Vardi and Moshe Y. Vardi},doi={10.1145/167088.167242},pmid={null},pmcid={null},mag_id={2025782239},journal={null},abstract={Traditional approaches to the algorithmic veri cation of real-time systems are limited to checking program correctness with respect to concrete timing properties (e.g., \message delivery within 10 milliseconds"). We address the more realistic and more ambitious problem of deriving symbolic constraints on the timing properties required of real-time systems (e.g., \message delivery within the time it takes to execute two assignment statements"). To model this problem, we introduce parametric timed automata | nite-state machines whose transitions are constrained with parametric timing requirements. The emptiness question for parametric timed automata is central to the veri cation problem. On the negative side, we show that in general this question is undecidable. On the positive side, we provide algorithms for checking the emptiness of restricted classes of parametric timed automata. The practical relevance of these classes is illustrated with several veri cation examples. There remains a gap between the automata classes for which we know that emptiness is decidable and undecidable, respectively, and this gap is related to various hard and open problems of logic and automata theory.}}
@ARTICLE{Voudouris_1996,title={MILP model for scheduling and design of a special class of multipurpose batch plants},year={1996},author={Vasilios T. Voudouris and V.T. Voudouris and Ignacio E. Grossmann and Ignacio E. Grossmann},doi={10.1016/0098-1354(96)81812-6},pmid={null},pmcid={null},mag_id={2031217737},journal={Computers & Chemical Engineering},abstract={null}}
@ARTICLE{Majozi_2006,title={Maximization of Throughput in a Multipurpose Batch Plant under a Fixed Time Horizon: S-graph Approach},year={2006},author={Thokozani Majozi and Thokozani Majozi and Ferenc Friedler and Ferenc Friedler and Ferenc Friedler},doi={10.1021/ie0604472},pmid={null},pmcid={null},mag_id={2031253472},journal={Industrial & Engineering Chemistry Research},abstract={This paper presents a graph-theoretic approach for the scheduling of multipurpose batch plants with the objective to maximize economic performance indexes, such as throughput, revenue, and profit over a predefined time horizon. The approach is based on the S-graph framework, which has been previously applied in the scheduling of multipurpose batch plants for the optimization of time-based performance indexes, e.g., minimization of makespan. In contrast to most techniques published in the literature, the approach proposed in this paper does not require any presupposition of the number of time points or manipulation of the time horizon of interest, which renders it continuous in time. The optimization procedure is based on a guided search algorithm that is guaranteed to terminate at a global optimum. Furthermore, the proposed approach exploits structural uniqueness of the problem to improve computational efficiency, which is necessary for industrial-scale problems. Nonintermediate storage (NIS) operational policy is addressed in this paper.}}
@ARTICLE{Majozi_2001,title={A Novel Continuous-Time MILP Formulation for Multipurpose Batch Plants. 1. Short-Term Scheduling},year={2001},author={Thokozani Majozi and Thokozani Majozi and Xin Zhu and X. X. Zhu and X. X. Zhu and X. X. Zhu},doi={10.1021/ie0005452},pmid={null},pmcid={null},mag_id={2034528540},journal={Industrial & Engineering Chemistry Research},abstract={In this paper, a new concept, the so-called state sequence network representation, is presented. This representation is based on states only, eliminating the use of tasks and units. Using this new representation as a basis, a novel continuous-time MILP formulation for short-term scheduling of multipurpose batch plants is developed. The presented formulation can readily be extended to intermediate due date scenarios. Also presented in this paper is a new model for the duration constraints that explores degrees of freedom that are intrinsic in batch operations. These are due to operator intervention, raw material purity, and different catalyst types. Time points are used to denote the use or production of a particular state. This formulation leads to the least number of binary variables and much better results when compared to other continuous-time formulations published in the literature. The reduced number of binary variables is a result of considering states only, thereby eliminating binary variables cor...}}
@ARTICLE{Strehl_1998,title={Symbolic model checking of process networks using interval diagram techniques},year={1998},author={Karsten Strehl and Karsten Strehl and Lothar Thiele and Lothar Thiele},doi={10.1145/288548.289117},pmid={null},pmcid={null},mag_id={2036546797},journal={null},abstract={In this paper, an approach to symbolic model checking of process networks is introduced. It is based on interval decision diagrams (IDDs), a representation of multi-valued functions. Compared to other model checking strategies, IDDs show some important properties that enable the verification of process networks more adequately than with conventional approaches. Additionally, applications concerning scheduling are shown. A new form of transition relation representation called interval mapping diagrams (IMDs)-and their less general version predicate action diagrams (PADs)-are explained together with the corresponding methods.}}
@ARTICLE{Öhman_1997,title={Implementation Aspects of the PLC Standard IEC 1131-3},year={1997},author={Martin Öhman and Martin Öhman and Stefan Johansson and Stefan Johansson and Stefan Johansson and Karl-Erik Årzén and Karl-Erik Årzén},doi={10.1016/s0967-0661(98)00054-9},pmid={null},pmcid={null},mag_id={2039691814},journal={Control Engineering Practice},abstract={null}}
@ARTICLE{Havelund_2000,title={Model Checking JAVA Programs Using Java Pathfinder},year={2000},author={Klaus Havelund and Klaus Havelund and Thomas Pressburger and Thomas Pressburger},doi={10.1007/s100090050043},pmid={null},pmcid={null},mag_id={2040060046},journal={International Journal on Software Tools for Technology Transfer},abstract={This paper describes a translator called Java PathFinder (Jpf), which translates from Java to Promela, the modeling language of the Spin model checker. Jpf translates a given Java program into a Promela model, which then can be model checked using Spin. The Java program may contain assertions, which are translated into similar assertions in the Promela model. The Spin model checker will then look for deadlocks and violations of any stated assertions. Jpf generates a Promela model with the same state space characteristics as the Java program. Hence, the Java program must have a finite and tractable state space. This work should be seen in a broader attempt to make formal methods applicable within NASA’s areas such as space, aviation, and robotics. The work is a continuation of an effort to formally analyze, using Spin, a multi-threaded operating system for the Deep-Space 1 space craft, and of previous work in applying existing model checkers and theorem provers to real applications.}}
@ARTICLE{Cousot_1977,title={Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints},year={1977},author={Patrick Cousot and Patrick Cousot and Radhia Cousot and Radhia Cousot},doi={10.1145/512950.512973},pmid={null},pmcid={null},mag_id={2043100293},journal={null},abstract={A program denotes computations in some universe of objects. Abstract interpretation of programs consists in using that denotation to describe computations in another universe of abstract objects, so that the results of abstract execution give some information on the actual computations. An intuitive example (which we borrow from Sintzoff [72]) is the rule of signs. The text -1515 * 17 may be understood to denote computations on the abstract universe {(+), (-), (±)} where the semantics of arithmetic operators is defined by the rule of signs. The abstract execution -1515 * 17 → -(+) * (+) → (-) * (+) → (-), proves that -1515 * 17 is a negative number. Abstract interpretation is concerned by a particular underlying structure of the usual universe of computations (the sign, in our example). It gives a summary of some facets of the actual executions of a program. In general this summary is simple to obtain but inaccurate (e.g. -1515 + 17 → -(+) + (+) → (-) + (+) → (±)). Despite its fundamentally incomplete results abstract interpretation allows the programmer or the compiler to answer questions which do not need full knowledge of program executions or which tolerate an imprecise answer, (e.g. partial correctness proofs of programs ignoring the termination problems, type checking, program optimizations which are not carried in the absence of certainty about their feasibility, …).}}
@ARTICLE{Shaik_2009,title={Novel Unified Modeling Approach for Short-Term Scheduling},year={2009},author={Munawar A. Shaik and Munawar A. Shaik and Christodoulos A. Floudas and Christodoulos A. Floudas},doi={10.1021/ie8010726},pmid={null},pmcid={null},mag_id={2043758623},journal={Industrial & Engineering Chemistry Research},abstract={Unit-specific event-based continuous time models have gained significant attention in the past decade for their advantages of requiring less number of event points, smaller problem size, and hence, a better computational performance. In the literature, different models had been proposed for short-term scheduling problems involving with and without resource constraints using unit-specific event-based formulations. For scheduling problems involving no resource constraints, generally the unit-specific event-based models do not allow tasks to continue over multiple events unlike in models that account for resource constraints explicitly. In this work, we emphasize the necessity for allowing tasks to take place over multiple event points even for simpler scheduling problems involving no resource constraints. We propose a novel short-term scheduling model using three-index binary and continuous variables that efficiently merges both the problems involving resources and no resource constraints into a unified, ge...}}
@ARTICLE{Mahanti_1985,title={AND/OR graph heuristic search methods},year={1985},author={Ambuj Mahanti and A. Mahanti and Arunabha Bagchi and Amitava Bagchi},doi={10.1145/2455.2459},pmid={null},pmcid={null},mag_id={2044354687},journal={Journal of the ACM},abstract={Two new marking algorithms for AND/OR graphs called CF and CS are presented. For admissible heuristics CS is not needed, and CF is shown to be preferable to the marking algorithms of Martelli and Montanari. When the heuristic is not admissible, the analysis is carried out with the help of the notion of the first and second discriminants of an AND/OR graph. It is proved that in this case CF can be followed by CS to get optimal solutions, provided the sumcost criterion is used and the first discriminant equals the second. Estimates of time and storage requirements are given. Other cost measures, such as maxcost, are also considered, and a number of interesting open problems are enumerated.}}
@ARTICLE{Shaik_2009,title={Production scheduling of a large-scale industrial continuous plant: Short-term and medium-term scheduling},year={2009},author={Munawar A. Shaik and Munawar A. Shaik and Christodoulos A. Floudas and Christodoulos A. Floudas and Josef Kallrath and Josef Kallrath and Hans-Joachim Pitz and Hans-Joachim Pitz},doi={10.1016/j.compchemeng.2008.08.013},pmid={null},pmcid={null},mag_id={2050078661},journal={Computers & Chemical Engineering},abstract={null}}
@ARTICLE{Chakrabarti_1994,title={Algorithms for searching explicit AND/OR graphs and their applications to problem reduction search},year={1994},author={P. P. Chakrabarti and Partha Chakrabarti},doi={10.1016/0004-3702(94)90020-5},pmid={null},pmcid={null},mag_id={2051199238},journal={Artificial Intelligence},abstract={null}}
@ARTICLE{Fraser_2009,title={Testing with model checkers: a survey},year={2009},author={Gordon Fraser and Gordon Fraser and Franz Wotawa and Franz Wotawa and Paul Ammann and Paul Ammann},doi={10.1002/stvr.v19:3},pmid={null},pmcid={null},mag_id={2052495090},journal={Software Testing, Verification & Reliability},abstract={About a decade after the initial proposal to use model checkers for the generation of test cases we take a look at the results in this field of research. Model checkers are formal verification tools, capable of providing counterexamples to violated properties. Normally, these counterexamples are meant to guide an analyst when searching for the root cause of a property violation. They are, however, also very useful as test cases. Many different approaches have been presented, many problems have been solved, yet many issues remain. This survey paper reviews the state of the art in testing with model checkers. Copyright © 2008 John Wiley & Sons, Ltd.}}
@ARTICLE{Gargantini_1999,title={Using model checking to generate tests from requirements specifications},year={1999},author={Angelo Gargantini and Angelo Gargantini and Constance L. Heitmeyer and Constance L. Heitmeyer},doi={10.1145/318774.318939},pmid={null},pmcid={null},mag_id={2055647675},journal={null},abstract={Recently, many formal methods, such as the SCR (Software Cost Reduction) requirements method, have been proposed for improving the quality of software specifications. Although improved specifications are valuable, the ultimate objective of software development is to produce software that satisfies its requirements. To evaluate the correctness of a software implementation, one can apply black-box testing to determine whether the implementation, given a sequence of system inputs, produces the correct system outputs. This paper describes a specification-based method for constructing a suite of  test sequences , where a test sequence is a sequence of inputs and outputs for testing a software implementation. The test sequences are derived from a tabular SCR requirements specification containing diverse data types, i.e., integer, boolean, and enumerated types. From the functions defined in the SCR specification, the method forms a collection of predicates called  branches , which “cover” all possible software behaviors described by the specification. Based on these predicates, the method then derives a suite of test sequences by using a model checker's ability to construct counterexamples. The paper presents the results of applying our method to four specifications, including a sizable component of a contractor specification of a real system.}}
@ARTICLE{Störrle_2013,title={Towards clone detection in UML domain models},year={2013},author={Harald Störrle and Harald Störrle},doi={10.1007/s10270-011-0217-9},pmid={null},pmcid={null},mag_id={2057750296},journal={Software and Systems Modeling},abstract={Code clones (i.e., duplicate fragments of code) have been studied for long, and there is strong evidence that they are a major source of software faults. Anecdotal evidence suggests that this phenomenon occurs similarly in models, suggesting that model clones are as detrimental to model quality as they are to code quality. However, programming language code and visual models have significant differences that make it difficult to directly transfer notions and algorithms developed in the code clone arena to model clones. In this article, we develop and propose a definition of the notion of "model clone" based on the thorough analysis of practical scenarios. We propose a formal definition of model clones, specify a clone detection algorithm for UML domain models, and implement it prototypically. We investigate different similarity heuristics to be used in the algorithm, and report the performance of our approach. While we believe that our approach advances the state of the art significantly, it is restricted to UML models, its results leave room for improvements, and there is no validation by field studies.}}
@ARTICLE{Behrmann_2005,title={Distributed reachability analysis in timed automata},year={2005},author={Gerd Behrmann and Gerd Behrmann},doi={10.1007/s10009-003-0111-z},pmid={null},pmcid={null},mag_id={2059970075},journal={International Journal on Software Tools for Technology Transfer},abstract={We evaluate a distributed reachability algorithm suitable for verification of real time critical systems modeled as timed automata. It is discovered that the algorithm suffers from load balancing problems and a high communication overhead. The load balancing problems are caused by the symbolic nature of the representation of the states of a timed automaton. We propose alternative data structures for representing the state-space of a timed automaton and adding a proportional load balancing controller on top of the algorithm. We evaluate various approaches at reducing communication overhead by increasing locality and compressing states. It is experimentally evaluated that by using the techniques speedups between 50% and 90% of linear can be obtained on a 14 node Linux Beowulf cluster on medium sized examples.}}
@ARTICLE{Magee_1999,title={Concurrency: State Models & Java Programs},year={1999},author={Jeff Magee and Jeff Magee and Jeff Kramer and Jeff Kramer},doi={null},pmid={null},pmcid={null},mag_id={2060910670},journal={null},abstract={Concurrency provides a thoroughly updatedapproach to the basic concepts and techniques behind concurrent programming. Concurrent programming is complex and demands a much more formal approach than sequential programming. In order to develop a thorough understanding of the topicMagee and Kramer present concepts, techniques and problems through a variety of forms: informal descriptions, illustrative examples, abstract models and concrete Java examples. These combineto provide problem patterns and associated solution techniqueswhich enablestudents torecognise problems and arrive at solutions. New features include: New chapters covering program verification and logical properties. More student exercises. Supporting website contains an updated version of the LTSA tool for modelling concurrency, model animation, and model checking. Website also includes the full set of state models, java examples, and demonstration programs and a comprehensive set of overhead slides for course presentation.}}
@ARTICLE{Cuomo_2014,title={CD-Form},year={2014},author={Antonio Cuomo and Antonio Cuomo and Antonella Santone and Antonella Santone and Umberto Villano and Umberto Villano},doi={10.1016/j.scico.2013.11.022},pmid={null},pmcid={null},mag_id={2062388955},journal={Science of Computer Programming},abstract={This paper presents the design and implementation of CD-Form (Clone Detector based on FORmal Methods), a tool targeted at the detection of Type-2 clones in Java code. CD-Form is based on a novel approach for detecting code clones. The methodology adopted performs the analysis on Java bytecode and not on the original Java source. The bytecode is transformed into CCS (Calculus of Communicating Systems) processes, which are successively checked for equivalence. After a thorough description of the methodology used for detecting clones, the design of the tool is presented. The results obtained by evaluating sample Java codes are validated by comparing them to those obtained by a state-of-the-art tool for clone detection. We propose the use of formal methods (Calculus of Communicating Systems) for detection of software clones.We introduce a technique for translating Java bytecode to process algebra representation.We present an optimized implementation able to deal with real-world software projects.We provide a comparison with a state-of-the-art tool, obtaining comparable results.}}
@ARTICLE{Barbuti_1999,title={Selective Mu-Calculus and Formula-Based Equivalence of Transition Systems},year={1999},author={Roberto Barbuti and Roberto Barbuti and Nicoletta De Francesco and Nicoletta De Francesco and Antonella Santone and Antonella Santone and Gigliola Vaglini and Gigliola Vaglini},doi={10.1006/jcss.1999.1660},pmid={null},pmcid={null},mag_id={2063176706},journal={Journal of Computer and System Sciences},abstract={In model checking for temporal logic, the correctness of a system with respect to a desired behavior is verified by checking whether a structure that models the system satisfies a formula describing the behavior. Most existing verification techniques are based on a representation of the system by means of a labeled transition system. In this approach to verification, the efficiency of the model checking is essentially influenced by the number of states of the transition system. In this paper we present a new temporal logic, the selective mu-calculus, and an equivalence between transition systems based on the formulae of this logic. This property preserving equivalence can be used to reduce the size of transition systems. The equivalence (called ?-equivalence) is based on the set, ?, of actions occurring inside the modal operators of a selective mu-calculus formula. We prove that the ?-equivalence coincides with the equivalence induced by the set of the selective mu-calculus formulae with occurring actions in ?. Thus, a formula can be more efficiently checked on a transition system ?-equivalent to the standard one, but smaller than it, since all the actions not in ? are “discarded.”}}
@ARTICLE{Santone_2012,title={Abstract reduction in directed model checking CCS processes},year={2012},author={Antonella Santone and Antonella Santone and Gigliola Vaglini and Gigliola Vaglini},doi={10.1007/s00236-012-0161-3},pmid={null},pmcid={null},mag_id={2063192183},journal={Acta Informatica},abstract={Model checking tools face a combinatorial blow up of the state-space (commonly known as the state explosion problem) that must be addressed to formally verify concurrent systems. We propose an approach combining abstraction techniques and heuristic search to overcome the problem above. In particular, heuristic search can avoid the bottleneck of the exhaustive exploration of the global state graph of a system, while retaining the advantages of abstraction techniques.}}
@ARTICLE{Walker_1989,title={Automated analysis of mutual exclusion algorithms using CCS},year={1989},author={David Walker and D. J. Walker},doi={10.1007/bf01887209},pmid={null},pmcid={null},mag_id={2063510765},journal={Formal Aspects of Computing},abstract={A number of mutual exclusion algorithms are studied by representing them as agents in the Calculus of Communicating Systems and using an automated tool embodying some of the theory of the Calculus to analyse the representations. It is determined whether or not each of the algorithms preserves mutual exclusion and is live.}}
@ARTICLE{Romero_2003,title={A New Framework for Batch Process Optimization Using the Flexible Recipe},year={2003},author={Javier Romero and Javier Romero and Javier Romero and Antonio Espuña and Antonio Espuña and Antonio Espuña and Ferenc Friedler and Ferenc Friedler and Ferenc Friedler and Luís Puigjaner and Luis Puigjaner and Luis Puigjaner},doi={10.1021/ie020002n},pmid={null},pmcid={null},mag_id={2063600226},journal={Industrial & Engineering Chemistry Research},abstract={Batch processes are characterized by a high degree of flexibility that can be appropriately exploited to obtain a maximum production profit. In principle, the nominal production recipe assumes an optimum balance between quality and costs for batches of products. However, in practice, this optimum performance is achieved only when this balance is extended to management of the entire batch plant. In this work, a framework is presented that fully exploits this inner flexibility of batch processes at the plant level. The framework considers a batch recipe model that interacts with a plant-wide model to constitute the so-called flexible recipe model. First, the potential use of this framework is shown by integrating a general multipurpose batch process scheduling algorithm into a general linear recipe model. Next, this framework is illustrated in practice using a real industrial scenario that exhibits complex recipe behavior. Finally, the benefits of considering the flexible recipe concept for the scheduling of batch processes are discussed.}}
@ARTICLE{Kamel_2000,title={Formalization and validation of the General Inter-ORB Protocol (GIOP) using PROMELA and SPIN},year={2000},author={Moataz Kamel and Moataz Kamel and Stefan Leue and Stefan Leue},doi={10.1007/s100090050045},pmid={null},pmcid={null},mag_id={2067623660},journal={International Journal on Software Tools for Technology Transfer},abstract={The General Inter-Orb Protocol (GIOP) is a key component of the Common Object Request Broker Architecture (CORBA) specification. We present the formal modeling and validation of the GIOP protocol using the Promela language, Linear Time Temporal Logic (LTL) and the Spin model checker. We validate the Promela model using ten high-level requirements which we elicit from the informal CORBA specification. These requirements are then formalized in LTL and the Spin model checker is used to determine their validity. During the validation process we discovered a few problems in GIOP: a potential transport-layer interface deadlock and problems with the server migration protocol. We also describe how property specification patterns helped us in formalizing the high-level requirements that we have elicited.}}
@ARTICLE{Paige_1987,title={Three partition refinement algorithms},year={1987},author={Robert Paige and Robert Paige and Robert E. Tarjan and Robert E. Tarjan},doi={10.1137/0216062},pmid={null},pmcid={null},mag_id={2068361557},journal={SIAM Journal on Computing},abstract={We present improved partition refinement algorithms for three problems: lexicographic sorting, relational coarsest partition, and double lexical ordering. Our double lexical ordering algorithm uses a new, efficient method for unmerging two sorted sets.}}
@ARTICLE{Imreh_2003,title={Scheduling problems on two sets of identical machines},year={2003},author={Csanád Imreh and Csanád Imreh},doi={10.1007/s00607-003-0011-9},pmid={null},pmcid={null},mag_id={2068718151},journal={Computing},abstract={In this paper we investigate the following scheduling problem: We have two sets of identical machines, the jobs have two processing times one for each set of machines. We consider two different objective functions, in the first model the goal is to minimize the maximum of the makespans on the sets, in the second model we minimize the sum of the makespans. We consider the online, semi online and offline versions of these problems.}}
@ARTICLE{Kondili_1993,title={A General Algorithm for Short-Term Scheduling of Batch Operations-I. MILP Formulation},year={1993},author={E. Kondili and E. Kondili and Constantinos C. Pantelides and C.C. Pantelides and Constantinos C. Pantelides and R. W. H. Sargent and R.W.H. Sargent and R.W.H. Sargent},doi={10.1016/0098-1354(93)80015-f},pmid={null},pmcid={null},mag_id={2070558838},journal={Computers & Chemical Engineering},abstract={null}}
@ARTICLE{Applegate_1991,title={A Computational Study of the Job-Shop Scheduling Problem},year={1991},author={David Applegate and David Applegate and W. J. Cook and William J. Cook},doi={10.1287/ijoc.3.2.149},pmid={null},pmcid={null},mag_id={2071306171},journal={Informs Journal on Computing},abstract={The job-shop scheduling problem is a notoriously difficult problem in combinatorial optimization. Although even modest sized instances remain computationally intractable, a number of important algorithmic advances have been made in recent years by J. Adams, E. Balas and D. Zawack; J. Carlier and E. Pinson; B. J. Lageweg, J. K. Lenstra and A. H. G. Rinnooy Kan; and others. Making use of a number of these advances, we have designed and implemented a new heuristic procedure for finding schedules, a cutting-plane method for obtaining lower bounds, and a combinatorial branch and bound algorithm. Our optimization procedure, combining the heuristic method and the combinatorial branch and bound algorithm, solved the well-known 10×10 problem of J. F. Muth and G. L. Thomson in under 7 minutes of computation time on a Sun Sparcstation 1. INFORMS Journal on Computing , ISSN 1091-9856, was published as ORSA Journal on Computing from 1989 to 1995 under ISSN 0899-1499.}}
@ARTICLE{Panek_2008,title={Scheduling of Multi-Product Batch Plants based upon Timed Automata Models},year={2008},author={Sebastian Panek and Sebastian Panek and Sebastian Engell and Sebastian Engell and Subanatarajan Subbiah and Subanatarajan Subbiah and Olaf Stursberg and Olaf Stursberg},doi={10.1016/j.compchemeng.2007.07.009},pmid={null},pmcid={null},mag_id={2072776377},journal={Computers & Chemical Engineering},abstract={null}}
@ARTICLE{Jiménez_2000,title={An efficient algorithm for searching implicit AND/OR graphs with cycles},year={2000},author={Pablo Jiménez and Pablo Jiménez and Carme Torras and Carme Torras},doi={10.1016/s0004-3702(00)00063-1},pmid={null},pmcid={null},mag_id={2073628093},journal={Artificial Intelligence},abstract={Abstract   We present an efficient    AO     ∗    -like algorithm that handles cyclic graphs without neither unfolding the cycles nor looping through them. Its top-down search strategy is based on Mahanti and Bagchi's CF [J. ACM 32 (1985) 28], whereas its bottom-up revision process is inspired in Chakrabarti's REV      ∗     [Artificial Intelligence 65 (1994) 329]. However, important modifications have been introduced in both algorithms to attain a true integration and gain efficiency. Proofs of correctness and completeness are included. Up to our knowledge, the resulting algorithm—called    CFC      REV     ∗      —is the most efficient one available for this problem.}}
@ARTICLE{Bustan_2003,title={Simulation-based minimization},year={2003},author={Doron Bustan and Doran Bustan and Orna Grumberg and Orna Grumberg},doi={10.1145/635499.635502},pmid={null},pmcid={null},mag_id={2076334860},journal={ACM Transactions on Computational Logic},abstract={We present a minimization algorithm that receives a Kripke structure M and returns the smallest structure that is simulation equivalent to M. The simulation equivalence relation is weaker than bisimulation but stronger than the simulation preorder. It strongly preserves ACTL and LTL (as sublogics of ACTL*).We show that every structure M has a unique-up-to-isomorphism reduced structure that is simulation equivalent to M and smallest in size. Our Minimizing Algorithm constructs this reduced structure. It first constructs the quotient structure for M, then eliminates transitions to little brothers, and finally deletes unreachable states.Since the first step of the algorithm is based on the simulation preorder over M, it has maximal space requirements. To reduce them, we present the Partitioning Algorithm, which constructs the quotient structure for M without ever building the simulation preorder. The Partitioning Algorithm has improved space complexity, but its time complexity might have worse.}}
@ARTICLE{Higman_1952,title={Ordering by Divisibility in Abstract Algebras},year={1952},author={Graham Higman and Graham Higman},doi={10.1112/plms/s3-2.1.326},pmid={null},pmcid={null},mag_id={2076508310},journal={Proceedings of The London Mathematical Society},abstract={Proceedings of the London Mathematical SocietyVolume s3-2, Issue 1 p. 326-336 Articles Ordering by Divisibility in Abstract Algebras Graham Higman, Graham Higman The University, ManchesterSearch for more papers by this author Graham Higman, Graham Higman The University, ManchesterSearch for more papers by this author First published: 1952 https://doi.org/10.1112/plms/s3-2.1.326Citations: 582AboutPDF ToolsRequest permissionExport citationAdd to favoritesTrack citation ShareShare Give accessShare full text accessShare full-text accessPlease review our Terms and Conditions of Use and check box below to share full-text version of article.I have read and accept the Wiley Online Library Terms and Conditions of UseShareable LinkUse the link below to share a full-text version of this article with your friends and colleagues. Learn more.Copy URL Share a linkShare onFacebookTwitterLinkedInRedditWechat Citing Literature Volumes3-2, Issue11952Pages 326-336 RelatedInformation}}
@ARTICLE{Dongarra_1990,title={Performance of various computers using standard linear equations software},year={1990},author={Jack Dongarra and Jack Dongarra},doi={10.1145/141868.141871},pmid={null},pmcid={null},mag_id={2078637295},journal={ACM Sigarch Computer Architecture News},abstract={This report compares the performance of different computer systems in solving dense systems of linear equations. The comparison involves approximately a hundred computers, ranging from a CRAY Y-MP to scientific workstations such as the Apollo and Sun to IBM PCs.}}
@ARTICLE{Rattray_1990,title={Specification and Verification of Concurrent Systems},year={1990},author={Charles Rattray and C. Rattray},doi={null},pmid={null},pmcid={null},mag_id={2079680418},journal={null},abstract={1. The Interplay of Theory and Practice in a Parallel Object-Oriented Language.- 2. Object-Oriented Process Specification.- 3. Formal Object Oriented Specification of Distributed Systems.- 4. The Design and Development of Ada Real-Time Embedded Systems.- 5. Protocol Analysis and Implementation using NPNs and SDL.- 6. A Tool for the Performance Analysis of Concurrent Systems.- 7. Winston: A Tool for Hierarchical Design and Simulation of Concurrent Systems.- 8. A Specification-Verification Framework for Distributed Applications Software.- 9. Dynamic Communication Links.- 10. Formal Environment and Tools Description for the Analysis of Real Time Concurrent Systems.- 11. An Equivalence Decision Problem in Systolic Array Verification.- 12. Should Concurrency be Specified?.- 13. Semantics for Specifying Real-Time Systems (extended abstract only).- 14. Specifying Processes in Terms of their Environments.- 15. Hennessy-Milner Logic with Recursion as a Specification Language, and a Refinement Calculus based on It.- 16. A Functional Programming Approach to the Specification and Verification of Concurrent Systems.- 17. Synchronization in Network Protocols.- 18. From Synchronous to Asynchronous Communication.- 19. Formal Specification and Verification of Asynchronous Processes in Higher-Order Logic.- 20. Temporal Specifications Directed by Grammar and Design of Process Networks.- 21. Analysis of Estelle Specifications.- 22. Concurrency in Modula-2: Properties of the Language Primitives.- 23. Specification and Implementation of Concurrent Systems using PARLOG.- 24. Specification and Verification in Communications Standards.- 25. Experience with LOTOS and Environment LOTTE on an ISDN Protocol.- 26. The Specification and Design of a Nondeterministic Data Structure Using CCS.- 27. A High-Level Petri Net Specification of the Cambridge Fast Ring M-Access Service.- Poster Sessions.- 1. Modelling of Distributed Problem Solving using Logic Modified Petri Nets.- 2. An Animator for CSP Implemented in HOPE.- 3. A Concurrent Approach to the Towers of Hanoi.- Author Index.}}
@ARTICLE{Bryant_1986,title={Graph-Based Algorithms for Boolean Function Manipulation},year={1986},author={Bryant and Bryant},doi={10.1109/tc.1986.1676819},pmid={null},pmcid={null},mag_id={2080267935},journal={IEEE Transactions on Computers},abstract={In this paper we present a new data structure for representing Boolean functions and an associated set of manipulation algorithms. Functions are represented by directed, acyclic graphs in a manner similar to the representations introduced by Lee [1] and Akers [2], but with further restrictions on the ordering of decision variables in the graph. Although a function requires, in the worst case, a graph of size exponential in the number of arguments, many of the functions encountered in typical applications have a more reasonable representation. Our algorithms have time complexity proportional to the sizes of the graphs being operated on, and hence are quite efficient as long as the graphs do not grow too large. We present experimental results from applying these algorithms to problems in logic design verification that demonstrate the practicality of our approach.}}
@ARTICLE{Clarke_1994,title={Model checking and abstraction},year={1994},author={Edmund M. Clarke and Edmund M. Clarke and Orna Grumberg and Orna Grumberg and David E. Long and David E. Long},doi={10.1145/186025.186051},pmid={null},pmcid={null},mag_id={2080593426},journal={ACM Transactions on Programming Languages and Systems},abstract={We describe a method for using abstraction to reduce the complexity of temporal-logic model checking. Using techniques similar to those involved in abstract interpretation, we construct an abstract model of a program without ever examining the corresponding unabstracted model. We show how this abstract model can be used to verify properties of the original program. We have implemented a system based on these techniques, and we demonstrate their practicality using a number of examples, including a program representing a pipelined ALU circuit with over 10 1300  states.}}
@ARTICLE{Brebner_1993,title={A CCS-based investigation of deadlock in a multi-process electronic mail system},year={1993},author={Gordon Brebner and Gordon J. Brebner},doi={10.1007/bf01212487},pmid={null},pmcid={null},mag_id={2083355315},journal={Formal Aspects of Computing},abstract={The networking software for a VAX/VMS computer system had been implemented as a collection of communicating processes. One night, an unusually high load on the electronic mail component of the software caused deadlock to occur between two of the processes. This paper describes how the deadlock was analysed by modelling the software using the Calculus of Communicating Systems (CCS) and then by investigating the behaviour of the model using the Edinburgh Concurrency Workbench (CWB). The analysis suggested how the software should be restructured to prevent the problem recurring; the new set of processes was analysed, and shown to be deadlock-free.}}
@ARTICLE{Adonyi_2003,title={Incorporating heat integration in batch process scheduling},year={2003},author={R. Adonyi and R. Adonyi and Javier Romero and J. Romero and Javier Romero and Luís Puigjaner and L. Puigjaner and Luis Puigjaner and Ferenc Friedler and Ferenc Friedler},doi={10.1016/s1359-4311(03)00141-8},pmid={null},pmcid={null},mag_id={2086129818},journal={Applied Thermal Engineering},abstract={null}}
@ARTICLE{Alur_2004,title={Optimal paths in weighted timed automata},year={2004},author={Rajeev Alur and Rajeev Alur and Salvatore La Torre and Salvatore La Torre and George J. Pappas and George J. Pappas},doi={10.1016/j.tcs.2003.10.038},pmid={null},pmcid={null},mag_id={2089017767},journal={Theoretical Computer Science},abstract={We consider the optimal-reachability problem for a timed automaton with respect to a linear cost function which results in a weighted timed automaton. Our solution to this optimization problem consists of reducing it to computing (parametric) shortest paths in a finite weighted directed graph. We call this graph a parametric sub-region graph. It refines the region graph, a standard tool for the analysis of timed automata, by adding the information which is relevant to solving the optimal-teachability problem. We present an algorithm to solve the optimal-reachability problem for weighted timed automata that takes time exponential in O(n(|δ(A)| + |W max |)), where n is the number of clocks, |δ(A)| is the size of the clock constraints and |W max | is the size of the largest weight. We show that this algorithm can be improved, if we restrict to weighted timed automata with a single clock. In case we consider a single starting state for the optimal-reachability problem, our approach yields an algorithm that takes exponential time only in the length of clock constraints.}}
@ARTICLE{Santone_2002,title={Automatic verification of concurrent systems using a formula-based compositional approach},year={2002},author={Antonella Santone and Antonella Santone},doi={10.1007/s00236-002-0084-5},pmid={null},pmcid={null},mag_id={2089892886},journal={Acta Informatica},abstract={When verifying concurrent systems, described by transition systems, state explosion is one of the most serious problems: systems are often described by transition systems with a prohibitive number of states. The primary cause of this problem is the parallel composition of interacting processes. In the recent years, compositional techniques have been developed to attack the state explosion problem. These techniques are based on dividing the verification task into simpler tasks, exploiting the natural decomposition of complex systems into processes. In this paper we present a formula-based compositional approach that allows us to deduce a property of a parallel composition of processes by checking it only on a component process. The approach can be automated and it is completely transparent to the user.}}
@ARTICLE{Land_2010,title={An Automatic Method for Solving Discrete Programming Problems},year={2010},author={A. H. Land and Ailsa H. Land and Ailsa Land and Alison Doig and Alison G. Doig},doi={10.1007/978-3-540-68279-0_5},pmid={null},pmcid={null},mag_id={2091364465},journal={null},abstract={In the late 1950s there was a group of teachers and research assistants at the London School of Economics interested in linear programming and its extensions, in particular Helen Makower, George Morton, Ailsa Land and Alison Doig. We had considered the ‘Laundry Van Problem’ until we discovered that it was known as the Traveling Salesman Problem, and had looked at aircraft timetabling, until quickly realizing that even the planning for the Scottish sector was beyond our capability! Alison Doig (now Harcourt) had studied the paper trim problem for her Masters project in Melbourne before coming to England.}}
@ARTICLE{Godefroid_1996,title={Partial-Order Methods for the Verification of Concurrent Systems},year={1996},author={Patrice Godefroid and Patrice Godefroid},doi={10.1007/3-540-60761-7},pmid={null},pmcid={null},mag_id={2093709900},journal={null},abstract={This monograph is a revised version of the author's Ph.D. thesis, submitted to the University of Liège, Belgium, with Pierre Wolper as thesis advisor. The general pattern of this work, is to turn logi}}
@ARTICLE{Lind-Nielsen_1998,title={Verification of Large State/Event Systems Using Compositionality and Dependency Analysis},year={1998},author={Jørn Lind-Nielsen and Jørn Lind-Nielsen and Henrik Reif Andersen and Henrik Reif Andersen and Gerd Behrmann and Gerd Behrmann and Henrik Hulgaard and Henrik Hulgaard and Henrik Hulgaard and K. Kristoffersen and Kåre J. Kristoffersen and Kim Guldstrand Larsen and Kim Guldstrand Larsen},doi={10.1007/bfb0054173},pmid={null},pmcid={null},mag_id={2097267767},journal={null},abstract={A state/event model is a concurrent version of Mealy machines used for describing embedded reactive systems. This paper introduces a technique that uses compositionality and dependency analysis to significantly improve the efficiency of symbolic model checking of state/event models. This technique makes possible automated verification of large industrial designs with the use of only modest resources (less than one hour on a standard PC for a model with 1421 concurrent machines). The results of the paper are being implemented in the next version of the commercial tool visualSTATEℳ.}}
@ARTICLE{Harel_1987,title={Statecharts: A visual formalism for complex systems},year={1987},author={David Harel and David Harel},doi={10.1016/0167-6423(87)90035-9},pmid={null},pmcid={null},mag_id={2099529102},journal={Science of Computer Programming},abstract={We present a broad extension of the conventional formalism of state machines and state diagrams, that is relevant to the specification and design of complex discrete-event systems, such as multi-computer real-time systems, communication protocols and digital control units. Our diagrams, which we call statecharts, extend conventional state-transition diagrams with essentially three elements, dealing, respectively, with the notions of hierarchy, concurrency and communica- tion. These transform the language of state diagrams into a highly structured and economical description language. Statecharts are thus compact and expressiv-small diagrams can express complex behavior-as well as compositional and modular. When coupled with the capabilities of computerized graphics, statecharts enable viewing the description at different levels of detail, and make even very large specifications manageable and comprehensible. In fact, we intend to demonstrate here that statecharts counter many of the objections raised against conventional state diagrams, and thus appear to render specification by diagrams an attractive and plausible approach. Statecharts can be used either as a stand-alone behavioral description or as part of a more general design methodology that deals also with the system's other aspects, such as functional decomposi- tion and data-flow specification. We also discuss some practical experience that was gained over the last three years in applying the statechart formalism to the specification of a particularly complex system.}}
@ARTICLE{Bérard_2005,title={Comparison of the expressiveness of timed automata and time petri nets},year={2005},author={Béatrice Bérard and Béatrice Bérard and Franck Cassez and Franck Cassez and Serge Haddad and Serge Haddad and Didier Lime and Didier Lime and Olivier H. Roux and Olivier Roux},doi={10.1007/11603009_17},pmid={null},pmcid={null},mag_id={2099924351},journal={null},abstract={In this paper we consider the model of Time Petri Nets (TPN) where time is associated with transitions. We also consider Timed Automata (TA) as defined by Alur & Dill, and compare the expressiveness of the two models w.r.t. timed language acceptance and (weak) timed bisimilarity. We first prove that there exists a TA $\mathcal{A}$s.t. there is no TPN (even unbounded) that is (weakly) timed bisimilar to $\mathcal{A}$. We then propose a structural translation from TA to (1-safe) TPNs preserving timed language acceptance. Further on, we prove that the previous (slightly extended) translation also preserves weak timed bisimilarity for a syntactical subclass $\mathcal{T}_{syn}(\leq,\geq)$of TA. For the theory of TPNs, the consequences are: 1) TA, bounded TPNs and 1-safe TPNs are equally expressive w.r.t. timed language acceptance; 2) TA are strictly more expressive than bounded TPNs w.r.t. timed bisimilarity; 3) The subclass $\mathcal{T}_{syn}(\leq,\geq)$, bounded and 1-safe TPNs “a la Merlin” are equally expressive w.r.t. timed bisimilarity.}}
@ARTICLE{Hegyháti_2009,title={Practical infeasibility of cross-transfer in batch plants with complex recipes: S-graph vs MILP methods},year={2009},author={Máté Hegyháti and Máté Hegyháti and Thokozani Majozi and Thokozani Majozi and Tibor Holczinger and Tibor Holczinger and Ferenc Friedler and Ferenc Friedler},doi={10.1016/j.ces.2008.10.018},pmid={null},pmcid={null},mag_id={2101599642},journal={Chemical Engineering Science},abstract={null}}
@ARTICLE{Bohnenkamp_2006,title={MODEST: A Compositional Modeling Formalism for Hard and Softly Timed Systems},year={2006},author={Henrik Bohnenkamp and Henrik C. Bohnenkamp and Pedro R. D’Argenio and Pedro R. D'Argenio and Pedro R. D'Argenio and Holger Hermanns and Holger Hermanns and Joost-Pieter Katoen and Joost-Pieter Katoen},doi={10.1109/tse.2006.104},pmid={null},pmcid={null},mag_id={2102609194},journal={IEEE Transactions on Software Engineering},abstract={This paper presents MODEST (modeling and description language for stochastic timed systems), a formalism that is intended to support 1) the modular description of reactive systems' behavior while covering both 2) functional and 3) nonfunctional system aspects such as timing and quality-of-service constraints in a single specification. The language contains, features such as simple and structured data types, structuring mechanisms like parallel composition and abstraction, means to control the granularity of assignments, exception handling, and nondeterministic and random branching and timing. MODEST can be viewed as an overarching notation for a wide spectrum of models, ranging from labeled transition systems to timed automata (and probabilistic variants thereof), as well as prominent stochastic processes such as (generalized semi-) Markov chains and decision processes. The paper describes the design rationales and details of the syntax and semantics}}
@ARTICLE{Grimshaw_1993,title={An Introduction to the Bootstrap},year={1993},author={Scott D. Grimshaw and Scott D. Grimshaw and Bradley Efron and Robert Tibshirani},doi={null},pmid={null},pmcid={null},mag_id={2102865756},journal={null},abstract={Introduction The Accuracy of a Sample Mean Random Samples and Probabilities The Empirical Distribution Function and the Plug-In Principle Standard Errors and Estimated Standard Errors The Bootstrap Estimate of Standard Error Bootstrap Standard Errors: Some Examples More Complicated Data Structures Regression Models Estimates of Bias The Jackknife Confidence Intervals Based on Bootstrap "Tables" Confidence Intervals Based on Bootstrap Percentiles Better Bootstrap Confidence Intervals Permutation Tests Hypothesis Testing with the Bootstrap Cross-Validation and Other Estimates of Prediction Error Adaptive Estimation and Calibration Assessing the Error in Bootstrap Estimates A Geometrical Representation for the Bootstrap and Jackknife An Overview of Nonparametric and Parametric Inference Further Topics in Bootstrap Confidence Intervals Efficient Bootstrap Computations Approximate Likelihoods Bootstrap Bioequivalence Discussion and Further Topics Appendix: Software for Bootstrap Computations References}}
@ARTICLE{Santone_2003,title={Heuristic search + local model checking in selective mu-calculus},year={2003},author={Antonella Santone and Antonella Santone},doi={10.1109/tse.2003.1205179},pmid={null},pmcid={null},mag_id={2105233041},journal={IEEE Transactions on Software Engineering},abstract={Many tools for the automatic analysis or verification of finite-state distributed systems are based on construction of the global state graph of the system under consideration. Thus, they often fail because of the state explosion problem: the state space of a distributed system potentially increases exponentially in the number of its parallel components. To overcome this problem, we present a model checking procedure, based on the combination of heuristic searches with ideas taken from local model checking. We use heuristic mechanisms for exploration of the search space in order to avoid construction of the complete state graph.}}
@ARTICLE{Hansen_2001,title={LAO: a heuristic search algorithm that finds solutions with loops},year={2001},author={Eric A. Hansen and Eric A. Hansen and Shlomo Zilberstein and Shlomo Zilberstein},doi={10.1016/s0004-3702(01)00106-0},pmid={null},pmcid={null},mag_id={2105757562},journal={Artificial Intelligence},abstract={Classic heuristic search algorithms can find solutions that take the form of a simple path (A*), a tree, or an acyclic graph (AO*). In this paper, we describe a novel generalization of heuristic search, called LAO*, that can find solutions with loops. We show that LAO* can be used to solve Markov decision problems and that it shares the advantage heuristic search has over dynamic programming for other classes of problems. Given a start state, it can find an optimal solution without evaluating the entire state space.  2001 Elsevier Science B.V. All rights reserved.}}
@ARTICLE{Beasley_2000,title={Scheduling Aircraft Landings--The Static Case},year={2000},author={John E. Beasley and John E. Beasley and Mohan Krishnamoorthy and Mohan Krishnamoorthy and Yazid M. Sharaiha and Yazid M. Sharaiha and David Abramson and David Abramson},doi={10.1287/trsc.34.2.180.12302},pmid={null},pmcid={null},mag_id={2106614985},journal={Transportation Science},abstract={In this paper, we consider the problem of scheduling aircraft (plane) landings at an airport. This problem is one of deciding a landing time for each plane such that each plane lands within a predetermined time window and that separation criteria between the landing of a plane and the landing of all successive planes are respected. We present a mixed-integer zero--one formulation of the problem for the single runway case and extend it to the multiple runway case. We strengthen the linear programming relaxations of these formulations by introducing additional constraints. Throughout, we discuss how our formulations can be used to model a number of issues (choice of objective function, precedence restrictions, restricting the number of landings in a given time period, runway workload balancing) commonly encountered in practice. The problem is solved optimally using linear programming-based tree search. We also present an effective heuristic algorithm for the problem. Computational results for both the heuristic and the optimal algorithm are presented for a number of test problems involving up to 50 planes and four runways.}}
@ARTICLE{Hessel_2008,title={Testing real-time systems using UPPAAL},year={2008},author={Anders Hessel and Anders Hessel and Kim Guldstrand Larsen and Kim Guldstrand Larsen and Marius Mikučionis and Marius Mikucionis and Brian Nielsen and Brian Nielsen and Paul Pettersson and Paul Pettersson and Arne Skou and Arne Skou},doi={10.1007/978-3-540-78917-8_3},pmid={null},pmcid={null},mag_id={2107360681},journal={null},abstract={This chapter presents principles and techniques for modelbased black-box conformance testing of real-time systems using the Uppaal model-checking tool-suite. The basis for testing is given as a network of concurrent timed automata specified by the test engineer. Relativized input/output conformance serves as the notion of implementation correctness, essentially timed trace inclusion taking environment assumptions into account. Test cases can be generated offline and later executed, or they can be generated and executed online. For both approaches this chapter discusses how to specify test objectives, derive test sequences, apply these to the system under test, and assign a verdict.}}
@ARTICLE{Bonet_2001,title={HEURISTIC SEARCH PLANNER 2.0},year={2001},author={Blai Bonet and Blai Bonet and Héctor Geffner and Hector Geffner},doi={10.1609/aimag.v22i3.1576},pmid={null},pmcid={null},mag_id={2107607247},journal={Ai Magazine},abstract={We describe the hsp2.0 planning algorithm that entered the second planning contest held at the Fifth International Conference on Artificial Intelligence Planning and Scheduling (AIPS'00). hsp2.0 is a domain-independent planning algorithm that implements the family of heuristic search planners that are characterized by the state space that is searched (either progression or regression space), the search algorithm used (variants of best-first search), and the heuristic function extracted from the problem representation. This general planner implements a scheduler that tries different variants concurrently with different (time) resource bounds. We also describe how hsp2.0 can be used as an optimal (and near-optimal) planning algorithm and compare its performance with two other optimal planners, stan and blackbox.}}
@ARTICLE{Nagy-György_2007,title={Online scheduling with machine cost and rejection},year={2007},author={Judit Nagy-György and Judit Nagy-György and Cs. Imreh and Cs. Imreh},doi={10.1016/j.dam.2007.07.004},pmid={null},pmcid={null},mag_id={2114098982},journal={Discrete Applied Mathematics},abstract={In this paper we define and investigate a new scheduling model. In this new model the number of machines is not fixed; the algorithm has to purchase the used machines, moreover the jobs can be rejected. We show that the simple combinations of the algorithms used in the area of scheduling with rejections and the area of scheduling with machine cost are not constant competitive. We present a 2.618-competitive algorithm called OPTCOPY.}}
@ARTICLE{Nadal_2008,title={Contribution to the Optimization and Flexible Management of Chemical Processes},year={2008},author={Sergio Nadal and Sergio Ferrer Nadal},doi={null},pmid={null},pmcid={null},mag_id={2114540436},journal={null},abstract={La industria quimica ha experimentado en las ultimas decadas un aumento en la competencia por la cual las empresas se ven obligadas a adaptarse a un mercado cambiante y cada vez mas exigente. Aunque la globalizacion ha abierto nuevos mercados, ha incrementado tambien el numero de competidores, de tal manera que solo las empresas que usen las plantas mas integradas y eficientes podran mantenerse en el negocio. En este contexto global, el principal proposito de esta tesis es desarrollar metodos que exploten la flexibilidad de los procesos, con el objetivo de aumentar la eficiencia de las plantas y asegurar los requerimientos de seguridad y calidad de los productos. Esta tesis contribuye a la optimizacion y a la gestion de la produccion desde pequenas plantas que usen procesos discontinuos hasta grandes plantas de procesado continuo.En primer lugar, esta tesis trata la gestion de los procesos continuos en los que suelen fabricar productos muy similares a gran escala. La gran ventaja de los procesos continuos es que pueden conseguir mayor consistencia en la calidad de los productos y que pueden aprovechar las economias de escala que reducen los costes y residuos. Sin embargo, la industria quimica para mantenerse competitiva necesita adaptar continuamente sus procesos a las condiciones del mercado y de operacion. El sistema de control supervisor presentado en esta parte de la tesis disminuye el tiempo de reaccion frente a incidentes en los procesos continuos y re-optimiza la produccion en tiempo real, si existe posibilidad de mejora.A continuacion, esta tesis trata la gestion de los procesos semicontinuos que permiten una operacion mas flexible y personalizada. Los procesos semicontinuos operan con puestas en marcha y paradas periodicas para acomodar las frecuentes transiciones entre diferentes productos. Esta tesis presenta un nuevo concepto de fabricacion flexible que permite programar perfiles variables de velocidad de produccion dentro de cada campana de produccion.La mayor parte del trabajo de investigacion de esta tesis se dedica a la planificacion de la produccion en los procesos discontinuos por lotes, utilizados principalmente en la produccion de productos quimicos con alto valor anadido. Estos procesos ofrecen varias ventajas respecto a los procesos continuos y semicontinuos debido a la mayor flexibilidad para acomodar diversos productos, diferentes capacidades de produccion, y la posibilidad de realizar operaciones completamente diferentes en los mismos equipos. Sin embargo, la obtencion del plan de produccion optimo usando se complica al aumentar la complejidad de la planta y/o el numero de lotes a planificar. La simplificacion de considerar tiempos de transferencia despreciables es generalmente aceptada en la literatura para evitar la complejidad del manejo de las operaciones de transferencia. En cambio, esta tesis pretende resaltar el papel critico que juegan las operaciones de transferencia en la sincronizacion de tareas, y en la consiguiente determinacion de planes de produccion factibles.Siguiendo con los procesos por lotes, esta tesis demuestra que el uso del concepto de recetas flexibles mejora la operacion de los procesos en ambientes de produccion con mucha incertidumbre. La flexibilidad de las receta se considera como una oportunidad adicional, tanto para la planificacion de la produccion reactiva como preactiva, reduciendo el riesgo de llegar a resultados economicamente desfavorables.Finalmente, esta tesis presenta las plantas discontinuas sin tuberias como una alternativas a las plantas por lotes clasicas. En la busqueda de formas mas competitivas y efectivas de produccion, la flexibilidad para producir un elevado numero de productos en plantas por lotes es limitada debido a la necesidad de equipos fijos conectados por tuberias y frecuentes tareas de limpieza. Las plantas sin tuberias presentan una mayor flexibilidad ya que el material se transfiere entre estaciones de procesamiento usando equipos que se mueven dentro de la planta. El trabajo presentado en esta parte de la tesis contribuye a la mejora en la gestion de este tipo de plantas proponiendo una formulacion mas eficiente a las encontradas en la literatura que resuelve el problema de la planificacion de la produccion.En resumen, esta tesis desarrolla nuevas estrategias de modelado y metodos de resolucion encaminados al soporte de la toma de decisiones que explotan la flexibilidad intrinseca de los procesos quimicos. Las principales ventajas de cada una de las contribuciones de esta tesis se demuestran mediante su aplicacion a diferentes casos de estudio.}}
@ARTICLE{Holzmann_1997,title={The model checker SPIN},year={1997},author={Gerard J. Holzmann and Gerard J. Holzmann},doi={10.1109/32.588521},pmid={null},pmcid={null},mag_id={2115309705},journal={null},abstract={SPIN is an efficient verification system for models of distributed software systems. It has been used to detect design errors in applications ranging from high-level descriptions of distributed algorithms to detailed code for controlling telephone exchanges. The paper gives an overview of the design and structure of the verifier, reviews its theoretical foundation, and gives an overview of significant practical applications.}}
@ARTICLE{Tarjan_1972,title={Depth-First Search and Linear Graph Algorithms},year={1972},author={Robert E. Tarjan and Robert E. Tarjan},doi={10.1137/0201010},pmid={null},pmcid={null},mag_id={2118382442},journal={SIAM Journal on Computing},abstract={The value of depth-first search or “backtracking” as a technique for solving problems is illustrated by two examples. An improved version of an algorithm for finding the strongly connected components of a directed graph and at algorithm for finding the biconnected components of an undirect graph are presented. The space and time requirements of both algorithms are bounded by $k_1 V + k_2 E + k_3 $ for some constants $k_1 ,k_2 $, and $k_3 $, where V is the number of vertices and E is the number of edges of the graph being examined.}}
@ARTICLE{Fox_2003,title={PDDL2.1: an extension to PDDL for expressing temporal planning domains},year={2003},author={Maria Fox and Maria Fox and Derek Long and Derek Long},doi={10.1613/jair.1129},pmid={null},pmcid={null},mag_id={2119709400},journal={Journal of Artificial Intelligence Research},abstract={In recent years research in the planning community has moved increasingly towards application of planners to realistic problems involving both time and many types of resources. For example, interest in planning demonstrated by the space research community has inspired work in observation scheduling, planetary rover exploration and spacecraft control domains. Other temporal and resource-intensive domains including logistics planning, plant control and manufacturing have also helped to focus the community on the modelling and reasoning issues that must be confronted to make planning technology meet the challenges of application.

The International Planning Competitions have acted as an important motivating force behind the progress that has been made in planning since 1998. The third competition (held in 2002) set the planning community the challenge of handling time and numeric resources. This necessitated the development of a modelling language capable of expressing temporal and numeric properties of planning domains. In this paper we describe the language, PDDL2.1, that was used in the competition. We describe the syntax of the language, its formal semantics and the validation of concurrent plans. We observe that PDDL2.1 has considerable modelling power -- exceeding the capabilities of current planning technology -- and presents a number of important challenges to the research community.}}
@ARTICLE{Ghaeli_2005,title={Petri-net based formulation and algorithm for short-term scheduling of batch plants},year={2005},author={M. Ghaeli and M. Ghaeli and Parisa A. Bahri and Parisa A. Bahri and Peter L. Lee and Peter L. Lee and Tianlong Gu and Tianlong Gu},doi={10.1016/j.compchemeng.2004.08.025},pmid={null},pmcid={null},mag_id={2120259938},journal={Computers & Chemical Engineering},abstract={null}}
@ARTICLE{Bolognesi_1987,title={Introduction to the ISO specification language LOTOS},year={1987},author={Tommaso Bolognesi and Tommaso Bolognesi and Ed Brinksma and Ed Brinksma},doi={10.1016/0169-7552(87)90085-7},pmid={null},pmcid={null},mag_id={2121372686},journal={Computer Networks and Isdn Systems},abstract={LOTOS is a specification language that has been specifically developed for the formal description of the OSI (Open Systems Interconnection) architecture, although it is applicable to distributed, concurrent systems in general. In LOTOS a system is seen as a set of processes which interact and exchange data with each other and with their environment. LOTOS is expected to become an ISO international standard by 1988.}}
@ARTICLE{Mehta_1998,title={Predictable scheduling of a job shop subject to breakdowns},year={1998},author={Sanjay V. Mehta and Sanjay Mehta and Reha Uzsoy and Reha Uzsoy and Reha Uzsoy},doi={10.1109/70.678447},pmid={null},pmcid={null},mag_id={2122549838},journal={null},abstract={Schedule modification may delay or render infeasible the execution of external activities planned on the basis of the predictive schedule. Thus it is of interest to develop predictive schedules which can absorb disruptions without affecting planned external activities, while maintaining high shop performance. We present a predictable scheduling approach where the predictive schedule is built with such objectives. The procedure inserts additional idle time into the schedule to absorb the impacts of breakdowns. The amount and location of the additional idle time is determined from the breakdown and repair distributions as well as the structure of the predictive schedule. The effects of disruptions on planned support activities are measured by the deviations of job completion times in the realized schedule from those in the predictive schedule. We apply our approach to minimizing maximum lateness in a job shop environment with random machine breakdowns, and show that it provides high predictability with minor sacrifices in shop performance.}}
@ARTICLE{Pinedo_1994,title={Scheduling: Theory, Algorithms, and Systems},year={1994},author={Michael Pinedo},doi={null},pmid={null},pmcid={null},mag_id={2122967269},journal={null},abstract={This book on scheduling covers theoretical models as well as scheduling problems in the real world. Author Michael Pinedo also includes a CD that contains slide-shows from industry and movies dealing with implementations of scheduling systems. The book consists of three parts. The first part focuses on deterministic scheduling with the associated combinatorial problems. The second part covers probabilistic scheduling models. In this part it is assumed that processing times and other problem data are not known in advance. The third part deals with scheduling in practice. It covers heuristics that are popular with practitioners and discusses system design and development issues. Each chapter contains a series of computational and theoretical exercises. This book is of interest to theoreticians and practitioners alike. Graduate students in operations management, operations research, industrial engineering and computer science will find the book to be an accessible and invaluable resource. Scheduling will serve as an essential reference for professionals working on scheduling problems in manufacturing and computing environments. Michael Pinedo is the Julius Schlesinger Professor of Operations Management at New York University.}}
@ARTICLE{Romero_2004,title={Scheduling intermediate storage multipurpose batch plants using the S-graph},year={2004},author={Javier Romero and Javier Romero and Luís Puigjaner and Luis Puigjaner and Luis Puigjaner and Tibor Holczinger and Tibor Holczinger and Ferenc Friedler and Ferenc Friedler},doi={10.1002/aic.10036},pmid={null},pmcid={null},mag_id={2123890774},journal={Aiche Journal},abstract={A graph theoretical approach is proposed for the optimal scheduling of multipurpose batch plants when constraints on intermediate storage allocation are met. The novel S-graph representation is extended and combined with a set of rationales to consider intermediate storage policy in production scheduling. This set of rationales accelerates the optimization procedure, reducing the searching tree from the very beginning, without losing optimality. It is assumed that the storage units can be commonly used throughout the plant to achieve maximum plant flexibility. Therefore, the problem solved suggests the more general batch-process transfer strategy, common intermediate storage policy (CIS). This policy is suggested for more flexible use of intermediate storage units. The accuracy of this proposed algorithm is tested with an exhaustive B&B search algorithm. The methodology is compared with other CIS algorithms and is applied to solve several case studies. The benefits of considering this kind of storage coupled with the use of the proposed algorithm are discussed through motivating examples. © 2004 American Institute of Chemical Engineers AIChE J, 50: 403– 417, 2004}}
@ARTICLE{Abdulla_1996,title={General decidability theorems for infinite-state systems},year={1996},author={Parosh Aziz Abdulla and Parosh Aziz Abdulla and Kārlis Čerāns and Karlis Cerans and Bengt Jönsson and Bengt Jonsson and Yih-Kuen Tsay and Yih-Kuen Tsay},doi={10.1109/lics.1996.561359},pmid={null},pmcid={null},mag_id={2123910665},journal={null},abstract={Over the last few years there has been an increasing research effort directed towards the automatic verification of infinite state systems. This paper is concerned with identifying general mathematical structures which can serve as sufficient conditions for achieving decidability. We present decidability results for a class of systems (called well-structured systems), which consist of a finite control part operating on an infinite data domain. The results assume that the data domain is equipped with a well-ordered and well-founded preorder such that the transition relation is "monotonic" (is a simulation) with respect to the preorder. We show that the following properties are decidable for well-structured systems: reachability; eventuality; and simulation. We also describe how these general principles subsume several decidability results from the literature about timed automata, relational automata, Petri nets, and lossy channel systems.}}
@ARTICLE{Edelkamp_2009,title={Survey on Directed Model Checking},year={2009},author={Stefan Edelkamp and Stefan Edelkamp and Viktor Schuppan and Viktor Schuppan and Dragan Bošnački and Dragan Bošnački and Anton Wijs and Anton Wijs and Ansgar Fehnker and Ansgar Fehnker and Husain Aljazzar and Husain Aljazzar},doi={10.1007/978-3-642-00431-5_5},pmid={null},pmcid={null},mag_id={2129659049},journal={null},abstract={This article surveys and gives historical accounts to the algorithmic essentials of directed model checking , a promising bug-hunting technique to mitigate the state explosion problem. In the enumeration process, successor selection is prioritized. We discuss existing guidance and methods to automatically generate them by exploiting system abstractions. We extend the algorithms to feature partial-order reduction and show how liveness problems can be adapted by lifting the search space. For deterministic, finite domains we instantiate the algorithms to directed symbolic, external and distributed search. For real-time domains we discuss the adaption of the algorithms to timed automata and for probabilistic domains we show the application to counterexample generation. Last but not least, we explain how directed model checking helps to accelerate finding solutions to scheduling problems.}}
@ARTICLE{Black_2000,title={Modeling and marshaling: making tests from model checker counterexamples},year={2000},author={Paul E. Black and Paul E. Black},doi={10.1109/dasc.2000.886880},pmid={null},pmcid={null},mag_id={2130123065},journal={null},abstract={Recently model checkers have been applied to software areas such as analyzing protocols and algorithms, measuring test adequacy, and generating abstract tests from formal models. When using model checkers to generate tests, the generated tests are execution traces of the models. Thus the type, occurrence, and order of variables, calls, and events in the execution traces are intimately tied to the choice of modeling representation. We briefly review how to use a model checker to generate tests from a high-level representation, such as MATLAB(R), UML, or SCR. Since the model checker uses a particular general model, the analyst has choices about how a piece of software may be modeled. We list some choices and discuss their advantages and disadvantages. We also describe a program to marshal model variables from resultant model checker traces and translate them into function calls, program variables, and other software artifacts.}}
@ARTICLE{Larsen_2001,title={As Cheap as Possible: Efficient Cost-Optimal Reachability for Priced Timed Automata},year={2001},author={Kim Guldstrand Larsen and Kim Guldstrand Larsen and Gerd Behrmann and Gerd Behrmann and Ed Brinksma and Ed Brinksma and Ansgar Fehnker and Ansgar Fehnker and Thomas Hune and Thomas Hune and Paul Pettersson and Paul Pettersson and Judi Romijn and Judi Romijn},doi={10.1007/3-540-44585-4_47},pmid={null},pmcid={null},mag_id={2130664212},journal={null},abstract={In this paper we present an algorithm for efficiently computing optimal cost of reaching a goal state in the model of Linearly Priced Timed Automata (LPTA). The central contribution of this paper is a priced extension of so-called zones. This, together with a notion of facets of a zone, allows the entire machinery for symbolic reachability for timed automata in terms of zones to be lifted to cost-optimal reachability using priced zones. We report on experiments with a cost-optimizing extension of Uppaal on a number of examples.}}
@ARTICLE{Enoiu_2013,title={Using Logic Coverage to Improve Testing Function Block Diagrams},year={2013},author={Eduard Paul Enoiu and Eduard Paul Enoiu and Daniel Sundmark and Daniel Sundmark and Paul Pettersson and Paul Pettersson},doi={10.1007/978-3-642-41707-8_1},pmid={null},pmcid={null},mag_id={2131820522},journal={null},abstract={In model-driven development, testers are often focusing on functional model-level testing, enabling verification of design models against their specifications. In addition, in safety-critical software development, testers are required to show that tests cover the structure of the implementation. Testing cost and time savings could be achieved if the process of deriving test cases for logic coverage is automated and provided test cases are ready to be executed. The logic coverage artifacts, i.e., predicates and clauses, are required for different logic coverage, e.g., MC/DC. One way of dealing with test case generation for ensuring logic coverage is to approach it as a model-checking problem, such that model-checking tools automatically create test cases. We show how logic coverage criteria can be formalized and used by a model-checker to provide test cases for ensuring coverage on safety-critical software described in the Function Block Diagram programming language. Based on our experiments, this approach, supported by a tool chain, is an applicable and useful way of generating test cases for covering Function Block Diagrams.}}
@ARTICLE{Ruys_1998,title={Experience with Literate Programming in the Modelling and Validation of Systems},year={1998},author={Theo C. Ruys and Theo C. Ruys and Ed Brinksma and Ed Brinksma},doi={10.1007/bfb0054185},pmid={null},pmcid={null},mag_id={2131983024},journal={null},abstract={This paper discusses our experience with literate programming tools in the realm of the modelling and validation of systems. We propose the use of literate programming techniques to structure and control the validation trajectory. The use of literate programming is illustrated by means of a running example using Promela and Spin. The paper can also be read as a tutorial on the application of literate programming to formal methods.}}
@ARTICLE{Lönn_1997,title={Formal verification of a TDMA protocol start-up mechanism},year={1997},author={Henrik Lönn and H. Lonn and Paul Pettersson and P. Pettersson and Paul Pettersson},doi={10.1109/prfts.1997.640153},pmid={null},pmcid={null},mag_id={2133740077},journal={null},abstract={This paper presents a formal verification of the start-up algorithm of the DACAPO protocol. The protocol uses TDMA (Time Division Multiple Access) bus arbitration. It was verified that an ensemble of four communicating stations becomes synchronized and operational within a bounded time from an arbitrary initial state. The system model included a clock drift corresponding to /spl plusmn/10/sup -3/. The protocol was modeled using a network of timed automata, and verification was performed using the symbolic model checker UPPAAL.}}
@ARTICLE{Jee_2009,title={A data flow-based structural testing technique for FBD programs},year={2009},author={Eunkyoung Jee and Eunkyoung Jee and Junbeom Yoo and Junbeom Yoo and Sungdeok Cha and Sungdeok Cha and Doo‐Hwan Bae and Doo-Hwan Bae},doi={10.1016/j.infsof.2009.01.003},pmid={null},pmcid={null},mag_id={2134413894},journal={Information & Software Technology},abstract={null}}
@ARTICLE{Abdeddaïm_2001,title={Job-Shop Scheduling Using Timed Automata},year={2001},author={Yasmina Abdeddaïm and Yasmina Abdeddaïm and Oded Maler and Oded Maler},doi={10.1007/3-540-44585-4_46},pmid={null},pmcid={null},mag_id={2134659903},journal={null},abstract={In this paper we show how the classical job-shop scheduling problem can be modeled as a special class of acyclic timed automata. Finding an optimal schedule corresponds, then, to finding a shortest (in terms of elapsed time) path in the timed automaton. This representation provides new techniques for solving the optimization problem and, more importantly, it allows to model naturally more complex dynamic resource allocation problems which are not captured so easily in traditional models of operation research. We present several algorithms and heuristics for finding the shortest paths in timed automata and test their implementation in the tool Kronos on numerous benchmark examples.}}
@ARTICLE{Corbett_2000,title={Bandera: extracting finite-state models from Java source code},year={2000},author={James C. Corbett and James C. Corbett and James C. Corbett and James C. Corbett and Matthew B. Dwyer and Matthew B. Dwyer and John Hatcliff and John Hatcliff and Shawn Laubach and Shawn Laubach and Corina S. Pǎsǎreanu and Corina S. Păsăreanu and Corina S. Pasareanu and Corina S. Păsăreanu and . Robby and Robby and Hongjun Zheng and Hongjun Zheng},doi={10.1145/337180.337234},pmid={null},pmcid={null},mag_id={2135274583},journal={null},abstract={Finite-state verification techniques, such as model checking, have shown promise as a cost-effective means for finding defects in hardware designs. To date, the application of these techniques to software has been hindered by several obstacles. Chief among these is the problem of constructing a finite-state model that approximates the executable behavior of the software system of interest. Current best-practice involves hand-construction of models which is expensive (prohibitive for all but the smallest systems), prone to errors (which can result in misleading verification results), and difficult to optimize (which is necessary to combat the exponential complexity of verification algorithms).  In this paper, we describe an integrated collection of program analysis and transformation components, called Bandera, that enables the automatic extraction of safe, compact finite-state models from program source code. Bandera takes as input Java source code and generates a program model in the input language of one of several existing verification tools; Bandera also maps verifier outputs back to the original source code. We discuss the major components of Bandera and give an overview of how it can be used to model check correctness properties of Java programs.}}
@ARTICLE{Bohnenkamp_2003,title={On integrating the MOBIUS and MODEST modeling tools},year={2003},author={Henrik Bohnenkamp and H. Bohnenkamp and Henrik C. Bohnenkamp and T. Courtney and T. Courtney and David Daly and David M. Daly and S. Derisavi and Salem Derisavi and Holger Hermanns and Holger Hermanns and Joost-Pieter Katoen and Joost-Pieter Katoen and Ric Klaren and Ric Klaren and Vinh Vi Lam and Vinh Lam and William H. Sanders and William H. Sanders},doi={10.1109/dsn.2003.1209980},pmid={null},pmcid={null},mag_id={2136326369},journal={null},abstract={frame-work components. This translation preserves the structureof the models, allowing efﬁcient solutions. The frameworkis implementedin the toolby a well-deﬁnedAbstract Func-tional Interface (AFI). Models and solution techniques in-teract with one another through the use of the standardinterface, allowing them to interact with M}}
@ARTICLE{David_2000,title={Modelling and analysis of a commercial field bus protocol},year={2000},author={Albert David and Alexandre David and Wang Yi and Wang Yi},doi={10.1109/emrts.2000.854004},pmid={null},pmcid={null},mag_id={2137382450},journal={null},abstract={We report on an industrial application of UPPAAL, in which a commercial field bus protocol (AF100) is modelled and analysed using the tool. During the case study, a number of imperfections in the protocol logic and its implementation are found and the error sources are debugged based on abstract models of the protocol; respective improvements have been suggested. The authors summarize their experiences in dealing with the complexity of the protocol using various modelling and abstraction features provided in UPPAAL. As an example, they study the bus coupler of AF100, which serves as the data link layer of the protocol.}}
@ARTICLE{Clarke_1989,title={Compositional model checking},year={1989},author={Edmund M. Clarke and Edmund M. Clarke and David E. Long and David E. Long and Kenneth L. McMillan and Kenneth L. McMillan},doi={10.1109/lics.1989.39190},pmid={null},pmcid={null},mag_id={2137467159},journal={null},abstract={A method is described for reducing the complexity of temporal logic model checking in systems composed of many parallel processes. The goal is to check properties of the components of a system and then deduce global properties from these local properties. The main difficulty with this type of approach is that local properties are often not preserved at the global level. The authors present a general framework for using additional interface processes to model the environment for a component. These interface processes are typically much simpler than the full environment of the component. By composing a component with its interface processes and then checking properties of this composition, the authors can guarantee that these properties will be preserved at the global level. They give two example compositional systems based on the logic CTL. >}}
@ARTICLE{Buttazzo_1997,title={Hard Real-Time Computing Systems: Predictable Scheduling Algorithms and Applications},year={1997},author={Giorgio Buttazzo and Giorgio Buttazzo},doi={null},pmid={null},pmcid={null},mag_id={2137784941},journal={null},abstract={Hard Real-Time Computing Systems: Predictable Scheduling Algorithms and Applications is a basic treatise on real-time computing, with particular emphasis on predictable scheduling algorithms. It introduces the fundamental concepts of real-time computing, illustrates the most significant results in the field, and provides the essential methodologies for designing predictable computing systems which can be used to support critical control applications. This volume serves as a textbook for advanced level courses on the topic. Each chapter provides basic concepts, which are followed by algorithms that are illustrated with concrete examples, figures and tables. Exercises are included with each chapter and solutions are given at the end of the book. The book also provides an excellent reference for those interested in real-time computing for designing and/or developing predictable control applications.}}
@ARTICLE{Kleer_1987,title={Diagnosing multiple faults},year={1987},author={Johan de Kleer and J. de Kleer and Brian Williams and Brian C. Williams},doi={10.1016/0004-3702(87)90063-4},pmid={null},pmcid={null},mag_id={2144386448},journal={Artificial Intelligence},abstract={null}}
@ARTICLE{Čerāns_1994,title={Deciding Properties of Integral Relational Automata},year={1994},author={Kārlis Čerāns and Karlis Cerans},doi={10.1007/3-540-58201-0_56},pmid={null},pmcid={null},mag_id={2146250272},journal={null},abstract={This paper investigates automated model checking possibilities for CTL* formulae over infinite transition systems represented by relational automata (RA). The general model checking problem for CTL* formulae over RA is shown undecidable, the undecidability being observed already on the class of Restricted CTL formulae. The decidability result, however, is obtained for another substantial subset of the logic, called A-CTL*+, which includes all ”linear time” formulae.}}
@ARTICLE{Brinksma_2000,title={Verification and Optimization of a PLC Control Schedule},year={2000},author={Ed Brinksma and Ed Brinksma and Angelika Mader and Angelika Mader},doi={10.1007/10722468_5},pmid={null},pmcid={null},mag_id={2146446489},journal={null},abstract={We report on the use of the SPIN model checker for both the verification of a process control program and the derivation of optimal control schedules. This work was carried out as part of a case study for the EC VHS project (Verification of Hybrid Systems), in which the program for a Programmable Logic Controller (PLC) of an experimental chemical plant had to be designed and verified. The intention of our approach was to see how much could be achieved here using the standard model checking environment of SPIN/Promela. As the symbolic calculations of real-time model checkers can be quite expensive it is interesting to try and exploit the efficiency of established non-real-time model checkers like SPIN in those cases where promising work-arounds seem to exist. In our case we handled the relevant real-time properties of the PLC controller using a time-abstraction technique; for the scheduling we implemented in Promela a so-called variable time advance procedure. For this case study these techniques proved sufficient to verify the design of the controller and derive (time-)optimal schedules with reasonable time and space requirements.}}
@ARTICLE{Herroelen_2005,title={Project scheduling under uncertainty: survey and research potentials},year={2005},author={Willy Herroelen and Willy Herroelen and Roel Leus and Roel Leus},doi={10.1016/j.ejor.2004.04.002},pmid={null},pmcid={null},mag_id={2147507583},journal={European Journal of Operational Research},abstract={The vast majority of the research efforts in project scheduling assume complete information about the scheduling problem to be solved and a static deterministic environment within which the pre-computed baseline schedule will be executed. However, in the real world, project activities are subject to considerable uncertainty, which is gradually resolved during project execution. In this survey we review the fundamental approaches for scheduling under uncertainty: reactive scheduling, stochastic project scheduling, fuzzy project scheduling, robust (proactive) scheduling and sensitivity analysis. We discuss the potentials of these approaches for scheduling under uncertainty projects with deterministic network evolution structure.}}
@ARTICLE{Santone_2011,title={Clone detection through process algebras and Java bytecode},year={2011},author={Antonella Santone and Antonella Santone},doi={10.1145/1985404.1985422},pmid={null},pmcid={null},mag_id={2149955986},journal={null},abstract={In this paper we present a formal method-based approach in detecting source code clones by means of analysing and comparing the Java Bytecode that is produced when the source code is compiled. A preliminary investigation has been also conducted to assess the validity of the proposed approach.}}
@ARTICLE{Bloem_2000,title={Symbolic guided search for CTL model checking},year={2000},author={Roderick Bloem and Roderick Bloem and Kavita Ravi and Kavita Ravi and Fabio Somenzi and Fabio Somenzi},doi={10.1145/337292.337306},pmid={null},pmcid={null},mag_id={2150309803},journal={null},abstract={CTL model checking of complex systems often suffers from the state-explosion problem. We propose using Symbolic Guided Search to avoid difficult-to-represent sections of the state space and prevent state explosion from occurring.  Symbolic Guided Search applies hints to guide the exploration of the state space. In this way, the size of the BDDs involved in the computation is controlled, and the truth of a property may be decided before all states have been explored. In this work, we show how hints can be used in the computation of nested fixpoints. We show how to use hints to obtain overapproximations useful for greatest fixpoints, and we present the first results for backward search. Our experiments demonstrate the effectiveness of our approach.}}
@ARTICLE{Cassez_2000,title={The Impressive Power of Stopwatches},year={2000},author={Franck Cassez and Franck Cassez and Kim Guldstrand Larsen and Kim Guldstrand Larsen},doi={10.1007/3-540-44618-4_12},pmid={null},pmcid={null},mag_id={2150377894},journal={null},abstract={In this paper we define and study the class of stopwatch automata which are timed automata augmented with stopwatches and unobservable behaviour. In particular, we investigate the expressive power of this class of automata, and show as a main result that any finite or infinite timed language accepted by a linear hybrid automaton is also acceptable by a stopwatch automaton. The consequences of this result are two-fold: firstly, it shows that the seemingly minor upgrade from timed automata to stopwatch automata immediately yields the full expressive power of linear hybrid automata. Secondly, reachability analysis of linear hybrid automata may effectively be reduced to reachability analysis of stopwatch automata. This, in turn, may be carried out using an easy (over-approximating) extension of the efficient reachability analysis for timed automata to stopwatch automata. We report on preliminary experiments on analyzing translations of linear hybrid automata using a stopwatch-extension of the real-time verification tool UPPAAL.}}
@ARTICLE{Berthomieu_1991,title={Modeling and verification of time dependent systems using time Petri nets},year={1991},author={Bernard Berthomieu and Bernard Berthomieu and Michel Diaz and Michel Diaz},doi={10.1109/32.75415},pmid={null},pmcid={null},mag_id={2151612633},journal={IEEE Transactions on Software Engineering},abstract={A description and analysis of concurrent systems, such as communication systems, whose behavior is dependent on explicit values of time is presented. An enumerative method is proposed in order to exhaustively validate the behavior of P. Merlin's time Petri net model, (1974). This method allows formal verification of time-dependent systems. It is applied to the specification and verification of the alternating bit protocol as a simple illustrative example. >}}
@ARTICLE{Lambrechts_2008,title={A tabu search procedure for developing robust predictive project schedules},year={2008},author={Olivier Lambrechts and Olivier Lambrechts and Erik Demeulemeester and Erik Demeulemeester and Erik Demeulemeester and Willy Herroelen and Willy Herroelen},doi={10.1016/j.ijpe.2007.02.003},pmid={null},pmcid={null},mag_id={2151991671},journal={International Journal of Production Economics},abstract={Proactive scheduling aims at the generation of robust baseline schedules that are as much as possible protected against disruptions that may occur during project execution. In this paper, we focus on disruptions caused by stochastic resource availabilities and aim at generating stable baseline schedules. A schedule’s robustness (stability) is measured by the weighted deviation between the planned and the actually realized activity starting times during project execution. We present a tabu search procedure that operates on a surrogate, free slack based objective function. Its eectiveness is demonstrated by extensive computational results obtained on a set of randomly generated test instances.}}
@ARTICLE{Whalen_2013,title={Observable modified Condition/Decision coverage},year={2013},author={Michael W. Whalen and Michael W. Whalen and Dongjiang You and Mats P. E. Heimdahl and Dongjiang You and Matt Staats and Mats P. E. Heimdahl and Matt Staats},doi={10.1109/icse.2013.6606556},pmid={null},pmcid={null},mag_id={2152664489},journal={null},abstract={In many critical systems domains, test suite adequacy is currently measured using structural coverage metrics over the source code. Of particular interest is the modified condition/decision coverage (MC/DC) criterion required for, e.g., critical avionics systems. In previous investigations we have found that the efficacy of such test suites is highly dependent on the structure of the program under test and the choice of variables monitored by the oracle. MC/DC adequate tests would frequently exercise faulty code, but the effects of the faults would not propagate to the monitored oracle variables.     In this report, we combine the MC/DC coverage metric with a notion of observability that helps ensure that the result of a fault encountered when covering a structural obligation propagates to a monitored variable; we term this new coverage criterion Observable MC/DC (OMC/DC). We hypothesize this path requirement will make structural coverage metrics 1.) more effective at revealing faults, 2.) more robust to changes in program structure, and 3.) more robust to the choice of variables monitored. We assess the efficacy and sensitivity to program structure of OMC/DC as compared to masking MC/DC using four subsystems from the civil avionics domain and the control logic of a microwave. We have found that test suites satisfying OMC/DC are significantly more effective than test suites satisfying MC/DC, revealing up to 88% more faults, and are less sensitive to program structure and the choice of monitored variables.}}
@ARTICLE{Enoiu_2013,title={Model-Based Test Suite Generation for Function Block Diagrams Using the UPPAAL Model Checker},year={2013},author={Eduard Paul Enoiu and Eduard Paul Enoiu and Daniel Sundmark and Daniel Sundmark and Paul Pettersson and Paul Pettersson},doi={10.1109/icstw.2013.27},pmid={null},pmcid={null},mag_id={2153268462},journal={null},abstract={A method for model-based test generation of safety-critical embedded applications using Programmable Logic Controllers and implemented in a programming language such as Function Block Diagram (FBD) is described. The FBD component model is based on the IEC 1131 standard and it is used primarily for embedded systems, in which timeliness is an important property to be tested. Our method involves the transformation of FBD programs with timed annotations into timed automata models which are used to automatically generate test suites. Specifically we demonstrate how to use model transformation for formalization and model-checking of FBD programs using the UPPAAL tool. Many benefits emerge from this method, including the ability to automatically generate test suites from a formal model in order to ensure compliance to strict quality requirements including unit testing and specific coverage measurements. The approach is experimentally assessed on a train control system in terms of consumed resources.}}
@ARTICLE{Norström_1999,title={Timed automata as task models for event-driven systems},year={1999},author={Christer Norström and Christer Norström and Anders Wall and Anders Wall and Wang Yi and Wang Yi},doi={10.1109/rtcsa.1999.811218},pmid={null},pmcid={null},mag_id={2153269726},journal={null},abstract={We extend the classic model of timed automata with a notion of real-time tasks. The main idea is to associate each discrete transition in a timed automaton with a task (an executable program). Intuitively, a discrete transition in an extended timed automaton denotes an event releasing a task and the guard on the transition specifies all the possible arrival times of the event (instead of the so-called minimal inter-arrival time). This yields a general model for hard real-time systems in which tasks may be periodic or non-periodic. We show that the schedulability problem for the extended model can be transformed into a reachability problem for standard timed automata, and thus it is decidable. This allows us to apply model-checking tools for timed automata to schedulability analysis for event-driven systems. In addition, based on the same model of a system, we may use the tools to verify other properties of the system (e.g. safety and functionality). This unifies schedulability analysis and formal verification in one framework. We present an example where the model-checker UPPAAL is applied to check the schedulability and safety properties of a control program for a turning lathe.}}
@ARTICLE{Helmink_1994,title={Proof-checking a data link protocol},year={1994},author={Leen Helmink and L. Helmink and M.P.A. Sellink and M.P.A. Sellink and Frits Vaandrager and Frits W. Vaandrager},doi={10.1007/3-540-58085-9_75},pmid={null},pmcid={null},mag_id={2153945968},journal={null},abstract={A data link protocol developed and used by Philips Electronics is modeled and verified using I/O automata theory. Correctness is computer-checked with the Coq proof development system.}}
@ARTICLE{Maravelias_2003,title={New General Continuous-Time State−Task Network Formulation for Short-Term Scheduling of Multipurpose Batch Plants},year={2003},author={Christos T. Maravelias and Christos T. Maravelias and Ignacio E. Grossmann and Ignacio E. Grossmann},doi={10.1016/s1570-7946(03)80117-7},pmid={null},pmcid={null},mag_id={2155876421},journal={Computer-aided chemical engineering},abstract={null}}
@ARTICLE{Mendez_2006,title={State-of-the-art review of optimization methods for short-term scheduling of batch processes},year={2006},author={Carlos Alberto Mendez and Carlos A. Méndez and Carlos A. Méndez and Jaime Cerdá and Jaime Cerdá and Ignacio E. Grossmann and Ignacio E. Grossmann and Iiro Harjunkoski and Iiro Harjunkoski and Marco Fahl and Marco Fahl},doi={10.1016/j.compchemeng.2006.02.008},pmid={null},pmcid={null},mag_id={2155900361},journal={Computers & Chemical Engineering},abstract={There has been significant progress in the area of short-term scheduling of batch processes, including the solution of industrial-sized problems, in the last 20 years. The main goal of this paper is to provide an up-to-date review of the state-of-the-art in this challenging area. Main features, strengths and limitations of existing modeling and optimization techniques as well as other available major solution methods are examined through this paper. We first present a general classification for scheduling problems of batch processes as well as for the corresponding optimization models. Subsequently, the modeling of representative optimization approaches for the different problem types are introduced in detail, focusing on both discrete and continuous time models. A comparison of effectiveness and efficiency of these models is given for two benchmarking examples from the literature. We also discuss two real-world applications of scheduling problems that cannot be readily accommodated using existing methods. For the sake of completeness, other alternative solution methods applied in the field of scheduling are also reviewed, followed by a discussion related to solving large-scale problems through rigorous optimization approaches. Finally, we list available academic and commercial software, and briefly address the issue of rescheduling capabilities of the various optimization approaches as well as important extensions that go beyond short-term batch scheduling.}}
@ARTICLE{Booch_1998,title={The Unified Modeling Language User Guide},year={1998},author={Grady Booch and Grady Booch and James Rumbaugh and James E. Rumbaugh and Ivar Jacobson and Ivar Jacobson},doi={null},pmid={null},pmcid={null},mag_id={2159765281},journal={null},abstract={In The Unified Modeling Language User Guide, the original developers of the UML--Grady Booch, James Rumbaugh, and Ivar Jacobson--provide a tutorial to the core aspects of the language in a two-color format designed to facilitate learning. Starting with a conceptual model of the UML, the book progressively applies the UML to a series of increasingly complex modeling problems across a variety of application domains. This example-driven approach helps readers quickly understand and apply the UML. For more advanced developers, the book includes a learning track focused on applying the UML to advanced modeling problems.With The Unified Modeling Language User Guide, readers will:Understand what the UML is, what it is not, and why it is relevant to the development of software-intensive systemsMaster the vocabulary, rules, and idioms of the UML in order to "speak" the language effectivelyLearn how to apply the UML to a number of common modeling problemsSee illustrations of the UML's use interspersed with use cases for specific UML features, andGain insight into the UML from the original creators of the UML.}}
@ARTICLE{Bohnenkamp_2007,title={Motor: The MoDeST Tool Environment},year={2007},author={Henrik Bohnenkamp and Henrik C. Bohnenkamp and H. Bohnenkamp and Holger Hermanns and Holger Hermanns and Joost-Pieter Katoen and Joost-Pieter Katoen},doi={10.1007/978-3-540-71209-1_38},pmid={null},pmcid={null},mag_id={2160227530},journal={null},abstract={The MoDeST Tool Environment (MOTOR) is a tool to facilitate the transformation, analysis and validation of modest models. modest is a modelling language to describe stochastic real-time systems. MOTOR implements the formal semantics of modest and is designed to transform and abstract modest specifications such that analysis can be carried out by third-party tools. For the time being, a fragment of MoDeST can be model-checked using CADP. The main analytical workhorse behind motor is discrete-event simulation, which is provided by the Mobius performance evaluation environment. We are experimenting with prototypical connections to the real-time model checker Uppaal.}}
@ARTICLE{Parashkevov_1996,title={ARC-a tool for efficient refinement and equivalence checking for CSP},year={1996},author={Atanas Parashkevov and A.N. Parashkevov and Jay Yantchev and J. Yantchev},doi={10.1109/icapp.1996.562859},pmid={null},pmcid={null},mag_id={2160686642},journal={null},abstract={The paper presents the design and implementation of ARC-a tool for automated verification of concurrent systems. The tool is based on the untimed CSP language, its semantic models and theory of refinement. We alleviate the combinatorial explosion problem using ordered binary decision diagrams (OBDDs) for the internal representation of complex data structures-sets and labeled transition systems (LTS). The semantically complex external choice operator is translated into the corresponding LTS using an optimized algorithm. This and some other implementation improvements allow verifying systems with up to 10/sup 33/ states, which is consistent with the capabilities of other OBDD based approaches. Compared to two existing CSP tools, FDR and MRC, ARC has fewer language restrictions and is more memory efficient. A performance comparison based on the n-schedulers and dining philosophers problems suggests that the checking algorithm of ARC is, in most cases, faster than those of the other tools.}}
@ARTICLE{Cai_2006,title={Stochastic Scheduling With Asymmetric Earliness And Tardiness Penalties Under Random Machine Breakdowns},year={2006},author={Xiaoqiang Cai and Xiaoqiang Cai and Xian Zhou and Xian Zhou},doi={10.1017/s0269964806060396},pmid={null},pmcid={null},mag_id={2161708969},journal={Probability in the Engineering and Informational Sciences},abstract={We study a stochastic scheduling problem of processing a set of jobs on a single machine. Each job has a random processing time Pi and a random due date Di, which are independently and exponentially distributed. The machine is subject to stochastic breakdowns in either preempt-resume or preempt-repeat patterns, with the uptimes following an exponential distribution and the downtimes (repair times) following a general distribution. The problem is to determine an optimal sequence for the machine to process all jobs so as to minimize the expected total cost comprising asymmetric earliness and tardiness penalties, in the form of E[∑ai max{0,Di − Ci} + bi max{0,Ci − Di}]. We find sufficient conditions for the optimal sequences to be V-shaped with respect to {E(Pi)/ai} and {E(Pi)/bi}, respectively, which cover previous results in the literature as special cases. We also find conditions under which optimal sequences can be derived analytically. An algorithm is provided that can compute the best V-shaped sequence.}}
@ARTICLE{Deavours_2002,title={The Mobius framework and its implementation},year={2002},author={Daniel D. Deavours and Daniel D. Deavours and Graham Clark and G. Clark and T. Courtney and T. Courtney and David Daly and David M. Daly and S. Derisavi and Salem Derisavi and Jay M. Doyle and Jay M. Doyle and William H. Sanders and William H. Sanders and Patrick G. Webster and Patrick G. Webster},doi={10.1109/tse.2002.1041052},pmid={null},pmcid={null},mag_id={2161833190},journal={IEEE Transactions on Software Engineering},abstract={The Mobius framework is an environment for supporting multiple modeling formalisms and solution techniques. Models expressed in formalisms that are compatible with the framework are translated into equivalent models using Mobius framework components. This translation preserves the structure of the models, allowing efficient solutions. The framework is implemented in the tool by a well-defined abstract functional interface. Models and solution techniques interact with one another through the use of the standard interface, allowing them to interact with Mobius framework components, not formalism components. This permits novel combinations of modeling techniques, and will be a catalyst for new research in modeling techniques. This paper describes our approach, focusing on the "atomic model". We describe the formal description of the Mobius components as well as their implementations in our software tool.}}
@ARTICLE{Kamel_2000,title={VIP: A Visual Editor and Compiler for v-Promela},year={2000},author={Moataz Kamel and Moataz Kamel and Stefan Leue and Stefan Leue},doi={10.1007/3-540-46419-0_32},pmid={null},pmcid={null},mag_id={2162105624},journal={null},abstract={We describe the Visual Interface to PROMELA (VIP) tool that we have recently implemented. VIP supports the visual editing and maintenance of v-Promela models. v-Promela is a visual, object-oriented extension to PROMELA, the input language to the SPIN model checker. We introduce the v-Promela notation as supported by the VIP editor, discuss PROMELA code generation, and describe the process of property validation for the resulting models. Our discussion centers around two case studies, a call processing system and the CORBA GIOP protocol.}}
@ARTICLE{Chilenski_1994,title={Applicability of modified condition/decision coverage to software testing},year={1994},author={John Joseph Chilenski and John Joseph Chilenski and Steven P. Miller and Steven P. Miller},doi={10.1049/sej.1994.0025},pmid={null},pmcid={null},mag_id={2162200351},journal={Software Engineering Journal},abstract={Modified condition/decision coverage is a structural coverage criterion requiring that each condition within a decision is shown by execution to independently and correctly affect the outcome of the decision. This criterion was developed to help meet the need for extensive testing of complex Boolean expressions in safety-critical applications. The paper describes the modified condition/decision coverage criterion, its properties and areas for further work.}}
@ARTICLE{Błażewicz_1996,title={The Job Shop Scheduling Problem: Conventional and new Solution Techniques},year={1996},author={Jacek Błażewicz and Jacek Blazewicz and Wolfgang Domschke and Wolfgang Domschke and Erwin Pesch and Erwin Pesch},doi={10.1016/0377-2217(95)00362-2},pmid={null},pmcid={null},mag_id={2162535720},journal={European Journal of Operational Research},abstract={null}}
@ARTICLE{Bandini_2001,title={Application of parametric model checking - the Root Contention protocol},year={2001},author={Gianfranco Bandini and G. Bandini and G. Bandini and R.L. Spelberg and R.L. Spelberg and R.L. Spelberg and R.C.H. de Rooij and R.C.H. de Rooij and W.J. Toetenel and W.J. Toetenel},doi={10.1109/hicss.2001.927265},pmid={null},pmcid={null},mag_id={2162978114},journal={null},abstract={Presents an application of formal verification which was carried out using a new implemented version of the LPMC model checker tool. The focus is on the modeling and the automatic verification of a protocol contained in the IEEE 1394 standard, the Root Contention protocol. This protocol involves both real time and randomization. This is an illustrative case study which fully demonstrates the use of the new LPMC tool's capability of handling linear constraints in order to exploit parametric real-time model checking.}}
@ARTICLE{Laínez_2010,title={Using S-graph to address uncertainty in batch plants},year={2010},author={José Miguel Laínez and José Miguel Laínez and Máté Hegyháti and Máté Hegyháti and Ferenc Friedler and Ferenc Friedler and Luís Puigjaner and Luis Puigjaner},doi={10.1007/s10098-009-0240-5},pmid={null},pmcid={null},mag_id={2164694850},journal={Clean Technologies and Environmental Policy},abstract={Processes and markets uncertainties make batch plants a complex environment to manage production activities. Uncertainties may cause deviations and infeasibilities in predefined schedules; this may result in poor planning and inefficient utilization of materials. Consequently, the relevance of explicitly incorporating variability in the scheduling formulation in order to offer more efficient plans and robust decisions to changes has become recognized. This work addresses the batch plants scheduling under exogenous uncertainty. The most widely utilized approach to tackle this problem is stochastic programming; however its solution results in high computational expenses. From another standpoint S-graph, a graph-theoretic approach, has proved to be very efficient to deal with deterministic scheduling. In this work, the S-graph framework is enhanced so that stochastic scheduling problems can be handled. For this purpose, a LP model that is used as performance evaluator has been coupled with S-graph framework. One of the main advantages of the proposed approach is that the search space does not increase according to the number of scenarios considered in the problem. Finally, the potential of the proposed framework is highlighted through two illustrative examples.}}
@ARTICLE{Ma_2014,title={Evaluating On-line Model Checking in UPPAAL-SMC using a Laser Tracheotomy Case Study},year={2014},author={Xintao Ma and Xintao Ma and Jonas Rinast and Jonas Rinast and Sibylle Schupp and Sibylle Schupp and Dieter Gollmann and Dieter Gollmann and Dieter Gollmann},doi={10.4230/oasics.mcps.2014.100},pmid={null},pmcid={null},mag_id={2165045114},journal={null},abstract={On-line model checking is a variant of model checking that evaluates properties of a system concurrently while deployed, which allows overcoming limitations of inaccurate system models. In this paper we conduct a laser tracheotomy case study to evaluate the feasibility of using the statistical model checker UPPAAL-SMC for on-line model checking in a medical application. Development of automatic on-line model checking relies on the precision of the prediction and real-time capabilities as real-time requirements must be met. We evaluate the case study with regards to these qualities and our results show that using UPPAAL-SMC in an on-line model checking context is practical: relative prediction errors were only 2% on average and guarantees could be established within reasonable time during our experiments.}}
@ARTICLE{Lamport_1987,title={A fast mutual exclusion algorithm},year={1987},author={Leslie Lamport and Leslie Lamport},doi={10.1145/7351.7352},pmid={null},pmcid={null},mag_id={2166071597},journal={ACM Transactions on Computer Systems},abstract={A new solution to the mutual exclusion problem is presented that, in the absence of contention, requires only seven memory accesses. It assumes atomic reads and atomic writes to shared registers.}}
@ARTICLE{Larsen_2003,title={Compact Data Structures and State-Space Reduction for Model-Checking Real-Time Systems},year={2003},author={Kim G. Larsen and Kim Guldstrand Larsen and Fredrik Larsson and Fredrik Larsson and Fredrik Larsson and Paul Pettersson and Paul Pettersson and Wang Yi and Wang Yi},doi={10.1023/a:1025132427497},pmid={null},pmcid={null},mag_id={2167722250},journal={Real-time Systems},abstract={During the past few years, a number of verification tools have been developed for real-time systems in the framework of timed automata. One of the major problems in applying these tools to industrial-sized systems is the huge memory-usage for the exploration of the state-space of a network (or product) of timed automata, as the model-checkers must keep information about not only the control structure of the automata but also the clock values specified by clock constraints. In this paper, we present a compact data structure for representing clock constraints. The data structure is based on an O(n3) algorithm which, given a constraint system over real-valued variables consisting of bounds on differences, constructs an equivalent system with a minimal number of constraints. In addition, we have developed an on-the-fly reduction technique to minimize the space-usage. Based on static analysis of the control structure of a network of timed automata, we are able to compute a set of symbolic states that cover all the dynamic loops of the network in an on-the-fly searching algorithm, and thus ensure termination in reachability analysis. The two techniques and their combination have been implemented in the tool UPPAAL. Our experimental results demonstrate that the techniques result in truly significant space-reductions: for six examples from the literature, the space saving is between 75% and 94%, and in (nearly) all examples time-performance is improved. Noteworthy is also the observation that the two techniques are completely orthogonal.}}
@ARTICLE{Dijkstra_1959,title={A note on two problems in connexion with graphs},year={1959},author={Edsger W. Dijkstra and Edsger W. Dijkstra},doi={10.1007/bf01386390},pmid={null},pmcid={null},mag_id={2169528473},journal={Numerische Mathematik},abstract={We consider n points (nodes), some or all pairs of which are connected by a branch; the length of each branch is given. We restrict ourselves to the case where at least one path exists between any two nodes. We now consider two problems. Problem 1. Constrnct the tree of minimum total length between the n nodes. (A tree is a graph with one and only one path between every two nodes.) In the course of the construction that we present here, the branches are subdivided into three sets: I. the branches definitely assignec~ to the tree under construction (they will form a subtree) ; II. the branches from which the next branch to be added to set I, will be selected ; III. the remaining branches (rejected or not yet considered). The nodes are subdivided into two sets: A. the nodes connected by the branches of set I, B. the remaining nodes (one and only one branch of set II will lead to each of these nodes), We start the construction by choosing an arbitrary node as the only member of set A, and by placing all branches that end in this node in set II. To start with, set I is empty. From then onwards we perform the following two steps repeatedly. Step 1. The shortest branch of set II is removed from this set and added to}}
@ARTICLE{Adonyi_2008,title={Effective scheduling of a large-scale paint production system},year={2008},author={R. Adonyi and R. Adonyi and Gábor Biros and Gabor Biros and Tibor Holczinger and Tibor Holczinger and Ferenc Friedler and Ferenc Friedler},doi={10.1016/j.jclepro.2006.08.021},pmid={null},pmcid={null},mag_id={2170876682},journal={Journal of Cleaner Production},abstract={null}}
@ARTICLE{Rayadurgam_2001,title={Coverage based test-case generation using model checkers},year={2001},author={Sanjai Rayadurgam and Sanjai Rayadurgam and Mats P. E. Heimdahl and Mats P. E. Heimdahl},doi={10.1109/ecbs.2001.922409},pmid={null},pmcid={null},mag_id={2172253171},journal={null},abstract={Presents a method for automatically generating test cases according to structural coverage criteria. We show how a model checker can be used to automatically generate complete test sequences that provide a pre-defined coverage of any software development artifact that can be represented as a finite state model. Our goal is to help reduce the high cost of developing test cases for safety-critical software applications that require a certain level of coverage for certification, e.g. safety-critical avionics systems that need to demonstrate MC/DC (modified condition and decision) coverage of the code. We define a formal framework which is suitable for modeling software artifacts like requirements models, software specifications or implementations. We then show how various structural coverage criteria can be formalized and used to make a model checker provide test sequences to achieve this coverage. To illustrate our approach, we demonstrate how a model checker can be used to generate test sequences for MC/DC coverage of a small case example.}}
@ARTICLE{Cimatti_2000,title={Industrial Applications of Model Checking},year={2000},author={Alessandro Cimatti and Alessandro Cimatti},doi={10.1007/3-540-45510-8_6},pmid={null},pmcid={null},mag_id={2177397681},journal={null},abstract={Formal methods have a great potential of application in the development of industrial critical systems. In certain application fields, formal methods are even becoming part of standards. Among formal methods, Model Checking is proving particularly effective, especially thanks to its ability to automatically analyze complex designs and to produce counterexamples. However, the application of formal methods in the industrial development practice is by no means trivial. Formal methods can be costly, slow down the development, and require training andc hanges to the development cycle. In this paper, the application of Model Checking techniques in the development of industrial critical systems is discussed, by focusing on two projects where Model Checking has been successfully applied under different conditions.}}
@ARTICLE{Amnell_2000,title={UPPAAL: now, next, and future},year={2000},author={Tobias Amnell and Tobias Amnell and Gerd Behrmann and Gerd Behrmann and Johan Bengtsson and Johan Bengtsson and Pedro R. D’Argenio and Pedro R. D'Argenio and Pedro R. D'Argenio and Albert David and Alexandre David and Ansgar Fehnker and Ansgar Fehnker and Thomas Hune and Thomas Hune and Bertrand Jeannet and Bertrand Jeannet and Kim Guldstrand Larsen and Kim Guldstrand Larsen and M. Oliver Möller and M. Oliver Möller and Paul Pettersson and Paul Pettersson and Carsten Weise and Carsten Weise and Wang Yi and Wang Yi},doi={10.1007/3-540-45510-8_4},pmid={null},pmcid={null},mag_id={2178662818},journal={Lecture Notes in Computer Science},abstract={UPPAAL is a tool for modeling, simulation and verification of real-time systems, developed jointly by BRICS at Aalborg University and the Department of Computer Systems at Uppsala University. The tool is appropriate for systems that can be modeled as a collection of non-deterministic processes with finite control structure and real-valued clocks, communicating through channels or shared variables. Typical application areas include real-time controllers and communication protocols, in particular those where timing aspects are critical.

This paper reports on the currently available version and summarizes developments during the last two years. We report on new directions that extends UPPAAL with cost-optimal exploration, parametric modeling, stop-watches, probablistic modeling, hierachical modeling, executable timed automata, and a hybrid automata animator. We also report on recent work to improve the efficiency of the tool. In particular, we outline Clock Difference Diagrams (CDDs), new compact representations of states, a distributed version of the tool, and application of dynamic partitioning.

UPPAAL has been applied in a number of academic and industrial case studies. We describe a selection of the recent case studies.}}
@ARTICLE{Yi_1995,title={Automatic verification of real-time communicating systems by constraint-solving},year={1995},author={Wang Yi and Wang Yi and Paul Pettersson and Paul Pettersson and Mats Daniels and Mats Daniels},doi={10.1007/978-0-387-34878-0_18},pmid={null},pmcid={null},mag_id={2180475648},journal={null},abstract={In this paper, an algebra of timed processes with real-valued clocks is presented, which serves as a formal description language for real-time communicating systems. We show that requirements such as “a process will never reach an undesired state” can be verified by solving a simple class of constraint systems on the clock-variables. A complete method for reachability analysis associated with the language is developed, and implemented as an automatic verification tool based on constraint-solving techniques. Finally as examples, we study and verify the safety-properties of Fischer’s mutual exclusion protocol and a railway crossing controller.}}
@ARTICLE{Bellettini_2014,title={Distributed CTL Model Checking in the Cloud.},year={2014},author={Carlo Bellettini and Matteo Camilli and Matteo Camilli and Carlo Bellettini and Lorenzo Capra and Lorenzo Capra and Mattia Monga and Mattia Monga},doi={10.1109/synasc.2014.52},pmid={null},pmcid={null},mag_id={2216194096},journal={null},abstract={The recent extensive availability of "big data" platforms calls for a widespread adoption by the formal verification community. Cloud computing platforms represent a great opportunity to run massively parallel jobs, yet classical formal verification tools/techniques must undergo a deep technological transformation in order to exploit the new available architectures. This has raised an increasing interest in deploying verification techniques on parallel/distributed frameworks. In this paper we introduce a framework to ease the adoption of a distributed approach to verification of Computation Tree Logic (CTL) formulas on very large state spaces. The approach exploits/integrates a recently developed, parametric state-space builder. The whole framework adopts M AP R EDUCE as core computational model, and can be tailored to different modelling formalisms. The outcomes of several tests performed on (Petri-nets based) benchmark specifications are presented, thus showing the convenience of the proposed approach.}}
@ARTICLE{Kuhn_1955,title={The Hungarian method for the assignment problem},year={1955},author={Harold W. Kuhn and Harold W. Kuhn and Harold W. Kuhn},doi={10.1002/nav.3800020109},pmid={null},pmcid={null},mag_id={2222512263},journal={Naval Research Logistics Quarterly},abstract={This paper has always been one of my favorite “children,” combining as it does elements of the duality of linear programming and combinatorial tools from graph theory. It may be of some interest to tell the story of its origin.}}
@ARTICLE{Lowder_2016,title={The Number, Size, and Distribution of Farms, Smallholder Farms, and Family Farms Worldwide},year={2016},author={Sarah K. Lowder and Sarah K. Lowder and Jakob Skoet and Jakob Skoet and Terri Raney and Terri Raney},doi={10.1016/j.worlddev.2015.10.041},pmid={null},pmcid={null},mag_id={2262752710},journal={World Development},abstract={Numerous sources provide evidence of trends and patterns in average farm size and farmland distribution worldwide, but they often lack documentation, are in some cases out of date, and do not provide comprehensive global and comparative regional estimates. This article uses agricultural census data (provided at the country level in Web Appendix) to show that there are more than 570 million farms worldwide, most of which are small and family-operated. It shows that small farms (less than 2ha) operate about 12% and family farms about 75% of the world’s agricultural land. It shows that average farm size decreased in most low- and lower-middle-income countries for which data are available from 1960 to 2000, whereas average farm sizes increased from 1960 to 2000 in some upper-middle-income countries and in nearly all high-income countries for which we have information.}}
@ARTICLE{Dijkstra_1959,title={a note on two problems in connection with graphs},year={1959},author={Edsger W. Dijkstra},doi={null},pmid={null},pmcid={null},mag_id={2280326949},journal={null},abstract={null}}
@ARTICLE{Acreţoaie_2014,title={Hypersonic: Model Analysis and Checking in the Cloud},year={2014},author={Vlad Acreţoaie and Vlad Acretoaie and Harald Störrle and Harald Störrle},doi={null},pmid={null},pmcid={null},mag_id={2293336569},journal={null},abstract={Context: Modeling tools are traditionally delivered as monolithic desktop applications, optionally extended by plug-ins or special purpose central servers. This delivery model suffers from several drawbacks, ranging from poor scalability to dicult maintenance and the proliferation of \shelfware". Objective: In this paper we investigate the conceptual and technical feasibility of a new software architecture for modeling tools, where certain advanced features are factored out of the client and moved towards the Cloud. With this approach we plan to address the above mentioned drawbacks of existing modeling tools. Method: We base our approach on RESTful Web services. Using features implemented in the existing Model Analysis and Checking (MACH) tool, we create a RESTful Web service API oering model analysis facilities. We refer to it as the Hypersonic API. We provide a proof of concept implementation for the Hypersonic API using model clone detection as our example case. We also implement a sample Web application as a client for these Web services. Results: Our initial experiments with Hypersonic demonstrate the viability of our approach. By applying standards such as REST and JSON in combination with Prolog as an implementation language, we are able to transform MACH from a command line tool into the rst Web-based model clone detection service with remarkably little eort.}}
@ARTICLE{Land_1960,title={an automatic method of solving discrete programming problems},year={1960},author={Ailsa Land and A. H. Land and A. G. Doig},doi={10.2307/1910129},pmid={null},pmcid={null},mag_id={2313810840},journal={Econometrica},abstract={null}}
@ARTICLE{Iversen_1999,title={Model-Checking Real-Time Control Programs. Verifying LEGO Mindstorms Systems Using UPPAAL},year={1999},author={Torsten K. Iversen and Torsten K. Iversen and K. Kristoffersen and Kåre J. Kristoffersen and Kim G. Larsen and Kim Guldstrand Larsen and Morten Laursen and Morten Laursen and Rune G. Madsen and Rune G. Madsen and Steffen K. Mortensen and Steffen K. Mortensen and Paul Pettersson and Paul Pettersson and Chris B. Thomasen and Chris B. Thomasen},doi={10.7146/brics.v6i53.20123},pmid={null},pmcid={null},mag_id={2351722488},journal={BRICS Report Series},abstract={In this paper, we present a method for automatic verification of real-time control programs running on LEGO  RCX bricks using the verification tool UPPAAL. The control programs, consisting of a number of tasks running concurrently, are automatically translated into the timed automata model of UPPAAL. The fixed scheduling algorithm used by the LEGO RCX processor is modeled in UPPAAL, and supply of similar (sufficient) timed automata models for the environment allows analysis of the overall real-time system using the tools of UPPAAL. To illustrate our techniques we have constructed, modeled and verified a machine for sorting LEGO bricks by color.}}
@ARTICLE{Larsen_1996,title={Diagnostic model-checking for real-time systems},year={1996},author={Kim G. Larsen and Kim Guldstrand Larsen and Paul Pettersson and Paul Pettersson and Wang Yi and Wang Yi},doi={10.7146/brics.v3i57.18682},pmid={null},pmcid={null},mag_id={2368465500},journal={BRICS Report Series},abstract={Uppaal is a new tool suit for automatic verification of networks of timed automata. In this paper we describe the diagnostic model-checking feature of Uppaal and illustrates its usefulness through the debugging of (a version of) the Philips Audio-Control Protocol. Together with a graphical interface of Uppaal this diagnostic feature allows for a number of errors to be more easily detected and corrected.}}
@ARTICLE{Larsen_2016,title={Online and Compositional Learning of Controllers with Application to Floor Heating},year={2016},author={Kim Guldstrand Larsen and Kim Guldstrand Larsen and Marius Mikučionis and Marius Mikucionis and Marco Muñiz and Marco Muñiz and Jǐŕı Srba and Jiří Srba and Jakob Haahr Taankvist and Jakob Haahr Taankvist},doi={10.1007/978-3-662-49674-9_14},pmid={null},pmcid={null},mag_id={2442701636},journal={null},abstract={Controller synthesis for stochastic hybrid switched systems, like e.g. a floor heating system in a house, is a complex computational task that cannot be solved by an exhaustive search though all the control options. The state-space to be explored is in general uncountable due to the presence of continuous variables e.g. temperature readings in the different rooms and even after digitization, the state-space remains huge and cannot be fully explored. We suggest a general and scalable methodology for controller synthesis for such systems. Instead of off-line synthesis of a controller for all possible input temperatures and an arbitrary time horizon, we propose an on-line synthesis methodology, where we periodically compute the controller only for the near future based on the current sensor readings. This computation is itself done by employing machine learning in order to avoid enumeration of the whole state-space. For additional scalability we propose and apply a compositional synthesis approach. Finally, we demonstrate the applicability of the methodology to a concrete floor heating system of a real family house.}}
@ARTICLE{Burkard_2008,title={Assignment problems},year={2008},author={Rainer E. Burkard and Rainer E. Burkard and Mauro Dell’Amico and Mauro Dell'Amico and Silvano Martello and Silvano Martello},doi={null},pmid={null},pmcid={null},mag_id={2467020497},journal={null},abstract={This book provides a comprehensive treatment of assignment problems from their conceptual beginnings in the 1920s through present-day theoretical, algorithmic, and practical developments. The authors have organized the book into 10 self-contained chapters to make it easy for readers to use the specific chapters of interest to them without having to read the book linearly. The topics covered include bipartite matching algorithms, linear assignment problems, quadratic assignment problems, multi-index assignment problems, and many variations of these problems. Exercises in the form of numerical examples provide readers with a method of self-study or students with homework problems, and an associated webpage offers applets that readers can use to execute some of the basic algorithms as well as links to computer codes that are available online. Audience: Assignment Problems is a useful tool for researchers, practitioners, and graduate students. Researchers will benefit from the detailed exposition of theory and algorithms related to assignment problems, including the basic linear sum assignment problem and its many variations. Practitioners will learn about practical applications of the methods, the performance of exact and heuristic algorithms, and software options. This book also can serve as a text for advanced courses in discrete mathematics, integer programming, combinatorial optimization, and algorithmic computer science. Contents: Preface; Chapter 1: Introduction; Chapter 2: Theoretical Foundations; Chapter 3: Bipartite Matching Algorithms; Chapter 4: Linear Sum Assignment Problem; Chapter 5: Further Results on the Linear Sum Assignment Problem; Chapter 6: Other Types of Linear Assignment Problems; Chapter 7: Quadratic Assignment Problems: Formulations and Bounds; Chapter 8: Quadratic Assignment Problems: Algorithms; Chapter 9: Other Types of Quadratic Assignment Problems; Chapter 10: Multi-index Assignment Problems; Bibliography; Author Index; Subject Index}}
@ARTICLE{Stern_1997,title={Parallelizing the Murφ verifier},year={1997},author={U. Stern and D. L. Dill},doi={null},pmid={null},pmcid={null},mag_id={2488874620},journal={null},abstract={With the use of state and memory reduction techniques in verification by explicit state enumeration, runtime becomes a major limiting factor. We describe a parallel version of the explicit state enumeration verifier Murφ for distributed memory multiprocessors and networks of workstations that is based on the message passing paradigm. In experiments with three complex cache coherence protocols, parallel Murφ shows close to linear speedups, which are largely insensitive to communication latency and bandwidth. There is some slowdown with increasing communication overhead, for which a simple yet relatively accurate approximation formula is given. Techniques to reduce overhead and required bandwidth and to allow heterogeneity and dynamically changing load in the parallel machine are discussed, which we expect will allow good speedups when using conventional networks of workstations.}}
@ARTICLE{Grumberg_2008,title={25 Years of Model Checking},year={2008},author={Orna Grumberg and Orna Grumberg and Helmut Veith and Helmut Veith},doi={10.1007/978-3-540-69850-0},pmid={null},pmcid={null},mag_id={2506987745},journal={null},abstract={Model checking technology is among the foremost applications of logic to computer science and computer engineering. The model checking community has achieved many breakthroughs, bridging the gap betwe}}
@ARTICLE{Hune_2000,title={Modelling a Real-Time Language},year={2000},author={Thomas Hune and T. Hune},doi={null},pmid={null},pmcid={null},mag_id={2523160183},journal={null},abstract={null}}
@ARTICLE{Duflot_2012,title={Practical Applications of Probabilistic Model Checking to Communication Protocols},year={2012},author={Marie Duflot and Marie Duflot and Marta Kwiatkowska and Marta Kwiatkowska and Gethin Norman and Gethin Norman and David Parker and David Parker and Sylvain Peyronnet and Sylvain Peyronnet and Claudine Picaronny and Claudine Picaronny and Jeremy Sproston and Jeremy Sproston},doi={10.1002/9781118459898.ch7},pmid={null},pmcid={null},mag_id={2546429222},journal={null},abstract={Probabilistic model checking is a formal verification technique for the analysis of systems that exhibit stochastic behaviour. It has been successfully employed in an extremely wide array of application domains including, for example, communication and multimedia protocols, security and power management. In this chapter we focus on the applicability of these techniques to the analysis of communication protocols. An analysis of the performance of such systems must successfully incorporate several crucial aspects, including concurrency between multiple components, real-time constraints and randomisation. Probabilistic model checking, in particular using probabilistic timed automata, is well suited to such an analysis. We provide an overview of this area, with emphasis on an industrially relevant case study: the IEEE 802.3 (CSMA/CD) protocol. We also discuss two contrasting approaches to the implementation of probabilistic model checking, namely those based on numerical computation and those based on discrete-event simulation. Using results from the two tools PRISM and APMC, we summarise the advantages, disadvantages and trade-offs associated with these techniques.}}
@ARTICLE{Hegyháti_2010,title={Overview of Industrial Batch Process Scheduling},year={2010},author={Máté Hegyháti and Máté Hegyháti and Ferenc Friedler and Ferenc Friedler},doi={10.3303/cet1021150},pmid={null},pmcid={null},mag_id={2557885243},journal={Chemical engineering transactions},abstract={The operation of a production facility has a major effect on the efficiency; therefore it is of upmost importance to find the best possible schedule. Due to the high practical expediency, the topic of batch process scheduling has gained growing interest in the last two decades and many approaches have been published to solve a wide variety of scheduling problems. In the present work first the different type of batch scheduling problems are overviewed, then the advantages and disadvantages of the available methods for batch process scheduling are summarized.}}
@ARTICLE{Smidla_2010,title={S-graph Based Parallel Algorithm to the Scheduling of Multipurpose Batch Plants.},year={2010},author={J. Smidla and J. Smidla and István Heckl and I. Heckl and Ferenc Friedler and F. Friedler},doi={null},pmid={null},pmcid={null},mag_id={2557956741},journal={Chemical engineering transactions},abstract={null}}
@ARTICLE{Kopanos_2010,title={Simultaneous Batching and Scheduling in Multi-product Multi-stage Batch Plants Through Mixed-integer Linear Programming.},year={2010},author={G.M. Kopanos and Luis Puigjaner and Luis Puigjaner},doi={null},pmid={null},pmcid={null},mag_id={2558376865},journal={Chemical engineering transactions},abstract={In this work, a novel sequence-based mixed-integer linear programming formulation for the simultaneous batching and scheduling in multi-product multi-stage batch plants is developed. The selection of batches, the allocation of batches to processing units and the sequencing of batches in each unit constitute the discrete decisions of our model. Batch processing times and sizes are variables. Batch size increment steps are included in an attempt to accommodate our model to real-life industrial practice.}}
@ARTICLE{Largouët_2016,title={Temporal Planning with Extended Timed Automata},year={2016},author={Christine Largouët and Christine Largouët and Omar Krichen and Omar Krichen and Omar Krichen and Yulong Zhao and Yulong Zhao and Yulong Zhao},doi={10.1109/ictai.2016.0086},pmid={null},pmcid={null},mag_id={2578577156},journal={null},abstract={We consider a system modeled as a set of interacting agents evolving along time according to explicit timing constraints. In this kind of system, the planning task consists in selecting and organizing actions in order to reach a goal state in a limited time and in an optimal manner, assuming actions have a cost. We propose to reformulate the planning problem in terms of model-checking and controller synthesis on interacting agents such that the state to reach is expressed using temporal logic. We have chosen to represent each agent using the formalism of Priced Timed Game Automata (PTGA). PTGA is an extension of Timed Automata that allows the representation of cost on actions and uncontrollable actions. Relying on this domain description, we define a planning algorithm that computes the best strategy to achieve the goal. This algorithm is based on recognized model-checking and synthesis tools from the UPPAAL suite. The expressivity of this approach is evaluated on the classical Transport Domain which is extended in order to include timing constraints, cost values and uncontrollable actions. This work has been implemented and performances evaluated on benchmarks.}}
@ARTICLE{Brown-Paul_2015,title={On the fly},year={2015},author={Christine Brown-Paul and Christine Brown-Paul},doi={null},pmid={null},pmcid={null},mag_id={2596984074},journal={Practical Hydroponics and Greenhouses},abstract={Time is running out for destructive Queensland fruit fly populations, according to new research by scientists from the University of Western Sydney and the University of New South Wales.}}
@ARTICLE{Jeannet_2000,title={Partitionnement dynamique dans l'analyse de relations linéaires et application à la vérification de programmes synchrones},year={2000},author={Bertrand Jeannet and Bertrand Jeannet},doi={null},pmid={null},pmcid={null},mag_id={2605673618},journal={null},abstract={Ce travail porte sur la verification, par des methodes algorithmiques, de proprietes de surete de systemes synchrones ou plus generalement reactifs, presentant a la fois des aspects booleens et numeriques. Il propose une technique originale permettant d'augmenter tres sensiblement la taille des systemes verifies. Nous commencons par rappeler le cadre theorique utilise, qui est celui de l'interpretation abstraite, et une de ses applications, l'analyse de relations lineaires, qui permet d'inferer des relations lineaires liant les variables numeriques d'un programme en ses points de controle. Cette analyse a ete appliquee a la verification de programmes synchrones numeriques et de systemes hybrides lineaires. Dans ce contexte, deux problemes se posent : le premier est que la structure de controle explicite de ces systemes est souvent de taille prohibitive, et le deuxieme est que la precision de l'analyse est quelquefois insuffisante pour la preuve de certaines proprietes. Ces deux problemes s'averant lies, nous proposons une solution pour obtenir un compromis entre complexite et precision, consistant a utiliser un domaine abstrait combinant proprietes booleennes et numeriques, et a se servir d'une structure de controle pour ajuster la precision de l'analyse. Celle-ci se sert de la propriete a montrer pour raffiner automatiquement une structure de controle initiale grossiere, jusqu'a ce que la precision obtenue permette de conclure a la preuve de la propriete. Un outil de verification fonde sur ces principes a ete developpe et experimente sur plusieurs exemples significatifs, et pour certains d'entre eux inabordables par d'autres techniques automatiques existantes.}}
@ARTICLE{Helmink_1994,title={Proof-checking a data link protocol},year={1994},author={L. Helmink and M.P.A. Sellink and Frits W. Vaandrager and T. Nipkow and H. Barendregt},doi={null},pmid={null},pmcid={null},mag_id={2612274127},journal={Lecture Notes in Computer Science},abstract={null}}
@ARTICLE{Helmink_1994,title={Proof-checking a data link protocol},year={1994},author={Leen Helmink and L. Helmink and M.P.A. Sellink and M.P.A. Sellink and Frits Vaandrager and Frits W. Vaandrager},doi={null},pmid={null},pmcid={null},mag_id={2613892803},journal={null},abstract={A data link protocol developed and used by Philips Electronics is modeled and verified using I/O automata theory. Correctness
is computer-checked with the Coq proof development system.}}
@ARTICLE{Kristoffersen_1999,title={Experimental Batch Plant: VHS Case Study 1 using Timed Automata and UPPAAL},year={1999},author={K. Kristoffersen and Kåre J. Kristoffersen and Kim Guldstrand Larsen and Kim Guldstrand Larsen and Paul Pettersson and Paul Pettersson and Carsten Weise and Carsten Weise},doi={null},pmid={null},pmcid={null},mag_id={2621848746},journal={null},abstract={null}}
@ARTICLE{Kwiatkowska_1999,title={Automatic Verification of Real-Time Systems with Discrete Probability Distributions},year={1999},author={Marta Kwiatkowska and Marta Kwiatkowska and Gethin Norman and Gethin Norman and Roberto Segala and Roberto Segala and Jeremy Sproston and Jeremy Sproston},doi={10.1007/3-540-48778-6_5},pmid={null},pmcid={null},mag_id={2631639048},journal={null},abstract={We consider the timed automata model of [3], which allows the analysis of real-time systems expressed in terms of quantitative timing constraints. Traditional approaches to real-time system description express the model purely in terms of nondeterminism; however, we may wish to express the likelihood of the system making certain transitions. In this paper, we present a model for real-time systems augmented with discrete probability distributions. Furthermore, using the algorithm of [5] with fairness, we develop a model checking method for such models against temporal logic properties which can refer both to timing properties and probabilities, such as, "with probability 0.6 or greater, the clock x remains below 5 until clock y exceeds 2".}}
@ARTICLE{Seppi_2006,title={Guided model checking with a Bayesian meta-heuristic},year={2006},author={Kevin Seppi and Kevin D. Seppi and Michael Jones and Michael D. Jones and Peter Lamborn and Peter Lamborn},doi={null},pmid={null},pmcid={null},mag_id={2683205133},journal={Fundamenta Informaticae},abstract={This paper presents a meta-heuristic for use in finding errors in models of complex concurrent systems using explicit guided model checking. The meta-heuristic improves explicit guided model checking by applying the empirical Bayes method to revise heuristic estimates of the distance from a given state to an error state. Guided search using the revised estimates finds errors with less search effort than the original estimates.}}
@ARTICLE{Abdulla_1994,title={Undecidable Verification Problems for Programs with Unreliable Channels},year={1994},author={Parosh Aziz Abdulla and Parosh Aziz Abdulla and Bengt Jönsson and Bengt Jonsson},doi={10.1007/3-540-58201-0_78},pmid={null},pmcid={null},mag_id={2688386367},journal={null},abstract={We consider the verification of a particular class of infinite-state systems, namely systems consisting of finite-state processes that communicate via unbounded lossy FIFO channels. This class is able to model e.g. link protocols such as the Alternating Bit Protocol and HDLC. In an earlier paper, we showed that several interesting verification problems are decidable for this class of systems, namely (1) the reachability problem: is a set of states reachable from some other state of the system, (2) safety property over traces formulated as regular sets of allowed finite traces, and (3) eventuality properties: do all computations of a system eventually reach a given set of states. In this paper, we show that the following problems are undecidable, namely


The model checking problem in propositional temporal logics such as Propositional Linear Time Logic (PTL) and Computation Tree Logic (CTL).


The problem of deciding eventuality properties with fair channels: do all computations eventually reach a given set of states if the unreliable channels are fair in the sense that they deliver infinitely many messages if infinitely many messages are transmitted. This problem can model the question of whether a link protocol, such as HDLC, will eventually reliably transfer messages across a medium that is not permanently broken.}}
@ARTICLE{Dierks_2001,title={PLC-automata: a new class of implementable real-time automata},year={2001},author={Henning Dierks and Henning Dierks},doi={10.1016/s0304-3975(00)00089-x},pmid={null},pmcid={null},mag_id={2694136767},journal={Theoretical Computer Science},abstract={We introduce PLC-automata as a new class of automata which are tailored to deal with real-time properties of programmable logic controllers (PLCs). These devices are often used in industrial practice to solve controlling problems. Nevertheless, PLC-automata are not restricted to PLCs, but can be seen as a model for all polling systems. A semantics in an appropriate real-time temporal logic (duration calculus) is given and an implementation schema that fits the semantics is presented in a programming language for PLCs. A case study is used to demonstrate the suitability of this approach. We define several parallel composition operators, and present an alternative semantics in terms of timed automata for which model-checkers are available.}}
@ARTICLE{Clabaut_2016,title={Industrial Grade Model Checking Use Cases, Constraints, Tools and Applications},year={2016},author={Mathieu Clabaut and Mathieu Clabaut and Ning Ge and Ning Ge and Nicolas Breton and Nicolas Breton and Éric Jenn and Eric Jenn and Rémi Delmas and Rémi Delmas and Yoann Fonteneau and Yoann Fonteneau},doi={null},pmid={null},pmcid={null},mag_id={2744509489},journal={null},abstract={Model checking has made a lot of progress since its infancy. For a long time, industrial applications were still limited to some very specific domains out of which the technique bumps into the state explosion wall. Nowadays things evolve and some tools are able to tackle real world use cases outside of the known domains. We give here the feedback collected when using model checking on several industrial strength use cases and give indication on how we take into account the specific domain constraints. 1 Model Checking for Industrial Problems Model checking refers to the problem of exhaustively and automatically checking whether a given model of a system meets a given specification. Model Checking is now an old technique which takes its ground in the mid 1970s as a response to concurrent problem analysis. It was until recently essentially confined to some specific areas, such as hardware analysis or protocol verification. Extension to other domains such as software verification has always been difficult due to the combinatorial explosion problem (the size of the space state grows exponentially with the size of the problem to analyze). However, recent developments in a variety of fields, ranging from symbolic model checking to SAT solver engines and including model checker parallelization lead to a broader range of application in industry including software analysis.}}
@ARTICLE{Amnell_2001,title={Uppaal - Now, Next, and Future},year={2001},author={Tobias Amnell and Gerd Behrmann and Johan Bengtsson and P.R. d' Argenio and Alexandre David and Ansgar Fehnker and T. Hune and Bertrand Jeannet and Kim Guldstrand Larsen and O. Moller and Paul Pettersson and Carsten Weise and Wentao Yi},doi={null},pmid={null},pmcid={null},mag_id={2746482328},journal={null},abstract={null}}
@ARTICLE{Saddem_2017,title={Decomposing the model-checking of mobile robotics actions on a grid},year={2017},author={Rim Saddem and Rim Saddem and Olivier Naud and Olivier Naud and Karen Godary-Dejean and Karen Godary-Dejean and Karen Godary Dejean and Didier Crestani and Didier Crestani},doi={10.1016/j.ifacol.2017.08.1236},pmid={null},pmcid={null},mag_id={2765775656},journal={IFAC-PapersOnLine},abstract={Abstract   Mobile automated systems, such as robots or machinery for precision agriculture, may be designed to perform actions that vary in space according to information from sensors or to a mission map. To be reliable, the design process of such systems should involve the combined verification of spatial and dynamic properties. We consider here CTL model-checking of a mobile robot’s behavior, using the UppAal Timed Automata verifier. We consider reachability properties including path finding. Space is modeled as a 2D grid and the mobile robot path is unknown a priori. In this case, the exhaustive state space exploration of model-checking leads to the generation of many possible movements. This exposes such model-checking to combinatorial issues depending on the grid size and the complexity of system dynamics. In this paper, we propose a decomposition methodology reducing the memory requirements for the verification task. The decomposition is twofold. The grid is decomposed in sub-grids and the model-checking query on the whole grid is decomposed in a set of queries on the sub-grids. A set of test cases and check the validity of the decomposition concept. The decomposition methodology is compared to a simpler method that verifies the reachability property without proceeding to decomposition.}}
@ARTICLE{Bohnenkamp_2004,title={Synthesis and stochastic assessment of schedules for lacquer production},year={2004},author={Henrik Bohnenkamp and Henrik C. Bohnenkamp and H. Bohnenkamp and Holger Hermanns and Holger Hermanns and J. Klaren and J. Klaren and Angelika Mader and Angelika Mader and Yaroslav S. Usenko and Y.S. Usenko},doi={null},pmid={null},pmcid={null},mag_id={2826621504},journal={CTIT technical report series},abstract={The MODEST modeling language pairs modeling features from stochastic process algebra and from timed and probabilistic automata with light-weight notations such as exception handling. It is supported by the MOTOR tool, which facilitates the execution and evaluation of MODEST specifications by means of the discrete event simulation engine of the MOBIUS tool. This paper describes the application of MODEST, MOTOR and MOBIUS to a highly nontrivial case. We investigate the effect of faulty behavior on a hard real-time scheduling problem from the domain of lacquer production. The scheduling problem is first solved using the timed model-checker UPPAAL. The resulting schedules are then embedded in a MODEST failure model of the lacquer production line, and analyzed with the discrete event simulator of MOBIUS. This approach allows one to assess the quality of the schedules with respect to timeliness, utilization of resources, and sensitivity to different assumptions about the reliability of the production line.}}
@ARTICLE{Yagoubi_2018,title={New Approach for Differential Harvest Problem: The model checking way},year={2018},author={Rim Saddem Yagoubi and Rim Saddem Yagoubi and Olivier Naud and Olivier Naud and Karen Godary-Dejean and Karen Godary-Dejean and Karen Godary Dejean and Karen Godary Dejean and Karen Godary Dejean and Didier Crestani and Didier Crestani},doi={10.1016/j.ifacol.2018.06.279},pmid={null},pmcid={null},mag_id={2884379712},journal={IFAC-PapersOnLine},abstract={Abstract   The development, in the last decades, of technologies for precision agriculture allows the acquisition of crop data with a high spatial resolution. This offers possibilities for innovative control and raises new logistics issues that may be solved using discrete event models. In vineyards, some technologies make it possible to define zones with different qualities of grapes and sort the grapes at harvest to make different vintages. In this context, the Differential Harvest Problem (DHP) consists in finding a trajectory of the harvesting machine in the field in order to obtain at least a given quantity of higher quality grapes and minimising working time. In available literature, the DHP has been solved using Constraint Programming. In this paper, we investigate if it is possible to solve the DHP using the Cost Optimal Reachability Analysis feature of a model-checking tool such as UppAal-CORA. A model named DHP PTA has been designed based on the priced timed automata formalism and the UppAal-CORA tool. The method made it possible to obtain the optimal trajectory of a harvesting machine for a vine plot composed of up to 12 rows. The study is based on real vineyard data.}}
@ARTICLE{Alur_1999,title={Timed Automata},year={1999},author={Rajeev Alur and Rajeev Alur},doi={null},pmid={null},pmcid={null},mag_id={2911583164},journal={null},abstract={Model checking is emerging as a practical tool for automated debugging of complex reactive systems such as embedded controllers and network protocols (see [23] for a survey). Traditional techniques for model checking do not admit an explicit modeling of time, and are thus, unsuitable for analysis of real-time systems whose correctness depends on relative magnitudes of different delays. Consequently, timed automata [7] were introduced as a formal notation to model the behavior of real-time systems. Its definition provides a simple way to annotate state-transition graphs with timing constraints using finitely many real-valued clock variables. Automated analysis of timed automata relies on the construction of a finite quotient of the infinite space of clock valuations. Over the years, the formalism has been extensively studied leading to many results establishing connections to circuits and logic, and much progress has been made in developing verification algorithms, heuristics, and tools. This paper provides a survey of the theory of timed automata, and their role in specification and verification of real-time systems.}}
@ARTICLE{Hessel_2004,title={Time-Optimal Real-Time Test Case Generation using UPPAAL},year={2004},author={Anders Hessel and Anders Hessel and Kim Guldstrand Larsen and Kim Guldstrand Larsen and Brian Nielsen and Brian Nielsen and Paul Pettersson and Paul Pettersson and Arne Skou and Arne Skou},doi={null},pmid={null},pmcid={null},mag_id={2982845041},journal={Lecture Notes in Computer Science},abstract={Testing is the primary software validation technique used by industry today, but remains ad hoc, error prone, and very expensive. A promising improvement is to automatically generate test cases from formal models of the system under test. We demonstrate how to automatically generate real-time conformance test cases from timed automata specifications. Specifically we demonstrate how to efficiently generate real-time test cases with optimal execution time i.e test cases that are the fastest possible to execute. Our technique allows time optimal test cases to be generated using manually formulated test purposes or generated automatically from various coverage criteria of the model.}}
@ARTICLE{R._1992,title={symbolic model checking},year={1992},author={BurchJ. R. and ClarkeE. M. and McMillanK. L. and DillD. L. and HwangL. J.},doi={null},pmid={null},pmcid={null},mag_id={3006125585},journal={Information & Computation},abstract={null}}
@ARTICLE{Fox_2011,title={PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains},year={2011},author={Maria Fox and Derek Long},doi={10.1613/jair.1129},pmid={null},pmcid={null},mag_id={3103157186},journal={arXiv: Artificial Intelligence},abstract={In recent years research in the planning community has moved increasingly toward s application of planners to realistic problems involving both time and many typ es of resources. For example, interest in planning demonstrated by the space res earch community has inspired work in observation scheduling, planetary rover ex ploration and spacecraft control domains. Other temporal and resource-intensive domains including logistics planning, plant control and manufacturing have also helped to focus the community on the modelling and reasoning issues that must be confronted to make planning technology meet the challenges of application. The International Planning Competitions have acted as an important motivating fo rce behind the progress that has been made in planning since 1998. The third com petition (held in 2002) set the planning community the challenge of handling tim e and numeric resources. This necessitated the development of a modelling langua ge capable of expressing temporal and numeric properties of planning domains. In this paper we describe the language, PDDL2.1, that was used in the competition. We describe the syntax of the language, its formal semantics and the validation of concurrent plans. We observe that PDDL2.1 has considerable modelling power --- exceeding the capabilities of current planning technology --- and presents a number of important challenges to the research community.}}
@ARTICLE{Bernardo_2004,title={formal methods for the design of real time systems},year={2004},author={Marco Bernardo and Flavio Corradini},doi={10.1007/b110123},pmid={null},pmcid={null},mag_id={3108818942},journal={null},abstract={null}}
@ARTICLE{Fraser_2009,title={Testing with model checkers: a survey},year={2009},author={Gordon Fraser and Gordon Fraser and Franz Wotawa and Franz Wotawa and Paul Ammann and Paul Ammann},doi={10.1002/stvr.402},pmid={null},pmcid={null},mag_id={4211181233},journal={Software Testing, Verification & Reliability},abstract={About a decade after the initial proposal to use model checkers for the generation of test cases we take a look at the results in this field of research. Model checkers are formal verification tools, capable of providing counterexamples to violated properties. Normally, these counterexamples are meant to guide an analyst when searching for the root cause of a property violation. They are, however, also very useful as test cases. Many different approaches have been presented, many problems have been solved, yet many issues remain. This survey paper reviews the state of the art in testing with model checkers. Copyright © 2008 John Wiley & Sons, Ltd.}}
@ARTICLE{Whalen_null,title={Observable modified condition/decision coverage},year={null},author={Michael W. Whalen and Michael Whalen and Gregory Gay and Gregory Gay and Dongjiang You and Dongjiang You and Mats P. E. Heimdahl and Mats P. E. Heimdahl and Matt Staats and Matt Staats},doi={10.1109/icse.2013.6606556},pmid={null},pmcid={null},mag_id={4233529774},journal={null},abstract={In many critical systems domains, test suite adequacy is currently measured using structural coverage metrics over the source code. Of particular interest is the modified condition/decision coverage (MC/DC) criterion required for, e.g., critical avionics systems. In previous investigations we have found that the efficacy of such test suites is highly dependent on the structure of the program under test and the choice of variables monitored by the oracle. MC/DC adequate tests would frequently exercise faulty code, but the effects of the faults would not propagate to the monitored oracle variables. In this report, we combine the MC/DC coverage metric with a notion of observability that helps ensure that the result of a fault encountered when covering a structural obligation propagates to a monitored variable; we term this new coverage criterion Observable MC/DC (OMC/DC). We hypothesize this path requirement will make structural coverage metrics 1.) more effective at revealing faults, 2.) more robust to changes in program structure, and 3.) more robust to the choice of variables monitored. We assess the efficacy and sensitivity to program structure of OMC/DC as compared to masking MC/DC using four subsystems from the civil avionics domain and the control logic of a microwave. We have found that test suites satisfying OMC/DC are significantly more effective than test suites satisfying MC/DC, revealing up to 88% more faults, and are less sensitive to program structure and the choice of monitored variables.}}
@ARTICLE{Gargantini_null,title={Using Model Checking to Generate Tests from Requirements Specifications},year={null},author={Angelo Gargantini and Angelo Gargantini and Constance L. Heitmeyer and Constance Heitmeyer},doi={10.1007/3-540-48166-4_10},pmid={null},pmcid={null},mag_id={4234459169},journal={Lecture Notes in Computer Science},abstract={Recently, many formal methods, such as the SCR (Software Cost Reduction) requirements method, have been proposed for improving the quality of software specifications. Although improved specifications are valuable, the ultimate objective of software development is to produce software that satisfies its requirements. To evaluate the correctness of a software implementation, one can apply black-box testing to determine whether the implementation, given a sequence of system inputs, produces the correct system outputs. This paper describes a specification-based method for constructing a suite of test sequences, where a test sequence is a sequence of inputs and outputs for testing a software implementation. The test sequences are derived from a tabular SCR requirements specification containing diverse data types, i.e., integer, boolean, and enumerated types. From the functions defined in the SCR specification, the method forms a collection of predicates called branches, which “cover” all possible software behaviors described by the specification. Based on these predicates, the method then derives a suite of test sequences by using a model checker’s ability to construct counterexamples. The paper presents the results of applying our method to four specifications, including a sizable component of a contractor specification of a real system.KeywordsModel CheckerTest SequenceReachable StateInput EventEvent TableThese keywords were added by machine and not by the authors. This process is experimental and the keywords may be updated as the learning algorithm improves.}}
@ARTICLE{Burkard_null,title={Assignment Problems},year={null},author={Rainer E. Burkard and Rainer Burkard and Mauro Dell’Amico and Mauro Dell'Amico and Silvano Martello and Silvano Martello},doi={10.1137/1.9780898717754},pmid={null},pmcid={null},mag_id={4239749705},journal={null},abstract={null}}
@ARTICLE{Land_null,title={An Automatic Method of Solving Discrete Programming Problems},year={null},author={A. H. Land and A. H. Land and A. G. Doig and A. G. Doig},doi={10.2307/1910129},pmid={null},pmcid={null},mag_id={4240374930},journal={Econometrica},abstract={null}}
@ARTICLE{Yang_null,title={Validation with guided search of the state space},year={null},author={C.H. Yang and C.H. Yang and D.L. Dill and D.L. Dill},doi={10.1109/dac.1998.724542},pmid={null},pmcid={null},mag_id={4246699818},journal={null},abstract={null}}
@ARTICLE{Godefroid_null,title={Exploring Very Large State Spaces Using Genetic Algorithms},year={null},author={Patrice Godefroid and Patrice Godefroid and Sarfraz Khurshid and Sarfraz Khurshid},doi={10.1007/3-540-46002-0_19},pmid={null},pmcid={null},mag_id={4247042060},journal={Lecture Notes in Computer Science},abstract={We present a novel framework for exploring very large state spaces of concurrent reactive systems. Our framework exploits application-independent heuristics using genetic algorithms to guide a state-space search towards error states.We have implemented this frameworkin conjunction with VeriSoft, a tool for exploring the state spaces of software applications composed of several concurrent processes executing arbitrary code. We present experimental results obtained with several examples of programs, including a C implementation of a public key authentication protocol.We discuss heuristics and properties of state spaces that help a genetic search detect deadlocks and assertion violations. For finding errors in very large state spaces, our experiments show that a genetic search using simple heuristics can significantly outperform random and systematic searches.}}
@ARTICLE{Alur_null,title={Timed Automata},year={null},author={Rajeev Alur and Rajeev Alur},doi={10.1007/3-540-48683-6_3},pmid={null},pmcid={null},mag_id={4253563042},journal={Lecture Notes in Computer Science},abstract={Model checking is emerging as a practical tool for automated debugging of complex reactive systems such as embedded controllers and network protocols (see [23] for a survey). Traditional techniques for model checking do not admit an explicit modeling of time, and are thus, unsuitable for analysis of real-time systems whose correctness depends on relative magnitudes of different delays. Consequently, timed automata [7] were introduced as a formal notation to model the behavior of real-time systems. Its definition provides a simple way to annotate state-transition graphs with timing constraints using finitely many real-valued clock variables. Automated analysis of timed automata relies on the construction of a finite quotient of the infinite space of clock valuations. Over the years, the formalism has been extensively studied leading to many results establishing connections to circuits and logic, and much progress has been made in developing verification algorithms, heuristics, and tools. This paper provides a survey of the theory of timed automata, and their role in specification and verification of real-time systems.}}
@ARTICLE{Corbett_null,title={Bandera: extracting finite-state models from Java source code},year={null},author={J.C. Corbett and J.C. Corbett and Matthew B. Dwyer and M.B. Dwyer and John Hatcliff and J. Hatcliff and S. Laubach and S. Laubach and Corina S. Pǎsǎreanu and C.S. Pasareanu and . Robby and None Robby and Hongjun Zhang and None Hongjun Zheng},doi={10.1109/icse.2000.870434},pmid={null},pmcid={null},mag_id={4256144738},journal={null},abstract={null}}
@ARTICLE{McMillan_1993,title={Symbolic Model Checking},year={1993},author={Kenneth L. McMillan and Kenneth L. McMillan},doi={10.1007/978-1-4615-3190-6},pmid={null},pmcid={null},mag_id={4300021588},journal={null},abstract={null}}
